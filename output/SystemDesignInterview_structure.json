{
  "title": "Untitled Document",
  "outline": [
    {
      "heading": "System Design Interview: An Insider’s Guide",
      "level": 2,
      "page": 2
    },
    {
      "heading": "All rights reserved. This book or any portion thereof may not be reproduced or used in any",
      "level": 3,
      "page": 2
    },
    {
      "heading": "manner whatsoever without the express written permission of the publisher except for the use",
      "level": 3,
      "page": 2
    },
    {
      "heading": "of brief quotations in a book review.",
      "level": 3,
      "page": 2
    },
    {
      "heading": "About the author:",
      "level": 3,
      "page": 2
    },
    {
      "heading": "Alex Xu is an experienced software engineer and entrepreneur. Previously, he worked at",
      "level": 3,
      "page": 2
    },
    {
      "heading": "Twitter, Apple, Zynga and Oracle. He received his M.S. from Carnegie Mellon University.",
      "level": 3,
      "page": 2
    },
    {
      "heading": "He has a passion for designing and implementing complex systems.",
      "level": 3,
      "page": 2
    },
    {
      "heading": "Please subscribe to our email list if you want to be notified when new chapters are available:",
      "level": 3,
      "page": 2
    },
    {
      "heading": "https://bit.ly/3dtIcsE",
      "level": 3,
      "page": 2
    },
    {
      "heading": "For more information, contact systemdesigninsider@gmail.com",
      "level": 3,
      "page": 2
    },
    {
      "heading": "Editor: Paul Solomon",
      "level": 3,
      "page": 2
    },
    {
      "heading": "Table of Contents",
      "level": 2,
      "page": 3
    },
    {
      "heading": "System Design Interview: An Insider’s Guide",
      "level": 3,
      "page": 3
    },
    {
      "heading": "FORWARD",
      "level": 3,
      "page": 3
    },
    {
      "heading": "CHAPTER 1: SCALE FROM ZERO TO MILLIONS OF USERS",
      "level": 3,
      "page": 3
    },
    {
      "heading": "CHAPTER 2: BACK-OF-THE-ENVELOPE ESTIMATION",
      "level": 3,
      "page": 3
    },
    {
      "heading": "CHAPTER 3: A FRAMEWORK FOR SYSTEM DESIGN INTERVIEWS",
      "level": 3,
      "page": 3
    },
    {
      "heading": "CHAPTER 4: DESIGN A RATE LIMITER",
      "level": 3,
      "page": 3
    },
    {
      "heading": "CHAPTER 5: DESIGN CONSISTENT HASHING",
      "level": 3,
      "page": 3
    },
    {
      "heading": "CHAPTER 6: DESIGN A KEY-VALUE STORE",
      "level": 3,
      "page": 3
    },
    {
      "heading": "CHAPTER 7: DESIGN A UNIQUE ID GENERATOR IN DISTRIBUTED SYSTEMS",
      "level": 3,
      "page": 3
    },
    {
      "heading": "CHAPTER 8: DESIGN A URL SHORTENER",
      "level": 3,
      "page": 3
    },
    {
      "heading": "CHAPTER 9: DESIGN A WEB CRAWLER",
      "level": 3,
      "page": 3
    },
    {
      "heading": "CHAPTER 10: DESIGN A NOTIFICATION SYSTEM",
      "level": 3,
      "page": 3
    },
    {
      "heading": "CHAPTER 11: DESIGN A NEWS FEED SYSTEM",
      "level": 3,
      "page": 3
    },
    {
      "heading": "CHAPTER 12: DESIGN A CHAT SYSTEM",
      "level": 3,
      "page": 3
    },
    {
      "heading": "CHAPTER 13: DESIGN A SEARCH AUTOCOMPLETE SYSTEM",
      "level": 3,
      "page": 3
    },
    {
      "heading": "CHAPTER 14: DESIGN YOUTUBE",
      "level": 3,
      "page": 3
    },
    {
      "heading": "CHAPTER 15: DESIGN GOOGLE DRIVE",
      "level": 3,
      "page": 3
    },
    {
      "heading": "CHAPTER 16: THE LEARNING CONTINUES",
      "level": 3,
      "page": 3
    },
    {
      "heading": "AFTERWORD",
      "level": 3,
      "page": 3
    },
    {
      "heading": "FORWARD",
      "level": 1,
      "page": 4
    },
    {
      "heading": "We are delighted that you have decided to join us in learning the system design interviews.",
      "level": 3,
      "page": 4
    },
    {
      "heading": "System design interview questions are the most difficult to tackle among all the technical",
      "level": 3,
      "page": 4
    },
    {
      "heading": "interviews. The questions require the interviewees to design an architecture for a software",
      "level": 3,
      "page": 4
    },
    {
      "heading": "system, which could be a news feed, Google search, chat system, etc. These questions are",
      "level": 3,
      "page": 4
    },
    {
      "heading": "intimidating, and there is no certain pattern to follow. The questions are usually very big",
      "level": 3,
      "page": 4
    },
    {
      "heading": "scoped and vague. The processes are open-ended and unclear without a standard or correct",
      "level": 3,
      "page": 4
    },
    {
      "heading": "answer.",
      "level": 3,
      "page": 4
    },
    {
      "heading": "Companies widely adopt system design interviews because the communication and problem-",
      "level": 3,
      "page": 4
    },
    {
      "heading": "solving skills tested in these interviews are similar to those required by a software engineer’s",
      "level": 3,
      "page": 4
    },
    {
      "heading": "daily work. An interviewee is evaluated based on how she analyzes a vague problem and how",
      "level": 3,
      "page": 4
    },
    {
      "heading": "she solves the problem step by step. The abilities tested also involve how she explains the",
      "level": 3,
      "page": 4
    },
    {
      "heading": "idea, discusses with others, and evaluates and optimizes the system. In English, using “she”",
      "level": 3,
      "page": 4
    },
    {
      "heading": "flows better than “he or she” or jumping between the two. To make reading easier, we use the",
      "level": 3,
      "page": 4
    },
    {
      "heading": "feminine pronoun throughout this book. No disrespect is intended for male engineers.",
      "level": 3,
      "page": 4
    },
    {
      "heading": "The system design questions are open-ended. Just like in the real world, there are many",
      "level": 3,
      "page": 4
    },
    {
      "heading": "differences and variations in the system. The desired outcome is to come up with an",
      "level": 3,
      "page": 4
    },
    {
      "heading": "architecture to achieve system design goals. The discussions could go in different ways",
      "level": 3,
      "page": 4
    },
    {
      "heading": "depending on the interviewer. Some interviewers may choose high-level architecture to cover",
      "level": 3,
      "page": 4
    },
    {
      "heading": "all aspects; whereas some might choose one or more areas to focus on. Typically, system",
      "level": 3,
      "page": 4
    },
    {
      "heading": "requirements, constraints and bottlenecks should be well understood to shape the direction of",
      "level": 3,
      "page": 4
    },
    {
      "heading": "both the interviewer and interviewee.",
      "level": 3,
      "page": 4
    },
    {
      "heading": "The objective of this book is to provide a reliable strategy to approach the system design",
      "level": 3,
      "page": 4
    },
    {
      "heading": "questions. The right strategy and knowledge are vital to the success of an interview.",
      "level": 3,
      "page": 4
    },
    {
      "heading": "This book provides solid knowledge in building a scalable system. The more knowledge",
      "level": 3,
      "page": 4
    },
    {
      "heading": "gained from reading this book, the better you are equipped in solving the system design",
      "level": 3,
      "page": 4
    },
    {
      "heading": "questions.",
      "level": 3,
      "page": 4
    },
    {
      "heading": "This book also provides a step by step framework on how to tackle a system design question.",
      "level": 3,
      "page": 4
    },
    {
      "heading": "It provides many examples to illustrate the systematic approach with detailed steps that you",
      "level": 3,
      "page": 4
    },
    {
      "heading": "can follow. With constant practice, you will be well-equipped to tackle system design",
      "level": 3,
      "page": 4
    },
    {
      "heading": "interview questions.",
      "level": 3,
      "page": 4
    },
    {
      "heading": "CHAPTER 1: SCALE FROM ZERO TO MILLIONS OF",
      "level": 1,
      "page": 5
    },
    {
      "heading": "USERS",
      "level": 1,
      "page": 5
    },
    {
      "heading": "Designing a system that supports millions of users is challenging, and it is a journey that",
      "level": 3,
      "page": 5
    },
    {
      "heading": "requires continuous refinement and endless improvement. In this chapter, we build a system",
      "level": 3,
      "page": 5
    },
    {
      "heading": "that supports a single user and gradually scale it up to serve millions of users. After reading",
      "level": 3,
      "page": 5
    },
    {
      "heading": "this chapter, you will master a handful of techniques that will help you to crack the system",
      "level": 3,
      "page": 5
    },
    {
      "heading": "design interview questions.",
      "level": 3,
      "page": 5
    },
    {
      "heading": "Single server setup",
      "level": 3,
      "page": 6
    },
    {
      "heading": "A journey of a thousand miles begins with a single step, and building a complex system is no",
      "level": 3,
      "page": 6
    },
    {
      "heading": "different. To start with something simple, everything is running on a single server. Figure 1-1",
      "level": 3,
      "page": 6
    },
    {
      "heading": "shows the illustration of a single server setup where everything is running on one server: web",
      "level": 3,
      "page": 6
    },
    {
      "heading": "app, database, cache, etc.",
      "level": 3,
      "page": 6
    },
    {
      "heading": "To understand this setup, it is helpful to investigate the request flow and traffic source. Let us",
      "level": 3,
      "page": 6
    },
    {
      "heading": "first look at the request flow (Figure 1-2).",
      "level": 3,
      "page": 6
    },
    {
      "heading": "1. Users access websites through domain names, such as api.mysite.com. Usually, the",
      "level": 3,
      "page": 7
    },
    {
      "heading": "Domain Name System (DNS) is a paid service provided by 3rd parties and not hosted by",
      "level": 3,
      "page": 7
    },
    {
      "heading": "our servers.",
      "level": 3,
      "page": 7
    },
    {
      "heading": "2. Internet Protocol (IP) address is returned to the browser or mobile app. In the example,",
      "level": 3,
      "page": 7
    },
    {
      "heading": "IP address 15.125.23.214 is returned.",
      "level": 3,
      "page": 7
    },
    {
      "heading": "3. Once the IP address is obtained, Hypertext Transfer Protocol (HTTP) [1] requests are",
      "level": 3,
      "page": 7
    },
    {
      "heading": "sent directly to your web server.",
      "level": 3,
      "page": 7
    },
    {
      "heading": "4. The web server returns HTML pages or JSON response for rendering.",
      "level": 3,
      "page": 7
    },
    {
      "heading": "Next, let us examine the traffic source. The traffic to your web server comes from two",
      "level": 3,
      "page": 7
    },
    {
      "heading": "sources: web application and mobile application.",
      "level": 3,
      "page": 7
    },
    {
      "heading": "• Web application: it uses a combination of server-side languages (Java, Python, etc.) to",
      "level": 3,
      "page": 7
    },
    {
      "heading": "handle business logic, storage, etc., and client-side languages (HTML and JavaScript) for",
      "level": 3,
      "page": 7
    },
    {
      "heading": "presentation.",
      "level": 3,
      "page": 7
    },
    {
      "heading": "• Mobile application: HTTP protocol is the communication protocol between the mobile",
      "level": 3,
      "page": 7
    },
    {
      "heading": "app and the web server. JavaScript Object Notation (JSON) is commonly used API",
      "level": 3,
      "page": 7
    },
    {
      "heading": "response format to transfer data due to its simplicity. An example of the API response in",
      "level": 3,
      "page": 7
    },
    {
      "heading": "JSON format is shown below:",
      "level": 3,
      "page": 7
    },
    {
      "heading": "GET /users/12 – Retrieve user object for id = 12",
      "level": 3,
      "page": 7
    },
    {
      "heading": "Database",
      "level": 3,
      "page": 8
    },
    {
      "heading": "With the growth of the user base, one server is not enough, and we need multiple servers: one",
      "level": 3,
      "page": 8
    },
    {
      "heading": "for web/mobile traffic, the other for the database (Figure 1-3). Separating web/mobile traffic",
      "level": 3,
      "page": 8
    },
    {
      "heading": "(web tier) and database (data tier) servers allows them to be scaled independently.",
      "level": 3,
      "page": 8
    },
    {
      "heading": "Which databases to use?",
      "level": 3,
      "page": 8
    },
    {
      "heading": "You can choose between a traditional relational database and a non-relational database. Let",
      "level": 3,
      "page": 8
    },
    {
      "heading": "us examine their differences.",
      "level": 3,
      "page": 8
    },
    {
      "heading": "Relational databases are also called a relational database management system (RDBMS) or",
      "level": 3,
      "page": 8
    },
    {
      "heading": "SQL database. The most popular ones are MySQL, Oracle database, PostgreSQL, etc.",
      "level": 3,
      "page": 8
    },
    {
      "heading": "Relational databases represent and store data in tables and rows. You can perform join",
      "level": 3,
      "page": 8
    },
    {
      "heading": "operations using SQL across different database tables.",
      "level": 3,
      "page": 8
    },
    {
      "heading": "Non-Relational databases are also called NoSQL databases. Popular ones are CouchDB,",
      "level": 3,
      "page": 8
    },
    {
      "heading": "Neo4j, Cassandra, HBase, Amazon DynamoDB, etc. [2]. These databases are grouped into",
      "level": 3,
      "page": 8
    },
    {
      "heading": "operations are generally not supported in non-relational databases.",
      "level": 3,
      "page": 8
    },
    {
      "heading": "For most developers, relational databases are the best option because they have been around",
      "level": 3,
      "page": 8
    },
    {
      "heading": "for over 40 years and historically, they have worked well. However, if relational databases",
      "level": 3,
      "page": 8
    },
    {
      "heading": "are not suitable for your specific use cases, it is critical to explore beyond relational",
      "level": 3,
      "page": 8
    },
    {
      "heading": "databases. Non-relational databases might be the right choice if:",
      "level": 3,
      "page": 8
    },
    {
      "heading": "• Your application requires super-low latency.",
      "level": 3,
      "page": 8
    },
    {
      "heading": "• Your data are unstructured, or you do not have any relational data.",
      "level": 3,
      "page": 8
    },
    {
      "heading": "• You only need to serialize and deserialize data (JSON, XML, YAML, etc.).",
      "level": 3,
      "page": 8
    },
    {
      "heading": "• You need to store a massive amount of data.",
      "level": 3,
      "page": 8
    },
    {
      "heading": "Vertical scaling vs horizontal scaling",
      "level": 3,
      "page": 9
    },
    {
      "heading": "Vertical scaling, referred to as “scale up”, means the process of adding more power (CPU,",
      "level": 3,
      "page": 9
    },
    {
      "heading": "RAM, etc.) to your servers. Horizontal scaling, referred to as “scale-out”, allows you to scale",
      "level": 3,
      "page": 9
    },
    {
      "heading": "by adding more servers into your pool of resources.",
      "level": 3,
      "page": 9
    },
    {
      "heading": "When traffic is low, vertical scaling is a great option, and the simplicity of vertical scaling is",
      "level": 3,
      "page": 9
    },
    {
      "heading": "its main advantage. Unfortunately, it comes with serious limitations.",
      "level": 3,
      "page": 9
    },
    {
      "heading": "• Vertical scaling has a hard limit. It is impossible to add unlimited CPU and memory to a",
      "level": 3,
      "page": 9
    },
    {
      "heading": "single server.",
      "level": 3,
      "page": 9
    },
    {
      "heading": "• Vertical scaling does not have failover and redundancy. If one server goes down, the",
      "level": 3,
      "page": 9
    },
    {
      "heading": "website/app goes down with it completely.",
      "level": 3,
      "page": 9
    },
    {
      "heading": "Horizontal scaling is more desirable for large scale applications due to the limitations of",
      "level": 3,
      "page": 9
    },
    {
      "heading": "vertical scaling.",
      "level": 3,
      "page": 9
    },
    {
      "heading": "In the previous design, users are connected to the web server directly. Users will unable to",
      "level": 3,
      "page": 9
    },
    {
      "heading": "access the website if the web server is offline. In another scenario, if many users access the",
      "level": 3,
      "page": 9
    },
    {
      "heading": "web server simultaneously and it reaches the web server’s load limit, users generally",
      "level": 3,
      "page": 9
    },
    {
      "heading": "experience slower response or fail to connect to the server. A load balancer is the best",
      "level": 3,
      "page": 9
    },
    {
      "heading": "technique to address these problems.",
      "level": 3,
      "page": 9
    },
    {
      "heading": "Load balancer",
      "level": 3,
      "page": 10
    },
    {
      "heading": "A load balancer evenly distributes incoming traffic among web servers that are defined in a",
      "level": 3,
      "page": 10
    },
    {
      "heading": "load-balanced set. Figure 1-4 shows how a load balancer works.",
      "level": 3,
      "page": 10
    },
    {
      "heading": "As shown in Figure 1-4, users connect to the public IP of the load balancer directly. With this",
      "level": 3,
      "page": 10
    },
    {
      "heading": "setup, web servers are unreachable directly by clients anymore. For better security, private",
      "level": 3,
      "page": 10
    },
    {
      "heading": "IPs are used for communication between servers. A private IP is an IP address reachable only",
      "level": 3,
      "page": 10
    },
    {
      "heading": "between servers in the same network; however, it is unreachable over the internet. The load",
      "level": 3,
      "page": 10
    },
    {
      "heading": "balancer communicates with web servers through private IPs.",
      "level": 3,
      "page": 10
    },
    {
      "heading": "In Figure 1-4, after a load balancer and a second web server are added, we successfully",
      "level": 3,
      "page": 10
    },
    {
      "heading": "solved no failover issue and improved the availability of the web tier. Details are explained",
      "level": 3,
      "page": 10
    },
    {
      "heading": "below:",
      "level": 3,
      "page": 10
    },
    {
      "heading": "• If server 1 goes offline, all the traffic will be routed to server 2. This prevents the website",
      "level": 3,
      "page": 10
    },
    {
      "heading": "from going offline. We will also add a new healthy web server to the server pool to",
      "level": 3,
      "page": 10
    },
    {
      "heading": "balance the load.",
      "level": 3,
      "page": 10
    },
    {
      "heading": "• If the website traffic grows rapidly, and two servers are not enough to handle the traffic,",
      "level": 3,
      "page": 10
    },
    {
      "heading": "the load balancer can handle this problem gracefully. You only need to add more servers",
      "level": 3,
      "page": 10
    },
    {
      "heading": "to the web server pool, and the load balancer automatically starts to send requests to them.",
      "level": 3,
      "page": 10
    },
    {
      "heading": "Now the web tier looks good, what about the data tier? The current design has one database,",
      "level": 3,
      "page": 10
    },
    {
      "heading": "so it does not support failover and redundancy. Database replication is a common technique",
      "level": 3,
      "page": 11
    },
    {
      "heading": "to address those problems. Let us take a look.",
      "level": 3,
      "page": 11
    },
    {
      "heading": "Database replication",
      "level": 3,
      "page": 12
    },
    {
      "heading": "Quoted from Wikipedia: “Database replication can be used in many database management",
      "level": 3,
      "page": 12
    },
    {
      "heading": "systems, usually with a master/slave relationship between the original (master) and the copies",
      "level": 3,
      "page": 12
    },
    {
      "heading": "(slaves)” [3].",
      "level": 3,
      "page": 12
    },
    {
      "heading": "A master database generally only supports write operations. A slave database gets copies of",
      "level": 3,
      "page": 12
    },
    {
      "heading": "the data from the master database and only supports read operations. All the data-modifying",
      "level": 3,
      "page": 12
    },
    {
      "heading": "commands like insert, delete, or update must be sent to the master database. Most",
      "level": 3,
      "page": 12
    },
    {
      "heading": "applications require a much higher ratio of reads to writes; thus, the number of slave",
      "level": 3,
      "page": 12
    },
    {
      "heading": "databases in a system is usually larger than the number of master databases. Figure 1-5 shows",
      "level": 3,
      "page": 12
    },
    {
      "heading": "a master database with multiple slave databases.",
      "level": 3,
      "page": 12
    },
    {
      "heading": "Advantages of database replication:",
      "level": 3,
      "page": 12
    },
    {
      "heading": "• Better performance: In the master-slave model, all writes and updates happen in master",
      "level": 3,
      "page": 12
    },
    {
      "heading": "nodes; whereas, read operations are distributed across slave nodes. This model improves",
      "level": 3,
      "page": 12
    },
    {
      "heading": "performance because it allows more queries to be processed in parallel.",
      "level": 3,
      "page": 12
    },
    {
      "heading": "• Reliability: If one of your database servers is destroyed by a natural disaster, such as a",
      "level": 3,
      "page": 12
    },
    {
      "heading": "typhoon or an earthquake, data is still preserved. You do not need to worry about data loss",
      "level": 3,
      "page": 12
    },
    {
      "heading": "because data is replicated across multiple locations.",
      "level": 3,
      "page": 12
    },
    {
      "heading": "• High availability: By replicating data across different locations, your website remains in",
      "level": 3,
      "page": 12
    },
    {
      "heading": "operation even if a database is offline as you can access data stored in another database",
      "level": 3,
      "page": 13
    },
    {
      "heading": "server.",
      "level": 3,
      "page": 13
    },
    {
      "heading": "In the previous section, we discussed how a load balancer helped to improve system",
      "level": 3,
      "page": 13
    },
    {
      "heading": "availability. We ask the same question here: what if one of the databases goes offline? The",
      "level": 3,
      "page": 13
    },
    {
      "heading": "architectural design discussed in Figure 1-5 can handle this case:",
      "level": 3,
      "page": 13
    },
    {
      "heading": "• If only one slave database is available and it goes offline, read operations will be directed",
      "level": 3,
      "page": 13
    },
    {
      "heading": "to the master database temporarily. As soon as the issue is found, a new slave database",
      "level": 3,
      "page": 13
    },
    {
      "heading": "will replace the old one. In case multiple slave databases are available, read operations are",
      "level": 3,
      "page": 13
    },
    {
      "heading": "redirected to other healthy slave databases. A new database server will replace the old one.",
      "level": 3,
      "page": 13
    },
    {
      "heading": "• If the master database goes offline, a slave database will be promoted to be the new",
      "level": 3,
      "page": 13
    },
    {
      "heading": "master. All the database operations will be temporarily executed on the new master",
      "level": 3,
      "page": 13
    },
    {
      "heading": "database. A new slave database will replace the old one for data replication immediately.",
      "level": 3,
      "page": 13
    },
    {
      "heading": "In production systems, promoting a new master is more complicated as the data in a slave",
      "level": 3,
      "page": 13
    },
    {
      "heading": "database might not be up to date. The missing data needs to be updated by running data",
      "level": 3,
      "page": 13
    },
    {
      "heading": "recovery scripts. Although some other replication methods like multi-masters and circular",
      "level": 3,
      "page": 13
    },
    {
      "heading": "replication could help, those setups are more complicated; and their discussions are",
      "level": 3,
      "page": 13
    },
    {
      "heading": "beyond the scope of this book. Interested readers should refer to the listed reference",
      "level": 3,
      "page": 13
    },
    {
      "heading": "materials [4] [5].",
      "level": 3,
      "page": 13
    },
    {
      "heading": "Figure 1-6 shows the system design after adding the load balancer and database replication.",
      "level": 3,
      "page": 13
    },
    {
      "heading": "Let us take a look at the design:",
      "level": 3,
      "page": 14
    },
    {
      "heading": "• A user gets the IP address of the load balancer from DNS.",
      "level": 3,
      "page": 14
    },
    {
      "heading": "• A user connects the load balancer with this IP address.",
      "level": 3,
      "page": 14
    },
    {
      "heading": "• The HTTP request is routed to either Server 1 or Server 2.",
      "level": 3,
      "page": 14
    },
    {
      "heading": "• A web server reads user data from a slave database.",
      "level": 3,
      "page": 14
    },
    {
      "heading": "• A web server routes any data-modifying operations to the master database. This includes",
      "level": 3,
      "page": 14
    },
    {
      "heading": "write, update, and delete operations.",
      "level": 3,
      "page": 14
    },
    {
      "heading": "Now, you have a solid understanding of the web and data tiers, it is time to improve the",
      "level": 3,
      "page": 14
    },
    {
      "heading": "load/response time. This can be done by adding a cache layer and shifting static content",
      "level": 3,
      "page": 14
    },
    {
      "heading": "(JavaScript/CSS/image/video files) to the content delivery network (CDN).",
      "level": 3,
      "page": 14
    },
    {
      "heading": "Cache",
      "level": 3,
      "page": 15
    },
    {
      "heading": "A cache is a temporary storage area that stores the result of expensive responses or frequently",
      "level": 3,
      "page": 15
    },
    {
      "heading": "accessed data in memory so that subsequent requests are served more quickly. As illustrated",
      "level": 3,
      "page": 15
    },
    {
      "heading": "in Figure 1-6, every time a new web page loads, one or more database calls are executed to",
      "level": 3,
      "page": 15
    },
    {
      "heading": "fetch data. The application performance is greatly affected by calling the database repeatedly.",
      "level": 3,
      "page": 15
    },
    {
      "heading": "The cache can mitigate this problem.",
      "level": 3,
      "page": 15
    },
    {
      "heading": "Cache tier",
      "level": 3,
      "page": 15
    },
    {
      "heading": "The cache tier is a temporary data store layer, much faster than the database. The benefits of",
      "level": 3,
      "page": 15
    },
    {
      "heading": "having a separate cache tier include better system performance, ability to reduce database",
      "level": 3,
      "page": 15
    },
    {
      "heading": "workloads, and the ability to scale the cache tier independently. Figure 1-7 shows a possible",
      "level": 3,
      "page": 15
    },
    {
      "heading": "setup of a cache server:",
      "level": 3,
      "page": 15
    },
    {
      "heading": "After receiving a request, a web server first checks if the cache has the available response. If",
      "level": 3,
      "page": 15
    },
    {
      "heading": "it has, it sends data back to the client. If not, it queries the database, stores the response in",
      "level": 3,
      "page": 15
    },
    {
      "heading": "cache, and sends it back to the client. This caching strategy is called a read-through cache.",
      "level": 3,
      "page": 15
    },
    {
      "heading": "Other caching strategies are available depending on the data type, size, and access patterns. A",
      "level": 3,
      "page": 15
    },
    {
      "heading": "previous study explains how different caching strategies work [6].",
      "level": 3,
      "page": 15
    },
    {
      "heading": "Interacting with cache servers is simple because most cache servers provide APIs for",
      "level": 3,
      "page": 15
    },
    {
      "heading": "common programming languages. The following code snippet shows typical Memcached",
      "level": 3,
      "page": 15
    },
    {
      "heading": "APIs:",
      "level": 3,
      "page": 15
    },
    {
      "heading": "Considerations for using cache",
      "level": 3,
      "page": 15
    },
    {
      "heading": "Here are a few considerations for using a cache system:",
      "level": 3,
      "page": 15
    },
    {
      "heading": "• Decide when to use cache. Consider using cache when data is read frequently but",
      "level": 3,
      "page": 15
    },
    {
      "heading": "modified infrequently. Since cached data is stored in volatile memory, a cache server is",
      "level": 3,
      "page": 15
    },
    {
      "heading": "not ideal for persisting data. For instance, if a cache server restarts, all the data in memory",
      "level": 3,
      "page": 15
    },
    {
      "heading": "is lost. Thus, important data should be saved in persistent data stores.",
      "level": 3,
      "page": 15
    },
    {
      "heading": "• Expiration policy. It is a good practice to implement an expiration policy. Once cached",
      "level": 3,
      "page": 15
    },
    {
      "heading": "data is expired, it is removed from the cache. When there is no expiration policy, cached",
      "level": 3,
      "page": 15
    },
    {
      "heading": "data will be stored in the memory permanently. It is advisable not to make the expiration",
      "level": 3,
      "page": 15
    },
    {
      "heading": "date too short as this will cause the system to reload data from the database too frequently.",
      "level": 3,
      "page": 15
    },
    {
      "heading": "Meanwhile, it is advisable not to make the expiration date too long as the data can become",
      "level": 3,
      "page": 15
    },
    {
      "heading": "stale.",
      "level": 3,
      "page": 15
    },
    {
      "heading": "• Consistency: This involves keeping the data store and the cache in sync. Inconsistency",
      "level": 3,
      "page": 15
    },
    {
      "heading": "can happen because data-modifying operations on the data store and cache are not in a",
      "level": 3,
      "page": 15
    },
    {
      "heading": "single transaction. When scaling across multiple regions, maintaining consistency between",
      "level": 3,
      "page": 15
    },
    {
      "heading": "the data store and cache is challenging. For further details, refer to the paper titled",
      "level": 3,
      "page": 16
    },
    {
      "heading": "“Scaling Memcache at Facebook” published by Facebook [7].",
      "level": 3,
      "page": 16
    },
    {
      "heading": "• Mitigating failures: A single cache server represents a potential single point of failure",
      "level": 3,
      "page": 16
    },
    {
      "heading": "(SPOF), defined in Wikipedia as follows: “A single point of failure (SPOF) is a part of a",
      "level": 3,
      "page": 16
    },
    {
      "heading": "system that, if it fails, will stop the entire system from working” [8]. As a result, multiple",
      "level": 3,
      "page": 16
    },
    {
      "heading": "cache servers across different data centers are recommended to avoid SPOF. Another",
      "level": 3,
      "page": 16
    },
    {
      "heading": "recommended approach is to overprovision the required memory by certain percentages.",
      "level": 3,
      "page": 16
    },
    {
      "heading": "This provides a buffer as the memory usage increases.",
      "level": 3,
      "page": 16
    },
    {
      "heading": "• Eviction Policy: Once the cache is full, any requests to add items to the cache might",
      "level": 3,
      "page": 16
    },
    {
      "heading": "cause existing items to be removed. This is called cache eviction. Least-recently-used",
      "level": 3,
      "page": 16
    },
    {
      "heading": "(LRU) is the most popular cache eviction policy. Other eviction policies, such as the Least",
      "level": 3,
      "page": 16
    },
    {
      "heading": "Frequently Used (LFU) or First in First Out (FIFO), can be adopted to satisfy different use",
      "level": 3,
      "page": 16
    },
    {
      "heading": "cases.",
      "level": 3,
      "page": 16
    },
    {
      "heading": "Content delivery network (CDN)",
      "level": 3,
      "page": 17
    },
    {
      "heading": "A CDN is a network of geographically dispersed servers used to deliver static content. CDN",
      "level": 3,
      "page": 17
    },
    {
      "heading": "servers cache static content like images, videos, CSS, JavaScript files, etc.",
      "level": 3,
      "page": 17
    },
    {
      "heading": "Dynamic content caching is a relatively new concept and beyond the scope of this book. It",
      "level": 3,
      "page": 17
    },
    {
      "heading": "enables the caching of HTML pages that are based on request path, query strings, cookies,",
      "level": 3,
      "page": 17
    },
    {
      "heading": "and request headers. Refer to the article mentioned in reference material [9] for more about",
      "level": 3,
      "page": 17
    },
    {
      "heading": "this. This book focuses on how to use CDN to cache static content.",
      "level": 3,
      "page": 17
    },
    {
      "heading": "Here is how CDN works at the high-level: when a user visits a website, a CDN server closest",
      "level": 3,
      "page": 17
    },
    {
      "heading": "to the user will deliver static content. Intuitively, the further users are from CDN servers, the",
      "level": 3,
      "page": 17
    },
    {
      "heading": "slower the website loads. For example, if CDN servers are in San Francisco, users in Los",
      "level": 3,
      "page": 17
    },
    {
      "heading": "Angeles will get content faster than users in Europe. Figure 1-9 is a great example that shows",
      "level": 3,
      "page": 17
    },
    {
      "heading": "how CDN improves load time.",
      "level": 3,
      "page": 17
    },
    {
      "heading": "Figure 1-10 demonstrates the CDN workflow.",
      "level": 3,
      "page": 17
    },
    {
      "heading": "1. User A tries to get image.png by using an image URL. The URL’s domain is provided",
      "level": 3,
      "page": 17
    },
    {
      "heading": "by the CDN provider. The following two image URLs are samples used to demonstrate",
      "level": 3,
      "page": 17
    },
    {
      "heading": "what image URLs look like on Amazon and Akamai CDNs:",
      "level": 3,
      "page": 17
    },
    {
      "heading": "• https://mysite.cloudfront.net/logo.jpg",
      "level": 3,
      "page": 17
    },
    {
      "heading": "• https://mysite.akamai.com/image-manager/img/logo.jpg",
      "level": 3,
      "page": 17
    },
    {
      "heading": "2. If the CDN server does not have image.png in the cache, the CDN server requests the",
      "level": 3,
      "page": 17
    },
    {
      "heading": "file from the origin, which can be a web server or online storage like Amazon S3.",
      "level": 3,
      "page": 17
    },
    {
      "heading": "3. The origin returns image.png to the CDN server, which includes optional HTTP header",
      "level": 3,
      "page": 17
    },
    {
      "heading": "Time-to-Live (TTL) which describes how long the image is cached.",
      "level": 3,
      "page": 17
    },
    {
      "heading": "4. The CDN caches the image and returns it to User A. The image remains cached in the",
      "level": 3,
      "page": 18
    },
    {
      "heading": "CDN until the TTL expires.",
      "level": 3,
      "page": 18
    },
    {
      "heading": "5. User B sends a request to get the same image.",
      "level": 3,
      "page": 18
    },
    {
      "heading": "6. The image is returned from the cache as long as the TTL has not expired.",
      "level": 3,
      "page": 18
    },
    {
      "heading": "Considerations of using a CDN",
      "level": 3,
      "page": 18
    },
    {
      "heading": "• Cost: CDNs are run by third-party providers, and you are charged for data transfers in",
      "level": 3,
      "page": 18
    },
    {
      "heading": "and out of the CDN. Caching infrequently used assets provides no significant benefits so",
      "level": 3,
      "page": 18
    },
    {
      "heading": "you should consider moving them out of the CDN.",
      "level": 3,
      "page": 18
    },
    {
      "heading": "• Setting an appropriate cache expiry: For time-sensitive content, setting a cache expiry",
      "level": 3,
      "page": 18
    },
    {
      "heading": "time is important. The cache expiry time should neither be too long nor too short. If it is",
      "level": 3,
      "page": 18
    },
    {
      "heading": "too long, the content might no longer be fresh. If it is too short, it can cause repeat",
      "level": 3,
      "page": 18
    },
    {
      "heading": "reloading of content from origin servers to the CDN.",
      "level": 3,
      "page": 18
    },
    {
      "heading": "• CDN fallback: You should consider how your website/application copes with CDN",
      "level": 3,
      "page": 18
    },
    {
      "heading": "failure. If there is a temporary CDN outage, clients should be able to detect the problem",
      "level": 3,
      "page": 18
    },
    {
      "heading": "and request resources from the origin.",
      "level": 3,
      "page": 18
    },
    {
      "heading": "• Invalidating files: You can remove a file from the CDN before it expires by performing",
      "level": 3,
      "page": 18
    },
    {
      "heading": "one of the following operations:",
      "level": 3,
      "page": 18
    },
    {
      "heading": "• Invalidate the CDN object using APIs provided by CDN vendors.",
      "level": 3,
      "page": 18
    },
    {
      "heading": "• Use object versioning to serve a different version of the object. To version an object,",
      "level": 3,
      "page": 18
    },
    {
      "heading": "you can add a parameter to the URL, such as a version number. For example, version",
      "level": 3,
      "page": 18
    },
    {
      "heading": "number 2 is added to the query string: image.png?v=2.",
      "level": 3,
      "page": 18
    },
    {
      "heading": "Figure 1-11 shows the design after the CDN and cache are added.",
      "level": 3,
      "page": 18
    },
    {
      "heading": "1. Static assets (JS, CSS, images, etc.,) are no longer served by web servers. They are",
      "level": 3,
      "page": 19
    },
    {
      "heading": "fetched from the CDN for better performance.",
      "level": 3,
      "page": 19
    },
    {
      "heading": "2. The database load is lightened by caching data.",
      "level": 3,
      "page": 19
    },
    {
      "heading": "Stateless web tier",
      "level": 3,
      "page": 20
    },
    {
      "heading": "Now it is time to consider scaling the web tier horizontally. For this, we need to move state",
      "level": 3,
      "page": 20
    },
    {
      "heading": "the persistent storage such as relational database or NoSQL. Each web server in the cluster",
      "level": 3,
      "page": 20
    },
    {
      "heading": "can access state data from databases. This is called stateless web tier.",
      "level": 3,
      "page": 20
    },
    {
      "heading": "Stateful architecture",
      "level": 3,
      "page": 20
    },
    {
      "heading": "A stateful server and stateless server has some key differences. A stateful server remembers",
      "level": 3,
      "page": 20
    },
    {
      "heading": "client data (state) from one request to the next. A stateless server keeps no state information.",
      "level": 3,
      "page": 20
    },
    {
      "heading": "Figure 1-12 shows an example of a stateful architecture.",
      "level": 3,
      "page": 20
    },
    {
      "heading": "In Figure 1-12, user A’s session data and profile image are stored in Server 1. To authenticate",
      "level": 3,
      "page": 20
    },
    {
      "heading": "User A, HTTP requests must be routed to Server 1. If a request is sent to other servers like",
      "level": 3,
      "page": 20
    },
    {
      "heading": "Server 2, authentication would fail because Server 2 does not contain User A’s session data.",
      "level": 3,
      "page": 20
    },
    {
      "heading": "Similarly, all HTTP requests from User B must be routed to Server 2; all requests from User",
      "level": 3,
      "page": 20
    },
    {
      "heading": "C must be sent to Server 3.",
      "level": 3,
      "page": 20
    },
    {
      "heading": "The issue is that every request from the same client must be routed to the same server. This",
      "level": 3,
      "page": 20
    },
    {
      "heading": "can be done with sticky sessions in most load balancers [10]; however, this adds the",
      "level": 3,
      "page": 20
    },
    {
      "heading": "overhead. Adding or removing servers is much more difficult with this approach. It is also",
      "level": 3,
      "page": 20
    },
    {
      "heading": "challenging to handle server failures.",
      "level": 3,
      "page": 20
    },
    {
      "heading": "Stateless architecture",
      "level": 3,
      "page": 20
    },
    {
      "heading": "Figure 1-13 shows the stateless architecture.",
      "level": 3,
      "page": 20
    },
    {
      "heading": "In this stateless architecture, HTTP requests from users can be sent to any web servers, which",
      "level": 3,
      "page": 21
    },
    {
      "heading": "out of web servers. A stateless system is simpler, more robust, and scalable.",
      "level": 3,
      "page": 21
    },
    {
      "heading": "Figure 1-14 shows the updated design with a stateless web tier.",
      "level": 3,
      "page": 21
    },
    {
      "heading": "In Figure 1-14, we move the session data out of the web tier and store them in the persistent",
      "level": 3,
      "page": 22
    },
    {
      "heading": "data store. The shared data store could be a relational database, Memcached/Redis, NoSQL,",
      "level": 3,
      "page": 22
    },
    {
      "heading": "etc. The NoSQL data store is chosen as it is easy to scale. Autoscaling means adding or",
      "level": 3,
      "page": 22
    },
    {
      "heading": "removing web servers automatically based on the traffic load. After the state data is removed",
      "level": 3,
      "page": 22
    },
    {
      "heading": "out of web servers, auto-scaling of the web tier is easily achieved by adding or removing",
      "level": 3,
      "page": 22
    },
    {
      "heading": "servers based on traffic load.",
      "level": 3,
      "page": 22
    },
    {
      "heading": "Your website grows rapidly and attracts a significant number of users internationally. To",
      "level": 3,
      "page": 22
    },
    {
      "heading": "improve availability and provide a better user experience across wider geographical areas,",
      "level": 3,
      "page": 22
    },
    {
      "heading": "supporting multiple data centers is crucial.",
      "level": 3,
      "page": 22
    },
    {
      "heading": "Data centers",
      "level": 3,
      "page": 23
    },
    {
      "heading": "Figure 1-15 shows an example setup with two data centers. In normal operation, users are",
      "level": 3,
      "page": 23
    },
    {
      "heading": "geoDNS-routed, also known as geo-routed, to the closest data center, with a split traffic of",
      "level": 3,
      "page": 23
    },
    {
      "heading": "x% in US-East and (100 – x)% in US-West. geoDNS is a DNS service that allows domain",
      "level": 3,
      "page": 23
    },
    {
      "heading": "names to be resolved to IP addresses based on the location of a user.",
      "level": 3,
      "page": 23
    },
    {
      "heading": "In the event of any significant data center outage, we direct all traffic to a healthy data center.",
      "level": 3,
      "page": 23
    },
    {
      "heading": "In Figure 1-16, data center 2 (US-West) is offline, and 100% of the traffic is routed to data",
      "level": 3,
      "page": 23
    },
    {
      "heading": "center 1 (US-East).",
      "level": 3,
      "page": 23
    },
    {
      "heading": "Several technical challenges must be resolved to achieve multi-data center setup:",
      "level": 3,
      "page": 24
    },
    {
      "heading": "• Traffic redirection: Effective tools are needed to direct traffic to the correct data center.",
      "level": 3,
      "page": 24
    },
    {
      "heading": "GeoDNS can be used to direct traffic to the nearest data center depending on where a user",
      "level": 3,
      "page": 24
    },
    {
      "heading": "is located.",
      "level": 3,
      "page": 24
    },
    {
      "heading": "• Data synchronization: Users from different regions could use different local databases or",
      "level": 3,
      "page": 24
    },
    {
      "heading": "caches. In failover cases, traffic might be routed to a data center where data is unavailable.",
      "level": 3,
      "page": 24
    },
    {
      "heading": "A common strategy is to replicate data across multiple data centers. A previous study",
      "level": 3,
      "page": 24
    },
    {
      "heading": "shows how Netflix implements asynchronous multi-data center replication [11].",
      "level": 3,
      "page": 24
    },
    {
      "heading": "• Test and deployment: With multi-data center setup, it is important to test your",
      "level": 3,
      "page": 24
    },
    {
      "heading": "website/application at different locations. Automated deployment tools are vital to keep",
      "level": 3,
      "page": 24
    },
    {
      "heading": "services consistent through all the data centers [11].",
      "level": 3,
      "page": 24
    },
    {
      "heading": "To further scale our system, we need to decouple different components of the system so they",
      "level": 3,
      "page": 24
    },
    {
      "heading": "can be scaled independently. Messaging queue is a key strategy employed by many real-",
      "level": 3,
      "page": 24
    },
    {
      "heading": "world distributed systems to solve this problem.",
      "level": 3,
      "page": 24
    },
    {
      "heading": "Message queue",
      "level": 3,
      "page": 25
    },
    {
      "heading": "A message queue is a durable component, stored in memory, that supports asynchronous",
      "level": 3,
      "page": 25
    },
    {
      "heading": "communication. It serves as a buffer and distributes asynchronous requests. The basic",
      "level": 3,
      "page": 25
    },
    {
      "heading": "architecture of a message queue is simple. Input services, called producers/publishers, create",
      "level": 3,
      "page": 25
    },
    {
      "heading": "messages, and publish them to a message queue. Other services or servers, called",
      "level": 3,
      "page": 25
    },
    {
      "heading": "consumers/subscribers, connect to the queue, and perform actions defined by the messages.",
      "level": 3,
      "page": 25
    },
    {
      "heading": "The model is shown in Figure 1-17.",
      "level": 3,
      "page": 25
    },
    {
      "heading": "Decoupling makes the message queue a preferred architecture for building a scalable and",
      "level": 3,
      "page": 25
    },
    {
      "heading": "reliable application. With the message queue, the producer can post a message to the queue",
      "level": 3,
      "page": 25
    },
    {
      "heading": "when the consumer is unavailable to process it. The consumer can read messages from the",
      "level": 3,
      "page": 25
    },
    {
      "heading": "queue even when the producer is unavailable.",
      "level": 3,
      "page": 25
    },
    {
      "heading": "Consider the following use case: your application supports photo customization, including",
      "level": 3,
      "page": 25
    },
    {
      "heading": "cropping, sharpening, blurring, etc. Those customization tasks take time to complete. In",
      "level": 3,
      "page": 25
    },
    {
      "heading": "processing workers pick up jobs from the message queue and asynchronously perform photo",
      "level": 3,
      "page": 25
    },
    {
      "heading": "customization tasks. The producer and the consumer can be scaled independently. When the",
      "level": 3,
      "page": 25
    },
    {
      "heading": "size of the queue becomes large, more workers are added to reduce the processing time.",
      "level": 3,
      "page": 25
    },
    {
      "heading": "However, if the queue is empty most of the time, the number of workers can be reduced.",
      "level": 3,
      "page": 25
    },
    {
      "heading": "Logging, metrics, automation",
      "level": 3,
      "page": 26
    },
    {
      "heading": "When working with a small website that runs on a few servers, logging, metrics, and",
      "level": 3,
      "page": 26
    },
    {
      "heading": "automation support are good practices but not a necessity. However, now that your site has",
      "level": 3,
      "page": 26
    },
    {
      "heading": "grown to serve a large business, investing in those tools is essential.",
      "level": 3,
      "page": 26
    },
    {
      "heading": "Logging: Monitoring error logs is important because it helps to identify errors and problems",
      "level": 3,
      "page": 26
    },
    {
      "heading": "in the system. You can monitor error logs at per server level or use tools to aggregate them to",
      "level": 3,
      "page": 26
    },
    {
      "heading": "a centralized service for easy search and viewing.",
      "level": 3,
      "page": 26
    },
    {
      "heading": "Metrics: Collecting different types of metrics help us to gain business insights and understand",
      "level": 3,
      "page": 26
    },
    {
      "heading": "the health status of the system. Some of the following metrics are useful:",
      "level": 3,
      "page": 26
    },
    {
      "heading": "• Host level metrics: CPU, Memory, disk I/O, etc.",
      "level": 3,
      "page": 26
    },
    {
      "heading": "• Aggregated level metrics: for example, the performance of the entire database tier, cache",
      "level": 3,
      "page": 26
    },
    {
      "heading": "tier, etc.",
      "level": 3,
      "page": 26
    },
    {
      "heading": "• Key business metrics: daily active users, retention, revenue, etc.",
      "level": 3,
      "page": 26
    },
    {
      "heading": "Automation: When a system gets big and complex, we need to build or leverage automation",
      "level": 3,
      "page": 26
    },
    {
      "heading": "tools to improve productivity. Continuous integration is a good practice, in which each code",
      "level": 3,
      "page": 26
    },
    {
      "heading": "check-in is verified through automation, allowing teams to detect problems early. Besides,",
      "level": 3,
      "page": 26
    },
    {
      "heading": "automating your build, test, deploy process, etc. could improve developer productivity",
      "level": 3,
      "page": 26
    },
    {
      "heading": "significantly.",
      "level": 3,
      "page": 26
    },
    {
      "heading": "Adding message queues and different tools",
      "level": 3,
      "page": 26
    },
    {
      "heading": "Figure 1-19 shows the updated design. Due to the space constraint, only one data center is",
      "level": 3,
      "page": 26
    },
    {
      "heading": "shown in the figure.",
      "level": 3,
      "page": 26
    },
    {
      "heading": "1. The design includes a message queue, which helps to make the system more loosely",
      "level": 3,
      "page": 26
    },
    {
      "heading": "coupled and failure resilient.",
      "level": 3,
      "page": 26
    },
    {
      "heading": "2. Logging, monitoring, metrics, and automation tools are included.",
      "level": 3,
      "page": 26
    },
    {
      "heading": "As the data grows every day, your database gets more overloaded. It is time to scale the data",
      "level": 3,
      "page": 27
    },
    {
      "heading": "tier.",
      "level": 3,
      "page": 27
    },
    {
      "heading": "Database scaling",
      "level": 3,
      "page": 28
    },
    {
      "heading": "There are two broad approaches for database scaling: vertical scaling and horizontal scaling.",
      "level": 3,
      "page": 28
    },
    {
      "heading": "Vertical scaling",
      "level": 3,
      "page": 28
    },
    {
      "heading": "Vertical scaling, also known as scaling up, is the scaling by adding more power (CPU, RAM,",
      "level": 3,
      "page": 28
    },
    {
      "heading": "DISK, etc.) to an existing machine. There are some powerful database servers. According to",
      "level": 3,
      "page": 28
    },
    {
      "heading": "Amazon Relational Database Service (RDS) [12], you can get a database server with 24 TB",
      "level": 3,
      "page": 28
    },
    {
      "heading": "of RAM. This kind of powerful database server could store and handle lots of data. For",
      "level": 3,
      "page": 28
    },
    {
      "heading": "example, stackoverflow.com in 2013 had over 10 million monthly unique visitors, but it only",
      "level": 3,
      "page": 28
    },
    {
      "heading": "had 1 master database [13]. However, vertical scaling comes with some serious drawbacks:",
      "level": 3,
      "page": 28
    },
    {
      "heading": "• You can add more CPU, RAM, etc. to your database server, but there are hardware",
      "level": 3,
      "page": 28
    },
    {
      "heading": "limits. If you have a large user base, a single server is not enough.",
      "level": 3,
      "page": 28
    },
    {
      "heading": "• Greater risk of single point of failures.",
      "level": 3,
      "page": 28
    },
    {
      "heading": "• The overall cost of vertical scaling is high. Powerful servers are much more expensive.",
      "level": 3,
      "page": 28
    },
    {
      "heading": "Horizontal scaling",
      "level": 3,
      "page": 28
    },
    {
      "heading": "Horizontal scaling, also known as sharding, is the practice of adding more servers. Figure 1-",
      "level": 3,
      "page": 28
    },
    {
      "heading": "20 compares vertical scaling with horizontal scaling.",
      "level": 3,
      "page": 28
    },
    {
      "heading": "Sharding separates large databases into smaller, more easily managed parts called shards.",
      "level": 3,
      "page": 28
    },
    {
      "heading": "Each shard shares the same schema, though the actual data on each shard is unique to the",
      "level": 3,
      "page": 28
    },
    {
      "heading": "shard.",
      "level": 3,
      "page": 28
    },
    {
      "heading": "Figure 1-21 shows an example of sharded databases. User data is allocated to a database",
      "level": 3,
      "page": 28
    },
    {
      "heading": "server based on user IDs. Anytime you access data, a hash function is used to find the",
      "level": 3,
      "page": 28
    },
    {
      "heading": "corresponding shard. In our example, user_id % 4 is used as the hash function. If the result",
      "level": 3,
      "page": 28
    },
    {
      "heading": "equals to 0, shard 0 is used to store and fetch data. If the result equals to 1, shard 1 is used.",
      "level": 3,
      "page": 29
    },
    {
      "heading": "The same logic applies to other shards.",
      "level": 3,
      "page": 29
    },
    {
      "heading": "Figure 1-22 shows the user table in sharded databases.",
      "level": 3,
      "page": 29
    },
    {
      "heading": "The most important factor to consider when implementing a sharding strategy is the choice of",
      "level": 3,
      "page": 29
    },
    {
      "heading": "the sharding key. Sharding key (known as a partition key) consists of one or more columns",
      "level": 3,
      "page": 29
    },
    {
      "heading": "that determine how data is distributed. As shown in Figure 1-22, “user_id” is the sharding",
      "level": 3,
      "page": 29
    },
    {
      "heading": "key. A sharding key allows you to retrieve and modify data efficiently by routing database",
      "level": 3,
      "page": 29
    },
    {
      "heading": "queries to the correct database. When choosing a sharding key, one of the most important",
      "level": 3,
      "page": 29
    },
    {
      "heading": "criteria is to choose a key that can evenly distributed data.",
      "level": 3,
      "page": 30
    },
    {
      "heading": "Sharding is a great technique to scale the database but it is far from a perfect solution. It",
      "level": 3,
      "page": 30
    },
    {
      "heading": "introduces complexities and new challenges to the system:",
      "level": 3,
      "page": 30
    },
    {
      "heading": "Resharding data: Resharding data is needed when 1) a single shard could no longer hold",
      "level": 3,
      "page": 30
    },
    {
      "heading": "more data due to rapid growth. 2) Certain shards might experience shard exhaustion faster",
      "level": 3,
      "page": 30
    },
    {
      "heading": "than others due to uneven data distribution. When shard exhaustion happens, it requires",
      "level": 3,
      "page": 30
    },
    {
      "heading": "updating the sharding function and moving data around. Consistent hashing, which will be",
      "level": 3,
      "page": 30
    },
    {
      "heading": "discussed in Chapter 5, is a commonly used technique to solve this problem.",
      "level": 3,
      "page": 30
    },
    {
      "heading": "Celebrity problem: This is also called a hotspot key problem. Excessive access to a specific",
      "level": 3,
      "page": 30
    },
    {
      "heading": "shard could cause server overload. Imagine data for Katy Perry, Justin Bieber, and Lady",
      "level": 3,
      "page": 30
    },
    {
      "heading": "Gaga all end up on the same shard. For social applications, that shard will be overwhelmed",
      "level": 3,
      "page": 30
    },
    {
      "heading": "with read operations. To solve this problem, we may need to allocate a shard for each",
      "level": 3,
      "page": 30
    },
    {
      "heading": "celebrity. Each shard might even require further partition.",
      "level": 3,
      "page": 30
    },
    {
      "heading": "Join and de-normalization: Once a database has been sharded across multiple servers, it is",
      "level": 3,
      "page": 30
    },
    {
      "heading": "hard to perform join operations across database shards. A common workaround is to de-",
      "level": 3,
      "page": 30
    },
    {
      "heading": "normalize the database so that queries can be performed in a single table.",
      "level": 3,
      "page": 30
    },
    {
      "heading": "In Figure 1-23, we shard databases to support rapidly increasing data traffic. At the same",
      "level": 3,
      "page": 30
    },
    {
      "heading": "time, some of the non-relational functionalities are moved to a NoSQL data store to reduce",
      "level": 3,
      "page": 30
    },
    {
      "heading": "the database load. Here is an article that covers many use cases of NoSQL [14].",
      "level": 3,
      "page": 30
    },
    {
      "heading": "Millions of users and beyond",
      "level": 3,
      "page": 32
    },
    {
      "heading": "Scaling a system is an iterative process. Iterating on what we have learned in this chapter",
      "level": 3,
      "page": 32
    },
    {
      "heading": "could get us far. More fine-tuning and new strategies are needed to scale beyond millions of",
      "level": 3,
      "page": 32
    },
    {
      "heading": "users. For example, you might need to optimize your system and decouple the system to even",
      "level": 3,
      "page": 32
    },
    {
      "heading": "smaller services. All the techniques learned in this chapter should provide a good foundation",
      "level": 3,
      "page": 32
    },
    {
      "heading": "to tackle new challenges. To conclude this chapter, we provide a summary of how we scale",
      "level": 3,
      "page": 32
    },
    {
      "heading": "our system to support millions of users:",
      "level": 3,
      "page": 32
    },
    {
      "heading": "• Keep web tier stateless",
      "level": 3,
      "page": 32
    },
    {
      "heading": "• Build redundancy at every tier",
      "level": 3,
      "page": 32
    },
    {
      "heading": "• Cache data as much as you can",
      "level": 3,
      "page": 32
    },
    {
      "heading": "• Support multiple data centers",
      "level": 3,
      "page": 32
    },
    {
      "heading": "• Host static assets in CDN",
      "level": 3,
      "page": 32
    },
    {
      "heading": "• Scale your data tier by sharding",
      "level": 3,
      "page": 32
    },
    {
      "heading": "• Split tiers into individual services",
      "level": 3,
      "page": 32
    },
    {
      "heading": "• Monitor your system and use automation tools",
      "level": 3,
      "page": 32
    },
    {
      "heading": "Congratulations on getting this far! Now give yourself a pat on the back. Good job!",
      "level": 3,
      "page": 32
    },
    {
      "heading": "Reference materials",
      "level": 2,
      "page": 33
    },
    {
      "heading": "[1] Hypertext Transfer Protocol: https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol",
      "level": 3,
      "page": 33
    },
    {
      "heading": "[2] Should you go Beyond Relational Databases?:",
      "level": 3,
      "page": 33
    },
    {
      "heading": "https://blog.teamtreehouse.com/should-you-go-beyond-relational-databases",
      "level": 3,
      "page": 33
    },
    {
      "heading": "[3] Replication:  https://en.wikipedia.org/wiki/Replication_(computing)",
      "level": 3,
      "page": 33
    },
    {
      "heading": "[4] Multi-master replication:",
      "level": 3,
      "page": 33
    },
    {
      "heading": "https://en.wikipedia.org/wiki/Multi-master_replication",
      "level": 3,
      "page": 33
    },
    {
      "heading": "[5] NDB Cluster Replication: Multi-Master and Circular Replication:",
      "level": 3,
      "page": 33
    },
    {
      "heading": "https://dev.mysql.com/doc/refman/5.7/en/mysql-cluster-replication-multi-master.html",
      "level": 3,
      "page": 33
    },
    {
      "heading": "[6] Caching Strategies and How to Choose the Right One:",
      "level": 3,
      "page": 33
    },
    {
      "heading": "https://codeahoy.com/2017/08/11/caching-strategies-and-how-to-choose-the-right-one/",
      "level": 3,
      "page": 33
    },
    {
      "heading": "[7] R. Nishtala, \"Facebook, Scaling Memcache at,\" 10th USENIX Symposium on Networked",
      "level": 3,
      "page": 33
    },
    {
      "heading": "Systems Design and Implementation (NSDI ’13).",
      "level": 3,
      "page": 33
    },
    {
      "heading": "[8] Single point of failure: https://en.wikipedia.org/wiki/Single_point_of_failure",
      "level": 3,
      "page": 33
    },
    {
      "heading": "[9] Amazon CloudFront Dynamic Content Delivery:",
      "level": 3,
      "page": 33
    },
    {
      "heading": "https://aws.amazon.com/cloudfront/dynamic-content/",
      "level": 3,
      "page": 33
    },
    {
      "heading": "[10] Configure Sticky Sessions for Your Classic Load Balancer:",
      "level": 3,
      "page": 33
    },
    {
      "heading": "https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-sticky-sessions.html",
      "level": 3,
      "page": 33
    },
    {
      "heading": "[11] Active-Active for Multi-Regional Resiliency:",
      "level": 3,
      "page": 33
    },
    {
      "heading": "https://netflixtechblog.com/active-active-for-multi-regional-resiliency-c47719f6685b",
      "level": 3,
      "page": 33
    },
    {
      "heading": "[12] Amazon EC2 High Memory Instances:",
      "level": 3,
      "page": 33
    },
    {
      "heading": "https://aws.amazon.com/ec2/instance-types/high-memory/",
      "level": 3,
      "page": 33
    },
    {
      "heading": "[13] What it takes to run Stack Overflow:",
      "level": 3,
      "page": 33
    },
    {
      "heading": "http://nickcraver.com/blog/2013/11/22/what-it-takes-to-run-stack-overflow",
      "level": 3,
      "page": 33
    },
    {
      "heading": "[14] What The Heck Are You Actually Using NoSQL For:",
      "level": 3,
      "page": 33
    },
    {
      "heading": "http://highscalability.com/blog/2010/12/6/what-the-heck-are-you-actually-using-nosql-",
      "level": 3,
      "page": 33
    },
    {
      "heading": "for.html",
      "level": 3,
      "page": 33
    },
    {
      "heading": "CHAPTER 2: BACK-OF-THE-ENVELOPE ESTIMATION",
      "level": 1,
      "page": 34
    },
    {
      "heading": "In a system design interview, sometimes you are asked to estimate system capacity or",
      "level": 3,
      "page": 34
    },
    {
      "heading": "performance requirements using a back-of-the-envelope estimation. According to Jeff Dean,",
      "level": 3,
      "page": 34
    },
    {
      "heading": "Google Senior Fellow, “back-of-the-envelope calculations are estimates you create using a",
      "level": 3,
      "page": 34
    },
    {
      "heading": "combination of thought experiments and common performance numbers to get a good feel for",
      "level": 3,
      "page": 34
    },
    {
      "heading": "which designs will meet your requirements” [1].",
      "level": 3,
      "page": 34
    },
    {
      "heading": "You need to have a good sense of scalability basics to effectively carry out back-of-the-",
      "level": 3,
      "page": 34
    },
    {
      "heading": "envelope estimation. The following concepts should be well understood: power of two [2],",
      "level": 3,
      "page": 34
    },
    {
      "heading": "latency numbers every programmer should know, and availability numbers.",
      "level": 3,
      "page": 34
    },
    {
      "heading": "Power of two",
      "level": 3,
      "page": 35
    },
    {
      "heading": "Although data volume can become enormous when dealing with distributed systems,",
      "level": 3,
      "page": 35
    },
    {
      "heading": "calculation all boils down to the basics. To obtain correct calculations, it is critical to know",
      "level": 3,
      "page": 35
    },
    {
      "heading": "1).",
      "level": 3,
      "page": 35
    },
    {
      "heading": "Latency numbers every programmer should know",
      "level": 3,
      "page": 36
    },
    {
      "heading": "Dr. Dean from Google reveals the length of typical computer operations in 2010 [1]. Some",
      "level": 3,
      "page": 36
    },
    {
      "heading": "numbers are outdated as computers become faster and more powerful. However, those",
      "level": 3,
      "page": 36
    },
    {
      "heading": "numbers should still be able to give us an idea of the fastness and slowness of different",
      "level": 3,
      "page": 36
    },
    {
      "heading": "computer operations.",
      "level": 3,
      "page": 36
    },
    {
      "heading": "Notes",
      "level": 3,
      "page": 36
    },
    {
      "heading": "-----------",
      "level": 3,
      "page": 36
    },
    {
      "heading": "ns = nanosecond, µs = microsecond, ms = millisecond",
      "level": 3,
      "page": 36
    },
    {
      "heading": "1 ns = 10^-9 seconds",
      "level": 3,
      "page": 36
    },
    {
      "heading": "1 µs= 10^-6 seconds = 1,000 ns",
      "level": 3,
      "page": 36
    },
    {
      "heading": "1 ms = 10^-3 seconds = 1,000 µs = 1,000,000 ns",
      "level": 3,
      "page": 36
    },
    {
      "heading": "A Google software engineer built a tool to visualize Dr. Dean’s numbers. The tool also takes",
      "level": 3,
      "page": 37
    },
    {
      "heading": "the time factor into consideration. Figures 2-1 shows the visualized latency numbers as of",
      "level": 3,
      "page": 37
    },
    {
      "heading": "2020 (source of figures: reference material [3]).",
      "level": 3,
      "page": 37
    },
    {
      "heading": "By analyzing the numbers in Figure 2-1, we get the following conclusions:",
      "level": 3,
      "page": 37
    },
    {
      "heading": "• Memory is fast but the disk is slow.",
      "level": 3,
      "page": 37
    },
    {
      "heading": "• Avoid disk seeks if possible.",
      "level": 3,
      "page": 37
    },
    {
      "heading": "• Simple compression algorithms are fast.",
      "level": 3,
      "page": 37
    },
    {
      "heading": "• Compress data before sending it over the internet if possible.",
      "level": 3,
      "page": 37
    },
    {
      "heading": "• Data centers are usually in different regions, and it takes time to send data between them.",
      "level": 3,
      "page": 37
    },
    {
      "heading": "Availability numbers",
      "level": 3,
      "page": 38
    },
    {
      "heading": "High availability is the ability of a system to be continuously operational for a desirably long",
      "level": 3,
      "page": 38
    },
    {
      "heading": "period of time. High availability is measured as a percentage, with 100% means a service that",
      "level": 3,
      "page": 38
    },
    {
      "heading": "has 0 downtime. Most services fall between 99% and 100%.",
      "level": 3,
      "page": 38
    },
    {
      "heading": "A service level agreement (SLA) is a commonly used term for service providers. This is an",
      "level": 3,
      "page": 38
    },
    {
      "heading": "agreement between you (the service provider) and your customer, and this agreement",
      "level": 3,
      "page": 38
    },
    {
      "heading": "formally defines the level of uptime your service will deliver. Cloud providers Amazon [4],",
      "level": 3,
      "page": 38
    },
    {
      "heading": "Google [5] and Microsoft [6] set their SLAs at 99.9% or above. Uptime is traditionally",
      "level": 3,
      "page": 38
    },
    {
      "heading": "measured in nines. The more the nines, the better. As shown in Table 2-3, the number of",
      "level": 3,
      "page": 38
    },
    {
      "heading": "nines correlate to the expected system downtime.",
      "level": 3,
      "page": 38
    },
    {
      "heading": "Example: Estimate Twitter QPS and storage requirements",
      "level": 3,
      "page": 39
    },
    {
      "heading": "Please note the following numbers are for this exercise only as they are not real numbers",
      "level": 3,
      "page": 39
    },
    {
      "heading": "from Twitter.",
      "level": 3,
      "page": 39
    },
    {
      "heading": "Assumptions:",
      "level": 3,
      "page": 39
    },
    {
      "heading": "•  300 million monthly active users.",
      "level": 3,
      "page": 39
    },
    {
      "heading": "•  50% of users use Twitter daily.",
      "level": 3,
      "page": 39
    },
    {
      "heading": "•  Users post 2 tweets per day on average.",
      "level": 3,
      "page": 39
    },
    {
      "heading": "•  10% of tweets contain media.",
      "level": 3,
      "page": 39
    },
    {
      "heading": "•  Data is stored for 5 years.",
      "level": 3,
      "page": 39
    },
    {
      "heading": "Estimations:",
      "level": 3,
      "page": 39
    },
    {
      "heading": "Query per second (QPS) estimate:",
      "level": 3,
      "page": 39
    },
    {
      "heading": "•  Daily active users (DAU) = 300 million * 50% = 150 million",
      "level": 3,
      "page": 39
    },
    {
      "heading": "•  Tweets QPS = 150 million * 2 tweets / 24 hour / 3600 seconds = ~3500",
      "level": 3,
      "page": 39
    },
    {
      "heading": "•  Peek QPS = 2 * QPS = ~7000",
      "level": 3,
      "page": 39
    },
    {
      "heading": "We will only estimate media storage here.",
      "level": 3,
      "page": 39
    },
    {
      "heading": "•  Average tweet size:",
      "level": 3,
      "page": 39
    },
    {
      "heading": "•  tweet_id   64 bytes",
      "level": 3,
      "page": 39
    },
    {
      "heading": "•  text           140 bytes",
      "level": 3,
      "page": 39
    },
    {
      "heading": "•  media       1 MB",
      "level": 3,
      "page": 39
    },
    {
      "heading": "•  Media storage: 150 million * 2 * 10% * 1 MB = 30 TB per day",
      "level": 3,
      "page": 39
    },
    {
      "heading": "•  5-year media storage: 30 TB * 365 * 5 = ~55 PB",
      "level": 3,
      "page": 39
    },
    {
      "heading": "Tips",
      "level": 3,
      "page": 40
    },
    {
      "heading": "Back-of-the-envelope estimation is all about the process. Solving the problem is more",
      "level": 3,
      "page": 40
    },
    {
      "heading": "important than obtaining results. Interviewers may test your problem-solving skills. Here are",
      "level": 3,
      "page": 40
    },
    {
      "heading": "a few tips to follow:",
      "level": 3,
      "page": 40
    },
    {
      "heading": "• Rounding and Approximation. It is difficult to perform complicated math operations",
      "level": 3,
      "page": 40
    },
    {
      "heading": "during the interview. For example, what is the result of “99987 / 9.1”? There is no need to",
      "level": 3,
      "page": 40
    },
    {
      "heading": "spend valuable time to solve complicated math problems. Precision is not expected. Use",
      "level": 3,
      "page": 40
    },
    {
      "heading": "round numbers and approximation to your advantage. The division question can be",
      "level": 3,
      "page": 40
    },
    {
      "heading": "simplified as follows: “100,000 / 10”.",
      "level": 3,
      "page": 40
    },
    {
      "heading": "• Write down your assumptions. It is a good idea to write down your assumptions to be",
      "level": 3,
      "page": 40
    },
    {
      "heading": "referenced later.",
      "level": 3,
      "page": 40
    },
    {
      "heading": "• Label your units. When you write down “5”, does it mean 5 KB or 5 MB? You might",
      "level": 3,
      "page": 40
    },
    {
      "heading": "confuse yourself with this. Write down the units because “5 MB” helps to remove",
      "level": 3,
      "page": 40
    },
    {
      "heading": "ambiguity.",
      "level": 3,
      "page": 40
    },
    {
      "heading": "• Commonly asked back-of-the-envelope estimations: QPS, peak QPS, storage, cache,",
      "level": 3,
      "page": 40
    },
    {
      "heading": "number of servers, etc. You can practice these calculations when preparing for an",
      "level": 3,
      "page": 40
    },
    {
      "heading": "interview. Practice makes perfect.",
      "level": 3,
      "page": 40
    },
    {
      "heading": "Congratulations on getting this far! Now give yourself a pat on the back. Good job!",
      "level": 3,
      "page": 40
    },
    {
      "heading": "Reference materials",
      "level": 2,
      "page": 41
    },
    {
      "heading": "[1] J. Dean.Google Pro Tip: Use Back-Of-The-Envelope-Calculations To Choose The Best",
      "level": 3,
      "page": 41
    },
    {
      "heading": "Design:",
      "level": 3,
      "page": 41
    },
    {
      "heading": "http://highscalability.com/blog/2011/1/26/google-pro-tip-use-back-of-the-envelope-",
      "level": 3,
      "page": 41
    },
    {
      "heading": "calculations-to-choo.html",
      "level": 3,
      "page": 41
    },
    {
      "heading": "[2] System design primer: https://github.com/donnemartin/system-design-primer",
      "level": 3,
      "page": 41
    },
    {
      "heading": "[3] Latency Numbers Every Programmer Should Know:",
      "level": 3,
      "page": 41
    },
    {
      "heading": "https://colin-scott.github.io/personal_website/research/interactive_latency.html",
      "level": 3,
      "page": 41
    },
    {
      "heading": "[4] Amazon Compute Service Level Agreement:",
      "level": 3,
      "page": 41
    },
    {
      "heading": "https://aws.amazon.com/compute/sla/",
      "level": 3,
      "page": 41
    },
    {
      "heading": "[5] Compute Engine Service Level Agreement (SLA):",
      "level": 3,
      "page": 41
    },
    {
      "heading": "https://cloud.google.com/compute/sla",
      "level": 3,
      "page": 41
    },
    {
      "heading": "[6] SLA summary for Azure services: https://azure.microsoft.com/en-",
      "level": 3,
      "page": 41
    },
    {
      "heading": "us/support/legal/sla/summary/",
      "level": 3,
      "page": 41
    },
    {
      "heading": "CHAPTER 3: A FRAMEWORK FOR SYSTEM DESIGN",
      "level": 1,
      "page": 42
    },
    {
      "heading": "INTERVIEWS",
      "level": 1,
      "page": 42
    },
    {
      "heading": "You have just landed a coveted on-site interview at your dream company. The hiring",
      "level": 3,
      "page": 42
    },
    {
      "heading": "coordinator sends you a schedule for that day. Scanning down the list, you feel pretty good",
      "level": 3,
      "page": 42
    },
    {
      "heading": "about it until your eyes land on this interview session - System Design Interview.",
      "level": 3,
      "page": 42
    },
    {
      "heading": "System design interviews are often intimidating. It could be as vague as “designing a well-",
      "level": 3,
      "page": 42
    },
    {
      "heading": "known product X?”. The questions are ambiguous and seem unreasonably broad. Your",
      "level": 3,
      "page": 42
    },
    {
      "heading": "weariness is understandable. After all, how could anyone design a popular product in an hour",
      "level": 3,
      "page": 42
    },
    {
      "heading": "that has taken hundreds if not thousands of engineers to build?",
      "level": 3,
      "page": 42
    },
    {
      "heading": "The good news is that no one expects you to. Real-world system design is extremely",
      "level": 3,
      "page": 42
    },
    {
      "heading": "complicated. For example, Google search is deceptively simple; however, the amount of",
      "level": 3,
      "page": 42
    },
    {
      "heading": "technology that underpins that simplicity is truly astonishing. If no one expects you to design",
      "level": 3,
      "page": 42
    },
    {
      "heading": "a real-world system in an hour, what is the benefit of a system design interview?",
      "level": 3,
      "page": 42
    },
    {
      "heading": "collaborate on an ambiguous problem and come up with a solution that meets their goals. The",
      "level": 3,
      "page": 42
    },
    {
      "heading": "problem is open-ended, and there is no perfect answer. The final design is less important",
      "level": 3,
      "page": 42
    },
    {
      "heading": "compared to the work you put in the design process. This allows you to demonstrate your",
      "level": 3,
      "page": 42
    },
    {
      "heading": "design skill, defend your design choices, and respond to feedback in a constructive manner.",
      "level": 3,
      "page": 42
    },
    {
      "heading": "Let us flip the table and consider what goes through the interviewer’s head as she walks into",
      "level": 3,
      "page": 42
    },
    {
      "heading": "the conference room to meet you. The primary goal of the interviewer is to accurately assess",
      "level": 3,
      "page": 42
    },
    {
      "heading": "your abilities. The last thing she wants is to give an inconclusive evaluation because the",
      "level": 3,
      "page": 42
    },
    {
      "heading": "session has gone poorly and there are not enough signals. What is an interviewer looking for",
      "level": 3,
      "page": 42
    },
    {
      "heading": "in a system design interview?",
      "level": 3,
      "page": 42
    },
    {
      "heading": "Many think that system design interview is all about a person's technical design skills. It is",
      "level": 3,
      "page": 42
    },
    {
      "heading": "much more than that. An effective system design interview gives strong signals about a",
      "level": 3,
      "page": 42
    },
    {
      "heading": "person's ability to collaborate, to work under pressure, and to resolve ambiguity",
      "level": 3,
      "page": 42
    },
    {
      "heading": "constructively. The ability to ask good questions is also an essential skill, and many",
      "level": 3,
      "page": 42
    },
    {
      "heading": "interviewers specifically look for this skill.",
      "level": 3,
      "page": 42
    },
    {
      "heading": "A good interviewer also looks for red flags. Over-engineering is a real disease of many",
      "level": 3,
      "page": 42
    },
    {
      "heading": "engineers as they delight in design purity and ignore tradeoffs. They are often unaware of the",
      "level": 3,
      "page": 42
    },
    {
      "heading": "compounding costs of over-engineered systems, and many companies pay a high price for",
      "level": 3,
      "page": 42
    },
    {
      "heading": "that ignorance. You certainly do not want to demonstrate this tendency in a system design",
      "level": 3,
      "page": 42
    },
    {
      "heading": "interview. Other red flags include narrow mindedness, stubbornness, etc.",
      "level": 3,
      "page": 42
    },
    {
      "heading": "In this chapter, we will go over some useful tips and introduce a simple and effective",
      "level": 3,
      "page": 42
    },
    {
      "heading": "framework to solve system design interview problems.",
      "level": 3,
      "page": 42
    },
    {
      "heading": "A 4-step process for effective system design interview",
      "level": 3,
      "page": 43
    },
    {
      "heading": "Every system design interview is different. A great system design interview is open-ended",
      "level": 3,
      "page": 43
    },
    {
      "heading": "and there is no one-size-fits-all solution. However, there are steps and common ground to",
      "level": 3,
      "page": 43
    },
    {
      "heading": "cover in every system design interview.",
      "level": 3,
      "page": 43
    },
    {
      "heading": "Step 1 - Understand the problem and establish design scope",
      "level": 3,
      "page": 43
    },
    {
      "heading": "\"Why did the tiger roar?\"",
      "level": 3,
      "page": 43
    },
    {
      "heading": "A hand shot up in the back of the class.",
      "level": 3,
      "page": 43
    },
    {
      "heading": "\"Yes, Jimmy?\", the teacher responded.",
      "level": 3,
      "page": 43
    },
    {
      "heading": "\"Because he was HUNGRY\".",
      "level": 3,
      "page": 43
    },
    {
      "heading": "\"Very good Jimmy.\"",
      "level": 3,
      "page": 43
    },
    {
      "heading": "Throughout his childhood, Jimmy has always been the first to answer questions in the class.",
      "level": 3,
      "page": 43
    },
    {
      "heading": "Whenever the teacher asks a question, there is always a kid in the classroom who loves to",
      "level": 3,
      "page": 43
    },
    {
      "heading": "take a crack at the question, no matter if he knows the answer or not. That is Jimmy.",
      "level": 3,
      "page": 43
    },
    {
      "heading": "Jimmy is an ace student. He takes pride in knowing all the answers fast. In exams, he is",
      "level": 3,
      "page": 43
    },
    {
      "heading": "usually the first person to finish the questions. He is a teacher's top choice for any academic",
      "level": 3,
      "page": 43
    },
    {
      "heading": "competition.",
      "level": 3,
      "page": 43
    },
    {
      "heading": "DON'T be like Jimmy.",
      "level": 3,
      "page": 43
    },
    {
      "heading": "In a system design interview, giving out an answer quickly without thinking gives you no",
      "level": 3,
      "page": 43
    },
    {
      "heading": "bonus points. Answering without a thorough understanding of the requirements is a huge red",
      "level": 3,
      "page": 43
    },
    {
      "heading": "flag as the interview is not a trivia contest. There is no right answer.",
      "level": 3,
      "page": 43
    },
    {
      "heading": "So, do not jump right in to give a solution. Slow down. Think deeply and ask questions to",
      "level": 3,
      "page": 43
    },
    {
      "heading": "clarify requirements and assumptions. This is extremely important.",
      "level": 3,
      "page": 43
    },
    {
      "heading": "As an engineer, we like to solve hard problems and jump into the final design; however, this",
      "level": 3,
      "page": 43
    },
    {
      "heading": "approach is likely to lead you to design the wrong system. One of the most important skills as",
      "level": 3,
      "page": 43
    },
    {
      "heading": "an engineer is to ask the right questions, make the proper assumptions, and gather all the",
      "level": 3,
      "page": 43
    },
    {
      "heading": "information needed to build a system. So, do not be afraid to ask questions.",
      "level": 3,
      "page": 43
    },
    {
      "heading": "When you ask a question, the interviewer either answers your question directly or asks you to",
      "level": 3,
      "page": 43
    },
    {
      "heading": "make your assumptions. If the latter happens, write down your assumptions on the",
      "level": 3,
      "page": 43
    },
    {
      "heading": "whiteboard or paper. You might need them later.",
      "level": 3,
      "page": 43
    },
    {
      "heading": "What kind of questions to ask? Ask questions to understand the exact requirements. Here is a",
      "level": 3,
      "page": 43
    },
    {
      "heading": "list of questions to help you get started:",
      "level": 3,
      "page": 43
    },
    {
      "heading": "• What specific features are we going to build?",
      "level": 3,
      "page": 43
    },
    {
      "heading": "• How many users does the product have?",
      "level": 3,
      "page": 43
    },
    {
      "heading": "• How fast does the company anticipate to scale up? What are the anticipated scales in 3",
      "level": 3,
      "page": 43
    },
    {
      "heading": "months, 6 months, and a year?",
      "level": 3,
      "page": 43
    },
    {
      "heading": "• What is the company’s technology stack? What existing services you might leverage to",
      "level": 3,
      "page": 43
    },
    {
      "heading": "simplify the design?",
      "level": 3,
      "page": 43
    },
    {
      "heading": "Example",
      "level": 3,
      "page": 43
    },
    {
      "heading": "If you are asked to design a news feed system, you want to ask questions that help you clarify",
      "level": 3,
      "page": 43
    },
    {
      "heading": "the requirements. The conversation between you and the interviewer might look like this:",
      "level": 3,
      "page": 43
    },
    {
      "heading": "Candidate: Is this a mobile app? Or a web app? Or both?",
      "level": 3,
      "page": 43
    },
    {
      "heading": "Interviewer: Both.",
      "level": 3,
      "page": 44
    },
    {
      "heading": "Candidate: What are the most important features for the product?",
      "level": 3,
      "page": 44
    },
    {
      "heading": "Interviewer: Ability to make a post and see friends’ news feed.",
      "level": 3,
      "page": 44
    },
    {
      "heading": "Candidate: Is the news feed sorted in reverse chronological order or a particular order? The",
      "level": 3,
      "page": 44
    },
    {
      "heading": "particular order means each post is given a different weight. For instance, posts from your",
      "level": 3,
      "page": 44
    },
    {
      "heading": "close friends are more important than posts from a group.",
      "level": 3,
      "page": 44
    },
    {
      "heading": "Interviewer: To keep things simple, let us assume the feed is sorted by reverse chronological",
      "level": 3,
      "page": 44
    },
    {
      "heading": "order.",
      "level": 3,
      "page": 44
    },
    {
      "heading": "Candidate: How many friends can a user have?",
      "level": 3,
      "page": 44
    },
    {
      "heading": "Interviewer: 5000",
      "level": 3,
      "page": 44
    },
    {
      "heading": "Candidate: What is the traffic volume?",
      "level": 3,
      "page": 44
    },
    {
      "heading": "Interviewer: 10 million daily active users (DAU)",
      "level": 3,
      "page": 44
    },
    {
      "heading": "Candidate: Can feed contain images, videos, or just text?",
      "level": 3,
      "page": 44
    },
    {
      "heading": "Interviewer: It can contain media files, including both images and videos.",
      "level": 3,
      "page": 44
    },
    {
      "heading": "Above are some sample questions that you can ask your interviewer. It is important to",
      "level": 3,
      "page": 44
    },
    {
      "heading": "understand the requirements and clarify ambiguities",
      "level": 3,
      "page": 44
    },
    {
      "heading": "Step 2 - Propose high-level design and get buy-in",
      "level": 3,
      "page": 44
    },
    {
      "heading": "In this step, we aim to develop a high-level design and reach an agreement with the",
      "level": 3,
      "page": 44
    },
    {
      "heading": "interviewer on the design. It is a great idea to collaborate with the interviewer during the",
      "level": 3,
      "page": 44
    },
    {
      "heading": "process.",
      "level": 3,
      "page": 44
    },
    {
      "heading": "• Come up with an initial blueprint for the design. Ask for feedback. Treat your",
      "level": 3,
      "page": 44
    },
    {
      "heading": "interviewer as a teammate and work together. Many good interviewers love to talk and get",
      "level": 3,
      "page": 44
    },
    {
      "heading": "involved.",
      "level": 3,
      "page": 44
    },
    {
      "heading": "• Draw box diagrams with key components on the whiteboard or paper. This might include",
      "level": 3,
      "page": 44
    },
    {
      "heading": "• Do back-of-the-envelope calculations to evaluate if your blueprint fits the scale",
      "level": 3,
      "page": 44
    },
    {
      "heading": "constraints. Think out loud. Communicate with your interviewer if back-of-the-envelope is",
      "level": 3,
      "page": 44
    },
    {
      "heading": "necessary before diving into it.",
      "level": 3,
      "page": 44
    },
    {
      "heading": "If possible, go through a few concrete use cases. This will help you frame the high-level",
      "level": 3,
      "page": 44
    },
    {
      "heading": "design. It is also likely that the use cases would help you discover edge cases you have not",
      "level": 3,
      "page": 44
    },
    {
      "heading": "yet considered.",
      "level": 3,
      "page": 44
    },
    {
      "heading": "Should we include API endpoints and database schema here? This depends on the problem.",
      "level": 3,
      "page": 44
    },
    {
      "heading": "For large design problems like “Design Google search engine”, this is a bit of too low level.",
      "level": 3,
      "page": 44
    },
    {
      "heading": "For a problem like designing the backend for a multi-player poker game, this is a fair game.",
      "level": 3,
      "page": 44
    },
    {
      "heading": "Communicate with your interviewer.",
      "level": 3,
      "page": 44
    },
    {
      "heading": "Example",
      "level": 3,
      "page": 44
    },
    {
      "heading": "Let us use “Design a news feed system” to demonstrate how to approach the high-level",
      "level": 3,
      "page": 44
    },
    {
      "heading": "design. Here you are not required to understand how the system actually works. All the",
      "level": 3,
      "page": 44
    },
    {
      "heading": "details will be explained in Chapter 11.",
      "level": 3,
      "page": 44
    },
    {
      "heading": "At the high level, the design is divided into two flows: feed publishing and news feed",
      "level": 3,
      "page": 44
    },
    {
      "heading": "building.",
      "level": 3,
      "page": 44
    },
    {
      "heading": "• Feed publishing: when a user publishes a post, corresponding data is written into",
      "level": 3,
      "page": 44
    },
    {
      "heading": "cache/database, and the post will be populated into friends’ news feed.",
      "level": 3,
      "page": 44
    },
    {
      "heading": "• Newsfeed building: the news feed is built by aggregating friends’ posts in a reverse",
      "level": 3,
      "page": 45
    },
    {
      "heading": "chronological order.",
      "level": 3,
      "page": 45
    },
    {
      "heading": "building flows, respectively.",
      "level": 3,
      "page": 45
    },
    {
      "heading": "Step 3 - Design deep dive",
      "level": 3,
      "page": 46
    },
    {
      "heading": "At this step, you and your interviewer should have already achieved the following objectives:",
      "level": 3,
      "page": 46
    },
    {
      "heading": "• Agreed on the overall goals and feature scope",
      "level": 3,
      "page": 46
    },
    {
      "heading": "• Sketched out a high-level blueprint for the overall design",
      "level": 3,
      "page": 46
    },
    {
      "heading": "• Obtained feedback from your interviewer on the high-level design",
      "level": 3,
      "page": 46
    },
    {
      "heading": "• Had some initial ideas about areas to focus on in deep dive based on her feedback",
      "level": 3,
      "page": 46
    },
    {
      "heading": "You shall work with the interviewer to identify and prioritize components in the architecture.",
      "level": 3,
      "page": 46
    },
    {
      "heading": "It is worth stressing that every interview is different. Sometimes, the interviewer may give off",
      "level": 3,
      "page": 46
    },
    {
      "heading": "hints that she likes focusing on high-level design. Sometimes, for a senior candidate",
      "level": 3,
      "page": 46
    },
    {
      "heading": "interview, the discussion could be on the system performance characteristics, likely focusing",
      "level": 3,
      "page": 46
    },
    {
      "heading": "on the bottlenecks and resource estimations. In most cases, the interviewer may want you to",
      "level": 3,
      "page": 46
    },
    {
      "heading": "dig into details of some system components. For URL shortener, it is interesting to dive into",
      "level": 3,
      "page": 46
    },
    {
      "heading": "the hash function design that converts a long URL to a short one. For a chat system, how to",
      "level": 3,
      "page": 46
    },
    {
      "heading": "reduce latency and how to support online/offline status are two interesting topics.",
      "level": 3,
      "page": 46
    },
    {
      "heading": "Time management is essential as it is easy to get carried away with minute details that do not",
      "level": 3,
      "page": 46
    },
    {
      "heading": "demonstrate your abilities. You must be armed with signals to show your interviewer. Try not",
      "level": 3,
      "page": 46
    },
    {
      "heading": "to get into unnecessary details. For example, talking about the EdgeRank algorithm of",
      "level": 3,
      "page": 47
    },
    {
      "heading": "Facebook feed ranking in detail is not ideal during a system design interview as this takes",
      "level": 3,
      "page": 47
    },
    {
      "heading": "much precious time and does not prove your ability in designing a scalable system.",
      "level": 3,
      "page": 47
    },
    {
      "heading": "Example",
      "level": 3,
      "page": 47
    },
    {
      "heading": "At this point, we have discussed the high-level design for a news feed system, and the",
      "level": 3,
      "page": 47
    },
    {
      "heading": "interviewer is happy with your proposal. Next, we will investigate two of the most important",
      "level": 3,
      "page": 47
    },
    {
      "heading": "use cases:",
      "level": 3,
      "page": 47
    },
    {
      "heading": "1. Feed publishing",
      "level": 3,
      "page": 47
    },
    {
      "heading": "2. News feed retrieval",
      "level": 3,
      "page": 47
    },
    {
      "heading": "Figure 3-3 and Figure 3-4 show the detailed design for the two use cases, which will be",
      "level": 3,
      "page": 47
    },
    {
      "heading": "explained in detail in Chapter 11.",
      "level": 3,
      "page": 47
    },
    {
      "heading": "Step 4 - Wrap up",
      "level": 3,
      "page": 49
    },
    {
      "heading": "In this final step, the interviewer might ask you a few follow-up questions or give you the",
      "level": 3,
      "page": 49
    },
    {
      "heading": "freedom to discuss other additional points. Here are a few directions to follow:",
      "level": 3,
      "page": 49
    },
    {
      "heading": "• The interviewer might want you to identify the system bottlenecks and discuss potential",
      "level": 3,
      "page": 49
    },
    {
      "heading": "improvements. Never say your design is perfect and nothing can be improved. There is",
      "level": 3,
      "page": 49
    },
    {
      "heading": "always something to improve upon. This is a great opportunity to show your critical",
      "level": 3,
      "page": 49
    },
    {
      "heading": "thinking and leave a good final impression.",
      "level": 3,
      "page": 49
    },
    {
      "heading": "• It could be useful to give the interviewer a recap of your design. This is particularly",
      "level": 3,
      "page": 49
    },
    {
      "heading": "important if you suggested a few solutions. Refreshing your interviewer’s memory can be",
      "level": 3,
      "page": 49
    },
    {
      "heading": "helpful after a long session.",
      "level": 3,
      "page": 49
    },
    {
      "heading": "• Error cases (server failure, network loss, etc.) are interesting to talk about.",
      "level": 3,
      "page": 49
    },
    {
      "heading": "• Operation issues are worth mentioning. How do you monitor metrics and error logs?",
      "level": 3,
      "page": 49
    },
    {
      "heading": "How to roll out the system?",
      "level": 3,
      "page": 49
    },
    {
      "heading": "• How to handle the next scale curve is also an interesting topic. For example, if your",
      "level": 3,
      "page": 49
    },
    {
      "heading": "current design supports 1 million users, what changes do you need to make to support 10",
      "level": 3,
      "page": 49
    },
    {
      "heading": "million users?",
      "level": 3,
      "page": 49
    },
    {
      "heading": "• Propose other refinements you need if you had more time.",
      "level": 3,
      "page": 49
    },
    {
      "heading": "To wrap up, we summarize a list of the Dos and Don’ts.",
      "level": 3,
      "page": 50
    },
    {
      "heading": "Dos",
      "level": 3,
      "page": 50
    },
    {
      "heading": "• Always ask for clarification. Do not assume your assumption is correct.",
      "level": 3,
      "page": 50
    },
    {
      "heading": "• Understand the requirements of the problem.",
      "level": 3,
      "page": 50
    },
    {
      "heading": "• There is neither the right answer nor the best answer. A solution designed to solve the",
      "level": 3,
      "page": 50
    },
    {
      "heading": "problems of a young startup is different from that of an established company with millions",
      "level": 3,
      "page": 50
    },
    {
      "heading": "of users. Make sure you understand the requirements.",
      "level": 3,
      "page": 50
    },
    {
      "heading": "• Let the interviewer know what you are thinking. Communicate with your interview.",
      "level": 3,
      "page": 50
    },
    {
      "heading": "• Suggest multiple approaches if possible.",
      "level": 3,
      "page": 50
    },
    {
      "heading": "• Once you agree with your interviewer on the blueprint, go into details on each",
      "level": 3,
      "page": 50
    },
    {
      "heading": "component. Design the most critical components first.",
      "level": 3,
      "page": 50
    },
    {
      "heading": "• Bounce ideas off the interviewer. A good interviewer works with you as a teammate.",
      "level": 3,
      "page": 50
    },
    {
      "heading": "• Never give up.",
      "level": 3,
      "page": 50
    },
    {
      "heading": "Don’ts",
      "level": 3,
      "page": 50
    },
    {
      "heading": "• Don't be unprepared for typical interview questions.",
      "level": 3,
      "page": 50
    },
    {
      "heading": "• Don’t jump into a solution without clarifying the requirements and assumptions.",
      "level": 3,
      "page": 50
    },
    {
      "heading": "• Don’t go into too much detail on a single component in the beginning. Give the high-",
      "level": 3,
      "page": 50
    },
    {
      "heading": "level design first then drills down.",
      "level": 3,
      "page": 50
    },
    {
      "heading": "• If you get stuck, don't hesitate to ask for hints.",
      "level": 3,
      "page": 50
    },
    {
      "heading": "• Again, communicate. Don't think in silence.",
      "level": 3,
      "page": 50
    },
    {
      "heading": "• Don’t think your interview is done once you give the design. You are not done until your",
      "level": 3,
      "page": 50
    },
    {
      "heading": "interviewer says you are done. Ask for feedback early and often.",
      "level": 3,
      "page": 50
    },
    {
      "heading": "Time allocation on each step",
      "level": 3,
      "page": 50
    },
    {
      "heading": "System design interview questions are usually very broad, and 45 minutes or an hour is not",
      "level": 3,
      "page": 50
    },
    {
      "heading": "enough to cover the entire design. Time management is essential. How much time should you",
      "level": 3,
      "page": 50
    },
    {
      "heading": "spend on each step? The following is a very rough guide on distributing your time in a 45-",
      "level": 3,
      "page": 50
    },
    {
      "heading": "minute interview session. Please remember this is a rough estimate, and the actual time",
      "level": 3,
      "page": 50
    },
    {
      "heading": "distribution depends on the scope of the problem and the requirements from the interviewer.",
      "level": 3,
      "page": 50
    },
    {
      "heading": "Step 1 Understand the problem and establish design scope: 3 - 10 minutes",
      "level": 3,
      "page": 50
    },
    {
      "heading": "Step 2 Propose high-level design and get buy-in: 10 - 15 minutes",
      "level": 3,
      "page": 50
    },
    {
      "heading": "Step 3 Design deep dive: 10 - 25 minutes",
      "level": 3,
      "page": 50
    },
    {
      "heading": "Step 4 Wrap: 3 - 5 minutes",
      "level": 3,
      "page": 50
    },
    {
      "heading": "CHAPTER 4: DESIGN A RATE LIMITER",
      "level": 1,
      "page": 51
    },
    {
      "heading": "In a network system, a rate limiter is used to control the rate of traffic sent by a client or a",
      "level": 3,
      "page": 51
    },
    {
      "heading": "service. In the HTTP world, a rate limiter limits the number of client requests allowed to be",
      "level": 3,
      "page": 51
    },
    {
      "heading": "sent over a specified period. If the API request count exceeds the threshold defined by the",
      "level": 3,
      "page": 51
    },
    {
      "heading": "rate limiter, all the excess calls are blocked. Here are a few examples:",
      "level": 3,
      "page": 51
    },
    {
      "heading": "• A user can write no more than 2 posts per second.",
      "level": 3,
      "page": 51
    },
    {
      "heading": "• You can create a maximum of 10 accounts per day from the same IP address.",
      "level": 3,
      "page": 51
    },
    {
      "heading": "• You can claim rewards no more than 5 times per week from the same device.",
      "level": 3,
      "page": 51
    },
    {
      "heading": "In this chapter, you are asked to design a rate limiter. Before starting the design, we first look",
      "level": 3,
      "page": 51
    },
    {
      "heading": "at the benefits of using an API rate limiter:",
      "level": 3,
      "page": 51
    },
    {
      "heading": "• Prevent resource starvation caused by Denial of Service (DoS) attack [1]. Almost all",
      "level": 3,
      "page": 51
    },
    {
      "heading": "APIs published by large tech companies enforce some form of rate limiting. For example,",
      "level": 3,
      "page": 51
    },
    {
      "heading": "Twitter limits the number of tweets to 300 per 3 hours [2]. Google docs APIs have the",
      "level": 3,
      "page": 51
    },
    {
      "heading": "prevents DoS attacks, either intentional or unintentional, by blocking the excess calls.",
      "level": 3,
      "page": 51
    },
    {
      "heading": "• Reduce cost. Limiting excess requests means fewer servers and allocating more",
      "level": 3,
      "page": 51
    },
    {
      "heading": "resources to high priority APIs. Rate limiting is extremely important for companies that",
      "level": 3,
      "page": 51
    },
    {
      "heading": "use paid third party APIs. For example, you are charged on a per-call basis for the",
      "level": 3,
      "page": 51
    },
    {
      "heading": "following external APIs: check credit, make a payment, retrieve health records, etc.",
      "level": 3,
      "page": 51
    },
    {
      "heading": "Limiting the number of calls is essential to reduce costs.",
      "level": 3,
      "page": 51
    },
    {
      "heading": "• Prevent servers from being overloaded. To reduce server load, a rate limiter is used to",
      "level": 3,
      "page": 51
    },
    {
      "heading": "filter out excess requests caused by bots or users’ misbehavior.",
      "level": 3,
      "page": 51
    },
    {
      "heading": "Step 1 - Understand the problem and establish design scope",
      "level": 3,
      "page": 52
    },
    {
      "heading": "Rate limiting can be implemented using different algorithms, each with its pros and cons. The",
      "level": 3,
      "page": 52
    },
    {
      "heading": "interactions between an interviewer and a candidate help to clarify the type of rate limiters we",
      "level": 3,
      "page": 52
    },
    {
      "heading": "are trying to build.",
      "level": 3,
      "page": 52
    },
    {
      "heading": "server-side API rate limiter?",
      "level": 3,
      "page": 52
    },
    {
      "heading": "Interviewer: Great question. We focus on the server-side API rate limiter.",
      "level": 3,
      "page": 52
    },
    {
      "heading": "Candidate: Does the rate limiter throttle API requests based on IP, the user ID, or other",
      "level": 3,
      "page": 52
    },
    {
      "heading": "properties?",
      "level": 3,
      "page": 52
    },
    {
      "heading": "Interviewer: The rate limiter should be flexible enough to support different sets of throttle",
      "level": 3,
      "page": 52
    },
    {
      "heading": "rules.",
      "level": 3,
      "page": 52
    },
    {
      "heading": "Candidate: What is the scale of the system? Is it built for a startup or a big company with a",
      "level": 3,
      "page": 52
    },
    {
      "heading": "large user base?",
      "level": 3,
      "page": 52
    },
    {
      "heading": "Interviewer: The system must be able to handle a large number of requests.",
      "level": 3,
      "page": 52
    },
    {
      "heading": "Candidate: Will the system work in a distributed environment?",
      "level": 3,
      "page": 52
    },
    {
      "heading": "Interviewer: Yes.",
      "level": 3,
      "page": 52
    },
    {
      "heading": "Candidate: Is the rate limiter a separate service or should it be implemented in application",
      "level": 3,
      "page": 52
    },
    {
      "heading": "code?",
      "level": 3,
      "page": 52
    },
    {
      "heading": "Interviewer: It is a design decision up to you.",
      "level": 3,
      "page": 52
    },
    {
      "heading": "Candidate: Do we need to inform users who are throttled?",
      "level": 3,
      "page": 52
    },
    {
      "heading": "Interviewer: Yes.",
      "level": 3,
      "page": 52
    },
    {
      "heading": "Requirements",
      "level": 3,
      "page": 52
    },
    {
      "heading": "Here is a summary of the requirements for the system:",
      "level": 3,
      "page": 52
    },
    {
      "heading": "• Accurately limit excessive requests.",
      "level": 3,
      "page": 52
    },
    {
      "heading": "• Low latency. The rate limiter should not slow down HTTP response time.",
      "level": 3,
      "page": 52
    },
    {
      "heading": "• Use as little memory as possible.",
      "level": 3,
      "page": 52
    },
    {
      "heading": "• Distributed rate limiting. The rate limiter can be shared across multiple servers or",
      "level": 3,
      "page": 52
    },
    {
      "heading": "processes.",
      "level": 3,
      "page": 52
    },
    {
      "heading": "• Exception handling. Show clear exceptions to users when their requests are throttled.",
      "level": 3,
      "page": 52
    },
    {
      "heading": "• High fault tolerance. If there are any problems with the rate limiter (for example, a cache",
      "level": 3,
      "page": 52
    },
    {
      "heading": "server goes offline), it does not affect the entire system.",
      "level": 3,
      "page": 52
    },
    {
      "heading": "Step 2 - Propose high-level design and get buy-in",
      "level": 3,
      "page": 53
    },
    {
      "heading": "Let us keep things simple and use a basic client and server model for communication.",
      "level": 3,
      "page": 53
    },
    {
      "heading": "Where to put the rate limiter?",
      "level": 3,
      "page": 53
    },
    {
      "heading": "Intuitively, you can implement a rate limiter at either the client or server-side.",
      "level": 3,
      "page": 53
    },
    {
      "heading": "• Client-side implementation. Generally speaking, client is an unreliable place to enforce",
      "level": 3,
      "page": 53
    },
    {
      "heading": "rate limiting because client requests can easily be forged by malicious actors. Moreover,",
      "level": 3,
      "page": 53
    },
    {
      "heading": "we might not have control over the client implementation.",
      "level": 3,
      "page": 53
    },
    {
      "heading": "• Server-side implementation. Figure 4-1 shows a rate limiter that is placed on the server-",
      "level": 3,
      "page": 53
    },
    {
      "heading": "side.",
      "level": 3,
      "page": 53
    },
    {
      "heading": "Besides the client and server-side implementations, there is an alternative way. Instead of",
      "level": 3,
      "page": 53
    },
    {
      "heading": "putting a rate limiter at the API servers, we create a rate limiter middleware, which throttles",
      "level": 3,
      "page": 53
    },
    {
      "heading": "requests to your APIs as shown in Figure 4-2.",
      "level": 3,
      "page": 53
    },
    {
      "heading": "Let us use an example in Figure 4-3 to illustrate how rate limiting works in this design.",
      "level": 3,
      "page": 53
    },
    {
      "heading": "Assume our API allows 2 requests per second, and a client sends 3 requests to the server",
      "level": 3,
      "page": 53
    },
    {
      "heading": "within a second. The first two requests are routed to API servers. However, the rate limiter",
      "level": 3,
      "page": 53
    },
    {
      "heading": "middleware throttles the third request and returns a HTTP status code 429. The HTTP 429",
      "level": 3,
      "page": 53
    },
    {
      "heading": "response status code indicates a user has sent too many requests.",
      "level": 3,
      "page": 53
    },
    {
      "heading": "Cloud microservices [4] have become widely popular and rate limiting is usually",
      "level": 3,
      "page": 54
    },
    {
      "heading": "implemented within a component called API gateway. API gateway is a fully managed",
      "level": 3,
      "page": 54
    },
    {
      "heading": "service that supports rate limiting, SSL termination, authentication, IP whitelisting, servicing",
      "level": 3,
      "page": 54
    },
    {
      "heading": "static content, etc. For now, we only need to know that the API gateway is a middleware that",
      "level": 3,
      "page": 54
    },
    {
      "heading": "supports rate limiting.",
      "level": 3,
      "page": 54
    },
    {
      "heading": "While designing a rate limiter, an important question to ask ourselves is: where should the",
      "level": 3,
      "page": 54
    },
    {
      "heading": "rater limiter be implemented, on the server-side or in a gateway? There is no absolute answer.",
      "level": 3,
      "page": 54
    },
    {
      "heading": "It depends on your company’s current technology stack, engineering resources, priorities,",
      "level": 3,
      "page": 54
    },
    {
      "heading": "goals, etc. Here are a few general guidelines:",
      "level": 3,
      "page": 54
    },
    {
      "heading": "• Evaluate your current technology stack, such as programming language, cache service,",
      "level": 3,
      "page": 54
    },
    {
      "heading": "etc. Make sure your current programming language is efficient to implement rate limiting",
      "level": 3,
      "page": 54
    },
    {
      "heading": "on the server-side.",
      "level": 3,
      "page": 54
    },
    {
      "heading": "• Identify the rate limiting algorithm that fits your business needs. When you implement",
      "level": 3,
      "page": 54
    },
    {
      "heading": "everything on the server-side, you have full control of the algorithm. However, your",
      "level": 3,
      "page": 54
    },
    {
      "heading": "choice might be limited if you use a third-party gateway.",
      "level": 3,
      "page": 54
    },
    {
      "heading": "• If you have already used microservice architecture and included an API gateway in the",
      "level": 3,
      "page": 54
    },
    {
      "heading": "design to perform authentication, IP whitelisting, etc., you may add a rate limiter to the",
      "level": 3,
      "page": 54
    },
    {
      "heading": "API gateway.",
      "level": 3,
      "page": 54
    },
    {
      "heading": "• Building your own rate limiting service takes time. If you do not have enough",
      "level": 3,
      "page": 54
    },
    {
      "heading": "engineering resources to implement a rate limiter, a commercial API gateway is a better",
      "level": 3,
      "page": 54
    },
    {
      "heading": "option.",
      "level": 3,
      "page": 54
    },
    {
      "heading": "Algorithms for rate limiting",
      "level": 3,
      "page": 54
    },
    {
      "heading": "Rate limiting can be implemented using different algorithms, and each of them has distinct",
      "level": 3,
      "page": 54
    },
    {
      "heading": "pros and cons. Even though this chapter does not focus on algorithms, understanding them at",
      "level": 3,
      "page": 54
    },
    {
      "heading": "high-level helps to choose the right algorithm or combination of algorithms to fit our use",
      "level": 3,
      "page": 54
    },
    {
      "heading": "cases. Here is a list of popular algorithms:",
      "level": 3,
      "page": 54
    },
    {
      "heading": "• Token bucket",
      "level": 3,
      "page": 54
    },
    {
      "heading": "• Leaking bucket",
      "level": 3,
      "page": 54
    },
    {
      "heading": "• Fixed window counter",
      "level": 3,
      "page": 54
    },
    {
      "heading": "• Sliding window log",
      "level": 3,
      "page": 54
    },
    {
      "heading": "• Sliding window counter",
      "level": 3,
      "page": 54
    },
    {
      "heading": "Token bucket algorithm",
      "level": 3,
      "page": 54
    },
    {
      "heading": "The token bucket algorithm is widely used for rate limiting. It is simple, well understood and",
      "level": 3,
      "page": 54
    },
    {
      "heading": "commonly used by internet companies. Both Amazon [5] and Stripe [6] use this algorithm to",
      "level": 3,
      "page": 55
    },
    {
      "heading": "throttle their API requests.",
      "level": 3,
      "page": 55
    },
    {
      "heading": "The token bucket algorithm work as follows:",
      "level": 3,
      "page": 55
    },
    {
      "heading": "• A token bucket is a container that has pre-defined capacity. Tokens are put in the bucket",
      "level": 3,
      "page": 55
    },
    {
      "heading": "at preset rates periodically. Once the bucket is full, no more tokens are added. As shown in",
      "level": 3,
      "page": 55
    },
    {
      "heading": "Figure 4-4, the token bucket capacity is 4. The refiller puts 2 tokens into the bucket every",
      "level": 3,
      "page": 55
    },
    {
      "heading": "second. Once the bucket is full, extra tokens will overflow.",
      "level": 3,
      "page": 55
    },
    {
      "heading": "• Each request consumes one token. When a request arrives, we check if there are enough",
      "level": 3,
      "page": 55
    },
    {
      "heading": "tokens in the bucket. Figure 4-5 explains how it works.",
      "level": 3,
      "page": 55
    },
    {
      "heading": "• If there are enough tokens, we take one token out for each request, and the request",
      "level": 3,
      "page": 55
    },
    {
      "heading": "goes through.",
      "level": 3,
      "page": 55
    },
    {
      "heading": "• If there are not enough tokens, the request is dropped.",
      "level": 3,
      "page": 55
    },
    {
      "heading": "Figure 4-6 illustrates how token consumption, refill, and rate limiting logic work. In this",
      "level": 3,
      "page": 56
    },
    {
      "heading": "example, the token bucket size is 4, and the refill rate is 4 per 1 minute.",
      "level": 3,
      "page": 56
    },
    {
      "heading": "The token bucket algorithm takes two parameters:",
      "level": 3,
      "page": 57
    },
    {
      "heading": "• Bucket size: the maximum number of tokens allowed in the bucket",
      "level": 3,
      "page": 57
    },
    {
      "heading": "• Refill rate: number of tokens put into the bucket every second",
      "level": 3,
      "page": 57
    },
    {
      "heading": "How many buckets do we need? This varies, and it depends on the rate-limiting rules. Here",
      "level": 3,
      "page": 57
    },
    {
      "heading": "are a few examples.",
      "level": 3,
      "page": 57
    },
    {
      "heading": "• It is usually necessary to have different buckets for different API endpoints. For instance,",
      "level": 3,
      "page": 57
    },
    {
      "heading": "if a user is allowed to make 1 post per second, add 150 friends per day, and like 5 posts per",
      "level": 3,
      "page": 57
    },
    {
      "heading": "second, 3 buckets are required for each user.",
      "level": 3,
      "page": 57
    },
    {
      "heading": "• If we need to throttle requests based on IP addresses, each IP address requires a bucket.",
      "level": 3,
      "page": 57
    },
    {
      "heading": "• If the system allows a maximum of 10,000 requests per second, it makes sense to have a",
      "level": 3,
      "page": 57
    },
    {
      "heading": "global bucket shared by all requests.",
      "level": 3,
      "page": 57
    },
    {
      "heading": "Pros:",
      "level": 3,
      "page": 57
    },
    {
      "heading": "• The algorithm is easy to implement.",
      "level": 3,
      "page": 57
    },
    {
      "heading": "• Memory efficient.",
      "level": 3,
      "page": 57
    },
    {
      "heading": "• Token bucket allows a burst of traffic for short periods. A request can go through as long",
      "level": 3,
      "page": 57
    },
    {
      "heading": "as there are tokens left.",
      "level": 3,
      "page": 57
    },
    {
      "heading": "Cons:",
      "level": 3,
      "page": 57
    },
    {
      "heading": "• Two parameters in the algorithm are bucket size and token refill rate. However, it might",
      "level": 3,
      "page": 57
    },
    {
      "heading": "be challenging to tune them properly.",
      "level": 3,
      "page": 58
    },
    {
      "heading": "Leaking bucket algorithm",
      "level": 3,
      "page": 58
    },
    {
      "heading": "The leaking bucket algorithm is similar to the token bucket except that requests are processed",
      "level": 3,
      "page": 58
    },
    {
      "heading": "at a fixed rate. It is usually implemented with a first-in-first-out (FIFO) queue. The algorithm",
      "level": 3,
      "page": 58
    },
    {
      "heading": "works as follows:",
      "level": 3,
      "page": 58
    },
    {
      "heading": "• When a request arrives, the system checks if the queue is full. If it is not full, the request",
      "level": 3,
      "page": 58
    },
    {
      "heading": "is added to the queue.",
      "level": 3,
      "page": 58
    },
    {
      "heading": "• Otherwise, the request is dropped.",
      "level": 3,
      "page": 58
    },
    {
      "heading": "• Requests are pulled from the queue and processed at regular intervals.",
      "level": 3,
      "page": 58
    },
    {
      "heading": "Figure 4-7 explains how the algorithm works.",
      "level": 3,
      "page": 58
    },
    {
      "heading": "Leaking bucket algorithm takes the following two parameters:",
      "level": 3,
      "page": 58
    },
    {
      "heading": "• Bucket size: it is equal to the queue size. The queue holds the requests to be processed at",
      "level": 3,
      "page": 58
    },
    {
      "heading": "a fixed rate.",
      "level": 3,
      "page": 58
    },
    {
      "heading": "• Outflow rate: it defines how many requests can be processed at a fixed rate, usually in",
      "level": 3,
      "page": 58
    },
    {
      "heading": "seconds.",
      "level": 3,
      "page": 58
    },
    {
      "heading": "Shopify, an ecommerce company, uses leaky buckets for rate-limiting [7].",
      "level": 3,
      "page": 58
    },
    {
      "heading": "Pros:",
      "level": 3,
      "page": 58
    },
    {
      "heading": "• Memory efficient given the limited queue size.",
      "level": 3,
      "page": 58
    },
    {
      "heading": "• Requests are processed at a fixed rate therefore it is suitable for use cases that a stable",
      "level": 3,
      "page": 58
    },
    {
      "heading": "outflow rate is needed.",
      "level": 3,
      "page": 58
    },
    {
      "heading": "Cons:",
      "level": 3,
      "page": 58
    },
    {
      "heading": "• A burst of traffic fills up the queue with old requests, and if they are not processed in",
      "level": 3,
      "page": 58
    },
    {
      "heading": "time, recent requests will be rate limited.",
      "level": 3,
      "page": 58
    },
    {
      "heading": "• There are two parameters in the algorithm. It might not be easy to tune them properly.",
      "level": 3,
      "page": 58
    },
    {
      "heading": "Fixed window counter algorithm",
      "level": 3,
      "page": 58
    },
    {
      "heading": "Fixed window counter algorithm works as follows:",
      "level": 3,
      "page": 58
    },
    {
      "heading": "• The algorithm divides the timeline into fix-sized time windows and assign a counter for",
      "level": 3,
      "page": 58
    },
    {
      "heading": "each window.",
      "level": 3,
      "page": 58
    },
    {
      "heading": "• Each request increments the counter by one.",
      "level": 3,
      "page": 58
    },
    {
      "heading": "• Once the counter reaches the pre-defined threshold, new requests are dropped until a new",
      "level": 3,
      "page": 58
    },
    {
      "heading": "time window starts.",
      "level": 3,
      "page": 58
    },
    {
      "heading": "Let us use a concrete example to see how it works. In Figure 4-8, the time unit is 1 second",
      "level": 3,
      "page": 59
    },
    {
      "heading": "and the system allows a maximum of 3 requests per second. In each second window, if more",
      "level": 3,
      "page": 59
    },
    {
      "heading": "than 3 requests are received, extra requests are dropped as shown in Figure 4-8.",
      "level": 3,
      "page": 59
    },
    {
      "heading": "A major problem with this algorithm is that a burst of traffic at the edges of time windows",
      "level": 3,
      "page": 59
    },
    {
      "heading": "could cause more requests than allowed quota to go through. Consider the following case:",
      "level": 3,
      "page": 59
    },
    {
      "heading": "In Figure 4-9, the system allows a maximum of 5 requests per minute, and the available quota",
      "level": 3,
      "page": 59
    },
    {
      "heading": "resets at the human-friendly round minute. As seen, there are five requests between 2:00:00",
      "level": 3,
      "page": 59
    },
    {
      "heading": "and 2:01:00 and five more requests between 2:01:00 and 2:02:00. For the one-minute window",
      "level": 3,
      "page": 59
    },
    {
      "heading": "between 2:00:30 and 2:01:30, 10 requests go through. That is twice as many as allowed",
      "level": 3,
      "page": 59
    },
    {
      "heading": "requests.",
      "level": 3,
      "page": 59
    },
    {
      "heading": "Pros:",
      "level": 3,
      "page": 59
    },
    {
      "heading": "• Memory efficient.",
      "level": 3,
      "page": 59
    },
    {
      "heading": "• Easy to understand.",
      "level": 3,
      "page": 60
    },
    {
      "heading": "• Resetting available quota at the end of a unit time window fits certain use cases.",
      "level": 3,
      "page": 60
    },
    {
      "heading": "Cons:",
      "level": 3,
      "page": 60
    },
    {
      "heading": "• Spike in traffic at the edges of a window could cause more requests than the allowed",
      "level": 3,
      "page": 60
    },
    {
      "heading": "quota to go through.",
      "level": 3,
      "page": 60
    },
    {
      "heading": "Sliding window log algorithm",
      "level": 3,
      "page": 60
    },
    {
      "heading": "As discussed previously, the fixed window counter algorithm has a major issue: it allows",
      "level": 3,
      "page": 60
    },
    {
      "heading": "more requests to go through at the edges of a window. The sliding window log algorithm",
      "level": 3,
      "page": 60
    },
    {
      "heading": "fixes the issue. It works as follows:",
      "level": 3,
      "page": 60
    },
    {
      "heading": "• The algorithm keeps track of request timestamps. Timestamp data is usually kept in",
      "level": 3,
      "page": 60
    },
    {
      "heading": "cache, such as sorted sets of Redis [8].",
      "level": 3,
      "page": 60
    },
    {
      "heading": "• When a new request comes in, remove all the outdated timestamps. Outdated timestamps",
      "level": 3,
      "page": 60
    },
    {
      "heading": "are defined as those older than the start of the current time window.",
      "level": 3,
      "page": 60
    },
    {
      "heading": "• Add timestamp of the new request to the log.",
      "level": 3,
      "page": 60
    },
    {
      "heading": "• If the log size is the same or lower than the allowed count, a request is accepted.",
      "level": 3,
      "page": 60
    },
    {
      "heading": "Otherwise, it is rejected.",
      "level": 3,
      "page": 60
    },
    {
      "heading": "We explain the algorithm with an example as revealed in Figure 4-10.",
      "level": 3,
      "page": 60
    },
    {
      "heading": "In this example, the rate limiter allows 2 requests per minute. Usually, Linux timestamps are",
      "level": 3,
      "page": 60
    },
    {
      "heading": "stored in the log. However, human-readable representation of time is used in our example for",
      "level": 3,
      "page": 60
    },
    {
      "heading": "better readability.",
      "level": 3,
      "page": 60
    },
    {
      "heading": "• The log is empty when a new request arrives at 1:00:01. Thus, the request is allowed.",
      "level": 3,
      "page": 60
    },
    {
      "heading": "• A new request arrives at 1:00:30, the timestamp 1:00:30 is inserted into the log. After the",
      "level": 3,
      "page": 61
    },
    {
      "heading": "insertion, the log size is 2, not larger than the allowed count. Thus, the request is allowed.",
      "level": 3,
      "page": 61
    },
    {
      "heading": "• A new request arrives at 1:00:50, and the timestamp is inserted into the log. After the",
      "level": 3,
      "page": 61
    },
    {
      "heading": "insertion, the log size is 3, larger than the allowed size 2. Therefore, this request is rejected",
      "level": 3,
      "page": 61
    },
    {
      "heading": "even though the timestamp remains in the log.",
      "level": 3,
      "page": 61
    },
    {
      "heading": "• A new request arrives at 1:01:40. Requests in the range [1:00:40,1:01:40) are within the",
      "level": 3,
      "page": 61
    },
    {
      "heading": "latest time frame, but requests sent before 1:00:40 are outdated. Two outdated timestamps,",
      "level": 3,
      "page": 61
    },
    {
      "heading": "1:00:01 and 1:00:30, are removed from the log. After the remove operation, the log size",
      "level": 3,
      "page": 61
    },
    {
      "heading": "becomes 2; therefore, the request is accepted.",
      "level": 3,
      "page": 61
    },
    {
      "heading": "Pros:",
      "level": 3,
      "page": 61
    },
    {
      "heading": "• Rate limiting implemented by this algorithm is very accurate. In any rolling window,",
      "level": 3,
      "page": 61
    },
    {
      "heading": "requests will not exceed the rate limit.",
      "level": 3,
      "page": 61
    },
    {
      "heading": "Cons:",
      "level": 3,
      "page": 61
    },
    {
      "heading": "• The algorithm consumes a lot of memory because even if a request is rejected, its",
      "level": 3,
      "page": 61
    },
    {
      "heading": "timestamp might still be stored in memory.",
      "level": 3,
      "page": 61
    },
    {
      "heading": "Sliding window counter algorithm",
      "level": 3,
      "page": 61
    },
    {
      "heading": "The sliding window counter algorithm is a hybrid approach that combines the fixed window",
      "level": 3,
      "page": 61
    },
    {
      "heading": "counter and sliding window log. The algorithm can be implemented by two different",
      "level": 3,
      "page": 61
    },
    {
      "heading": "approaches. We will explain one implementation in this section and provide reference for the",
      "level": 3,
      "page": 61
    },
    {
      "heading": "other implementation at the end of the section. Figure 4-11 illustrates how this algorithm",
      "level": 3,
      "page": 61
    },
    {
      "heading": "works.",
      "level": 3,
      "page": 61
    },
    {
      "heading": "Assume the rate limiter allows a maximum of 7 requests per minute, and there are 5 requests",
      "level": 3,
      "page": 61
    },
    {
      "heading": "in the previous minute and 3 in the current minute. For a new request that arrives at a 30%",
      "level": 3,
      "page": 61
    },
    {
      "heading": "position in the current minute, the number of requests in the rolling window is calculated",
      "level": 3,
      "page": 61
    },
    {
      "heading": "using the following formula:",
      "level": 3,
      "page": 61
    },
    {
      "heading": "• Requests in current window + requests in the previous window * overlap percentage of",
      "level": 3,
      "page": 61
    },
    {
      "heading": "the rolling window and previous window",
      "level": 3,
      "page": 61
    },
    {
      "heading": "• Using this formula, we get 3 + 5 * 0.7% = 6.5 request. Depending on the use case, the",
      "level": 3,
      "page": 62
    },
    {
      "heading": "number can either be rounded up or down. In our example, it is rounded down to 6.",
      "level": 3,
      "page": 62
    },
    {
      "heading": "Since the rate limiter allows a maximum of 7 requests per minute, the current request can go",
      "level": 3,
      "page": 62
    },
    {
      "heading": "through. However, the limit will be reached after receiving one more request.",
      "level": 3,
      "page": 62
    },
    {
      "heading": "Due to the space limitation, we will not discuss the other implementation here. Interested",
      "level": 3,
      "page": 62
    },
    {
      "heading": "readers should refer to the reference material [9]. This algorithm is not perfect. It has pros and",
      "level": 3,
      "page": 62
    },
    {
      "heading": "cons.",
      "level": 3,
      "page": 62
    },
    {
      "heading": "Pros",
      "level": 3,
      "page": 62
    },
    {
      "heading": "• It smooths out spikes in traffic because the rate is based on the average rate of the",
      "level": 3,
      "page": 62
    },
    {
      "heading": "previous window.",
      "level": 3,
      "page": 62
    },
    {
      "heading": "• Memory efficient.",
      "level": 3,
      "page": 62
    },
    {
      "heading": "Cons",
      "level": 3,
      "page": 62
    },
    {
      "heading": "• It only works for not-so-strict look back window. It is an approximation of the actual rate",
      "level": 3,
      "page": 62
    },
    {
      "heading": "because it assumes requests in the previous window are evenly distributed. However, this",
      "level": 3,
      "page": 62
    },
    {
      "heading": "problem may not be as bad as it seems. According to experiments done by Cloudflare [10],",
      "level": 3,
      "page": 62
    },
    {
      "heading": "only 0.003% of requests are wrongly allowed or rate limited among 400 million requests.",
      "level": 3,
      "page": 62
    },
    {
      "heading": "High-level architecture",
      "level": 3,
      "page": 62
    },
    {
      "heading": "The basic idea of rate limiting algorithms is simple. At the high-level, we need a counter to",
      "level": 3,
      "page": 62
    },
    {
      "heading": "keep track of how many requests are sent from the same user, IP address, etc. If the counter is",
      "level": 3,
      "page": 62
    },
    {
      "heading": "larger than the limit, the request is disallowed.",
      "level": 3,
      "page": 62
    },
    {
      "heading": "Where shall we store counters? Using the database is not a good idea due to slowness of disk",
      "level": 3,
      "page": 62
    },
    {
      "heading": "access. In-memory cache is chosen because it is fast and supports time-based expiration",
      "level": 3,
      "page": 62
    },
    {
      "heading": "strategy. For instance, Redis [11] is a popular option to implement rate limiting. It is an in-",
      "level": 3,
      "page": 62
    },
    {
      "heading": "memory store that offers two commands: INCR and EXPIRE.",
      "level": 3,
      "page": 62
    },
    {
      "heading": "• INCR: It increases the stored counter by 1.",
      "level": 3,
      "page": 62
    },
    {
      "heading": "• EXPIRE: It sets a timeout for the counter. If the timeout expires, the counter is",
      "level": 3,
      "page": 62
    },
    {
      "heading": "automatically deleted.",
      "level": 3,
      "page": 62
    },
    {
      "heading": "Figure 4-12 shows the high-level architecture for rate limiting, and this works as follows:",
      "level": 3,
      "page": 62
    },
    {
      "heading": "• The client sends a request to rate limiting middleware.",
      "level": 3,
      "page": 62
    },
    {
      "heading": "• Rate limiting middleware fetches the counter from the corresponding bucket in Redis and",
      "level": 3,
      "page": 62
    },
    {
      "heading": "checks if the limit is reached or not.",
      "level": 3,
      "page": 63
    },
    {
      "heading": "• If the limit is reached, the request is rejected.",
      "level": 3,
      "page": 63
    },
    {
      "heading": "• If the limit is not reached, the request is sent to API servers. Meanwhile, the system",
      "level": 3,
      "page": 63
    },
    {
      "heading": "increments the counter and saves it back to Redis.",
      "level": 3,
      "page": 63
    },
    {
      "heading": "Step 3 - Design deep dive",
      "level": 3,
      "page": 64
    },
    {
      "heading": "The high-level design in Figure 4-12 does not answer the following questions:",
      "level": 3,
      "page": 64
    },
    {
      "heading": "• How are rate limiting rules created? Where are the rules stored?",
      "level": 3,
      "page": 64
    },
    {
      "heading": "• How to handle requests that are rate limited?",
      "level": 3,
      "page": 64
    },
    {
      "heading": "In this section, we will first answer the questions regarding rate limiting rules and then go",
      "level": 3,
      "page": 64
    },
    {
      "heading": "over the strategies to handle rate-limited requests. Finally, we will discuss rate limiting in",
      "level": 3,
      "page": 64
    },
    {
      "heading": "distributed environment, a detailed design, performance optimization and monitoring.",
      "level": 3,
      "page": 64
    },
    {
      "heading": "Rate limiting rules",
      "level": 3,
      "page": 64
    },
    {
      "heading": "Lyft open-sourced their rate-limiting component [12]. We will peek inside of the component",
      "level": 3,
      "page": 64
    },
    {
      "heading": "and look at some examples of rate limiting rules:",
      "level": 3,
      "page": 64
    },
    {
      "heading": "domain: messaging",
      "level": 3,
      "page": 64
    },
    {
      "heading": "descriptors:",
      "level": 3,
      "page": 64
    },
    {
      "heading": "- key: message_type",
      "level": 3,
      "page": 64
    },
    {
      "heading": "Value: marketing",
      "level": 3,
      "page": 64
    },
    {
      "heading": "rate_limit:",
      "level": 3,
      "page": 64
    },
    {
      "heading": "unit: day",
      "level": 3,
      "page": 64
    },
    {
      "heading": "requests_per_unit: 5",
      "level": 3,
      "page": 64
    },
    {
      "heading": "In the above example, the system is configured to allow a maximum of 5 marketing messages",
      "level": 3,
      "page": 64
    },
    {
      "heading": "per day. Here is another example:",
      "level": 3,
      "page": 64
    },
    {
      "heading": "domain: auth",
      "level": 3,
      "page": 64
    },
    {
      "heading": "descriptors:",
      "level": 3,
      "page": 64
    },
    {
      "heading": "- key: auth_type",
      "level": 3,
      "page": 64
    },
    {
      "heading": "Value: login",
      "level": 3,
      "page": 64
    },
    {
      "heading": "rate_limit:",
      "level": 3,
      "page": 64
    },
    {
      "heading": "unit: minute",
      "level": 3,
      "page": 64
    },
    {
      "heading": "requests_per_unit: 5",
      "level": 3,
      "page": 64
    },
    {
      "heading": "This rule shows that clients are not allowed to login more than 5 times in 1 minute. Rules are",
      "level": 3,
      "page": 64
    },
    {
      "heading": "generally written in configuration files and saved on disk.",
      "level": 3,
      "page": 64
    },
    {
      "heading": "Exceeding the rate limit",
      "level": 3,
      "page": 64
    },
    {
      "heading": "In case a request is rate limited, APIs return a HTTP response code 429 (too many requests)",
      "level": 3,
      "page": 64
    },
    {
      "heading": "to the client. Depending on the use cases, we may enqueue the rate-limited requests to be",
      "level": 3,
      "page": 64
    },
    {
      "heading": "processed later. For example, if some orders are rate limited due to system overload, we may",
      "level": 3,
      "page": 64
    },
    {
      "heading": "keep those orders to be processed later.",
      "level": 3,
      "page": 64
    },
    {
      "heading": "Rate limiter headers",
      "level": 3,
      "page": 64
    },
    {
      "heading": "How does a client know whether it is being throttled? And how does a client know the",
      "level": 3,
      "page": 64
    },
    {
      "heading": "number of allowed remaining requests before being throttled? The answer lies in HTTP",
      "level": 3,
      "page": 64
    },
    {
      "heading": "response headers. The rate limiter returns the following HTTP headers to clients:",
      "level": 3,
      "page": 64
    },
    {
      "heading": "X-Ratelimit-Remaining: The remaining number of allowed requests within the window.",
      "level": 3,
      "page": 64
    },
    {
      "heading": "X-Ratelimit-Limit: It indicates how many calls the client can make per time window.",
      "level": 3,
      "page": 64
    },
    {
      "heading": "X-Ratelimit-Retry-After: The number of seconds to wait until you can make a request again",
      "level": 3,
      "page": 64
    },
    {
      "heading": "without being throttled.",
      "level": 3,
      "page": 64
    },
    {
      "heading": "When a user has sent too many requests, a 429 too many requests error and X-Ratelimit-",
      "level": 3,
      "page": 64
    },
    {
      "heading": "Retry-After header are returned to the client.",
      "level": 3,
      "page": 65
    },
    {
      "heading": "Detailed design",
      "level": 3,
      "page": 65
    },
    {
      "heading": "Figure 4-13 presents a detailed design of the system.",
      "level": 3,
      "page": 65
    },
    {
      "heading": "• Rules are stored on the disk. Workers frequently pull rules from the disk and store them",
      "level": 3,
      "page": 65
    },
    {
      "heading": "in the cache.",
      "level": 3,
      "page": 65
    },
    {
      "heading": "• When a client sends a request to the server, the request is sent to the rate limiter",
      "level": 3,
      "page": 65
    },
    {
      "heading": "middleware first.",
      "level": 3,
      "page": 65
    },
    {
      "heading": "• Rate limiter middleware loads rules from the cache. It fetches counters and last request",
      "level": 3,
      "page": 65
    },
    {
      "heading": "timestamp from Redis cache. Based on the response, the rate limiter decides:",
      "level": 3,
      "page": 65
    },
    {
      "heading": "• if the request is not rate limited, it is forwarded to API servers.",
      "level": 3,
      "page": 65
    },
    {
      "heading": "• if the request is rate limited, the rate limiter returns 429 too many requests error to",
      "level": 3,
      "page": 65
    },
    {
      "heading": "the client. In the meantime, the request is either dropped or forwarded to the queue.",
      "level": 3,
      "page": 65
    },
    {
      "heading": "Rate limiter in a distributed environment",
      "level": 3,
      "page": 66
    },
    {
      "heading": "Building a rate limiter that works in a single server environment is not difficult. However,",
      "level": 3,
      "page": 66
    },
    {
      "heading": "scaling the system to support multiple servers and concurrent threads is a different story.",
      "level": 3,
      "page": 66
    },
    {
      "heading": "There are two challenges:",
      "level": 3,
      "page": 66
    },
    {
      "heading": "• Race condition",
      "level": 3,
      "page": 66
    },
    {
      "heading": "• Synchronization issue",
      "level": 3,
      "page": 66
    },
    {
      "heading": "Race condition",
      "level": 3,
      "page": 66
    },
    {
      "heading": "As discussed earlier, rate limiter works as follows at the high-level:",
      "level": 3,
      "page": 66
    },
    {
      "heading": "• Read the counter value from Redis.",
      "level": 3,
      "page": 66
    },
    {
      "heading": "• Check if ( counter + 1 ) exceeds the threshold.",
      "level": 3,
      "page": 66
    },
    {
      "heading": "• If not, increment the counter value by 1 in Redis.",
      "level": 3,
      "page": 66
    },
    {
      "heading": "Race conditions can happen in a highly concurrent environment as shown in Figure 4-14.",
      "level": 3,
      "page": 66
    },
    {
      "heading": "Assume the counter value in Redis is 3. If two requests concurrently read the counter value",
      "level": 3,
      "page": 66
    },
    {
      "heading": "before either of them writes the value back, each will increment the counter by one and write",
      "level": 3,
      "page": 66
    },
    {
      "heading": "it back without checking the other thread. Both requests (threads) believe they have the",
      "level": 3,
      "page": 66
    },
    {
      "heading": "correct counter value 4. However, the correct counter value should be 5.",
      "level": 3,
      "page": 66
    },
    {
      "heading": "Locks are the most obvious solution for solving race condition. However, locks will",
      "level": 3,
      "page": 66
    },
    {
      "heading": "significantly slow down the system. Two strategies are commonly used to solve the problem:",
      "level": 3,
      "page": 66
    },
    {
      "heading": "Lua script [13] and sorted sets data structure in Redis [8]. For readers interested in these",
      "level": 3,
      "page": 66
    },
    {
      "heading": "strategies, refer to the corresponding reference materials [8] [13].",
      "level": 3,
      "page": 66
    },
    {
      "heading": "Synchronization issue",
      "level": 3,
      "page": 66
    },
    {
      "heading": "Synchronization is another important factor to consider in a distributed environment. To",
      "level": 3,
      "page": 66
    },
    {
      "heading": "support millions of users, one rate limiter server might not be enough to handle the traffic.",
      "level": 3,
      "page": 66
    },
    {
      "heading": "When multiple rate limiter servers are used, synchronization is required. For example, on the",
      "level": 3,
      "page": 66
    },
    {
      "heading": "left side of Figure 4-15, client 1 sends requests to rate limiter 1, and client 2 sends requests to",
      "level": 3,
      "page": 66
    },
    {
      "heading": "as shown on the right side of Figure 4-15. If no synchronization happens, rate limiter 1 does",
      "level": 3,
      "page": 67
    },
    {
      "heading": "not contain any data about client 2. Thus, the rate limiter cannot work properly.",
      "level": 3,
      "page": 67
    },
    {
      "heading": "One possible solution is to use sticky sessions that allow a client to send traffic to the same",
      "level": 3,
      "page": 67
    },
    {
      "heading": "rate limiter. This solution is not advisable because it is neither scalable nor flexible. A better",
      "level": 3,
      "page": 67
    },
    {
      "heading": "approach is to use centralized data stores like Redis. The design is shown in Figure 4-16.",
      "level": 3,
      "page": 67
    },
    {
      "heading": "Performance optimization",
      "level": 3,
      "page": 67
    },
    {
      "heading": "Performance optimization is a common topic in system design interviews. We will cover two",
      "level": 3,
      "page": 67
    },
    {
      "heading": "areas to improve.",
      "level": 3,
      "page": 67
    },
    {
      "heading": "First, multi-data center setup is crucial for a rate limiter because latency is high for users",
      "level": 3,
      "page": 67
    },
    {
      "heading": "located far away from the data center. Most cloud service providers build many edge server",
      "level": 3,
      "page": 67
    },
    {
      "heading": "locations around the world. For example, as of 5/20 2020, Cloudflare has 194 geographically",
      "level": 3,
      "page": 67
    },
    {
      "heading": "distributed edge servers [14]. Traffic is automatically routed to the closest edge server to",
      "level": 3,
      "page": 67
    },
    {
      "heading": "reduce latency.",
      "level": 3,
      "page": 67
    },
    {
      "heading": "Second, synchronize data with an eventual consistency model. If you are unclear about the",
      "level": 3,
      "page": 68
    },
    {
      "heading": "eventual consistency model, refer to the “Consistency” section in “Chapter 6: Design a Key-",
      "level": 3,
      "page": 68
    },
    {
      "heading": "value Store.”",
      "level": 3,
      "page": 68
    },
    {
      "heading": "Monitoring",
      "level": 3,
      "page": 68
    },
    {
      "heading": "After the rate limiter is put in place, it is important to gather analytics data to check whether",
      "level": 3,
      "page": 68
    },
    {
      "heading": "the rate limiter is effective. Primarily, we want to make sure:",
      "level": 3,
      "page": 68
    },
    {
      "heading": "• The rate limiting algorithm is effective.",
      "level": 3,
      "page": 68
    },
    {
      "heading": "• The rate limiting rules are effective.",
      "level": 3,
      "page": 68
    },
    {
      "heading": "For example, if rate limiting rules are too strict, many valid requests are dropped. In this case,",
      "level": 3,
      "page": 68
    },
    {
      "heading": "we want to relax the rules a little bit. In another example, we notice our rate limiter becomes",
      "level": 3,
      "page": 68
    },
    {
      "heading": "ineffective when there is a sudden increase in traffic like flash sales. In this scenario, we may",
      "level": 3,
      "page": 68
    },
    {
      "heading": "replace the algorithm to support burst traffic. Token bucket is a good fit here.",
      "level": 3,
      "page": 68
    },
    {
      "heading": "Step 4 - Wrap up",
      "level": 3,
      "page": 69
    },
    {
      "heading": "In this chapter, we discussed different algorithms of rate limiting and their pros/cons.",
      "level": 3,
      "page": 69
    },
    {
      "heading": "Algorithms discussed include:",
      "level": 3,
      "page": 69
    },
    {
      "heading": "• Token bucket",
      "level": 3,
      "page": 69
    },
    {
      "heading": "• Leaking bucket",
      "level": 3,
      "page": 69
    },
    {
      "heading": "• Fixed window",
      "level": 3,
      "page": 69
    },
    {
      "heading": "• Sliding window log",
      "level": 3,
      "page": 69
    },
    {
      "heading": "• Sliding window counter",
      "level": 3,
      "page": 69
    },
    {
      "heading": "Then, we discussed the system architecture, rate limiter in a distributed environment,",
      "level": 3,
      "page": 69
    },
    {
      "heading": "performance optimization and monitoring. Similar to any system design interview questions,",
      "level": 3,
      "page": 69
    },
    {
      "heading": "there are additional talking points you can mention if time allows:",
      "level": 3,
      "page": 69
    },
    {
      "heading": "• Hard vs soft rate limiting.",
      "level": 3,
      "page": 69
    },
    {
      "heading": "• Hard: The number of requests cannot exceed the threshold.",
      "level": 3,
      "page": 69
    },
    {
      "heading": "• Soft:  Requests can exceed the threshold for a short period.",
      "level": 3,
      "page": 69
    },
    {
      "heading": "• Rate limiting at different levels. In this chapter, we only talked about rate limiting at the",
      "level": 3,
      "page": 69
    },
    {
      "heading": "application level (HTTP: layer 7). It is possible to apply rate limiting at other layers. For",
      "level": 3,
      "page": 69
    },
    {
      "heading": "example, you can apply rate limiting by IP addresses using Iptables [15] (IP: layer 3).",
      "level": 3,
      "page": 69
    },
    {
      "heading": "Note: The Open Systems Interconnection model (OSI model) has 7 layers [16]:  Layer 1:",
      "level": 3,
      "page": 69
    },
    {
      "heading": "Layer 5: Session layer, Layer 6: Presentation layer, Layer 7: Application layer.",
      "level": 3,
      "page": 69
    },
    {
      "heading": "• Avoid being rate limited. Design your client with best practices:",
      "level": 3,
      "page": 69
    },
    {
      "heading": "• Use client cache to avoid making frequent API calls.",
      "level": 3,
      "page": 69
    },
    {
      "heading": "• Understand the limit and do not send too many requests in a short time frame.",
      "level": 3,
      "page": 69
    },
    {
      "heading": "• Include code to catch exceptions or errors so your client can gracefully recover from",
      "level": 3,
      "page": 69
    },
    {
      "heading": "exceptions.",
      "level": 3,
      "page": 69
    },
    {
      "heading": "• Add sufficient back off time to retry logic.",
      "level": 3,
      "page": 69
    },
    {
      "heading": "Congratulations on getting this far! Now give yourself a pat on the back. Good job!",
      "level": 3,
      "page": 69
    },
    {
      "heading": "Reference materials",
      "level": 2,
      "page": 70
    },
    {
      "heading": "[1] Rate-limiting strategies and techniques: https://cloud.google.com/solutions/rate-limiting-",
      "level": 3,
      "page": 70
    },
    {
      "heading": "strategies-techniques",
      "level": 3,
      "page": 70
    },
    {
      "heading": "[2] Twitter rate limits: https://developer.twitter.com/en/docs/basics/rate-limits",
      "level": 3,
      "page": 70
    },
    {
      "heading": "[3] Google docs usage limits: https://developers.google.com/docs/api/limits",
      "level": 3,
      "page": 70
    },
    {
      "heading": "[4] IBM microservices: https://www.ibm.com/cloud/learn/microservices",
      "level": 3,
      "page": 70
    },
    {
      "heading": "[5] Throttle API requests for better throughput:",
      "level": 3,
      "page": 70
    },
    {
      "heading": "https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-request-",
      "level": 3,
      "page": 70
    },
    {
      "heading": "throttling.html",
      "level": 3,
      "page": 70
    },
    {
      "heading": "[6] Stripe rate limiters: https://stripe.com/blog/rate-limiters",
      "level": 3,
      "page": 70
    },
    {
      "heading": "[7] Shopify REST Admin API rate limits: https://help.shopify.com/en/api/reference/rest-",
      "level": 3,
      "page": 70
    },
    {
      "heading": "admin-api-rate-limits",
      "level": 3,
      "page": 70
    },
    {
      "heading": "[8] Better Rate Limiting With Redis Sorted Sets:",
      "level": 3,
      "page": 70
    },
    {
      "heading": "https://engineering.classdojo.com/blog/2015/02/06/rolling-rate-limiter/",
      "level": 3,
      "page": 70
    },
    {
      "heading": "[9] System Design — Rate limiter and Data modelling:",
      "level": 3,
      "page": 70
    },
    {
      "heading": "https://medium.com/@saisandeepmopuri/system-design-rate-limiter-and-data-modelling-",
      "level": 3,
      "page": 70
    },
    {
      "heading": "9304b0d18250",
      "level": 3,
      "page": 70
    },
    {
      "heading": "[10] How we built rate limiting capable of scaling to millions of domains:",
      "level": 3,
      "page": 70
    },
    {
      "heading": "https://blog.cloudflare.com/counting-things-a-lot-of-different-things/",
      "level": 3,
      "page": 70
    },
    {
      "heading": "[11] Redis website: https://redis.io/",
      "level": 3,
      "page": 70
    },
    {
      "heading": "[12] Lyft rate limiting: https://github.com/lyft/ratelimit",
      "level": 3,
      "page": 70
    },
    {
      "heading": "[13] Scaling your API with rate limiters:",
      "level": 3,
      "page": 70
    },
    {
      "heading": "https://gist.github.com/ptarjan/e38f45f2dfe601419ca3af937fff574d#request-rate-limiter",
      "level": 3,
      "page": 70
    },
    {
      "heading": "[14] What is edge computing: https://www.cloudflare.com/learning/serverless/glossary/what-",
      "level": 3,
      "page": 70
    },
    {
      "heading": "is-edge-computing/",
      "level": 3,
      "page": 70
    },
    {
      "heading": "[15] Rate Limit Requests with Iptables: https://blog.programster.org/rate-limit-requests-with-",
      "level": 3,
      "page": 70
    },
    {
      "heading": "iptables",
      "level": 3,
      "page": 70
    },
    {
      "heading": "[16] OSI model: https://en.wikipedia.org/wiki/OSI_model#Layer_architecture",
      "level": 3,
      "page": 70
    },
    {
      "heading": "CHAPTER 5: DESIGN CONSISTENT HASHING",
      "level": 1,
      "page": 71
    },
    {
      "heading": "To achieve horizontal scaling, it is important to distribute requests/data efficiently and evenly",
      "level": 3,
      "page": 71
    },
    {
      "heading": "across servers. Consistent hashing is a commonly used technique to achieve this goal. But",
      "level": 3,
      "page": 71
    },
    {
      "heading": "first, let us take an in-depth look at the problem.",
      "level": 3,
      "page": 71
    },
    {
      "heading": "The rehashing problem",
      "level": 3,
      "page": 72
    },
    {
      "heading": "If you have n  cache servers, a common way to balance the load is to use the following hash",
      "level": 3,
      "page": 72
    },
    {
      "heading": "method:",
      "level": 3,
      "page": 72
    },
    {
      "heading": "serverIndex = hash(key) % N, where N is the size of the server pool.",
      "level": 3,
      "page": 72
    },
    {
      "heading": "Let us use an example to illustrate how it works. As shown in Table 5-1, we have 4 servers",
      "level": 3,
      "page": 72
    },
    {
      "heading": "and 8 string keys with their hashes.",
      "level": 3,
      "page": 72
    },
    {
      "heading": "To fetch the server where a key is stored, we perform the modular operation f(key) % 4. For",
      "level": 3,
      "page": 72
    },
    {
      "heading": "instance, hash(key0) % 4 = 1 means a client must contact server 1 to fetch the cached data.",
      "level": 3,
      "page": 72
    },
    {
      "heading": "Figure 5-1 shows the distribution of keys based on Table 5-1.",
      "level": 3,
      "page": 72
    },
    {
      "heading": "This approach works well when the size of the server pool is fixed, and the data distribution",
      "level": 3,
      "page": 73
    },
    {
      "heading": "is even. However, problems arise when new servers are added, or existing servers are",
      "level": 3,
      "page": 73
    },
    {
      "heading": "removed. For example, if server 1 goes offline, the size of the server pool becomes 3. Using",
      "level": 3,
      "page": 73
    },
    {
      "heading": "the same hash function, we get the same hash value for a key. But applying modular",
      "level": 3,
      "page": 73
    },
    {
      "heading": "operation gives us different server indexes because the number of servers is reduced by 1. We",
      "level": 3,
      "page": 73
    },
    {
      "heading": "get the results as shown in Table 5-2 by applying hash % 3:",
      "level": 3,
      "page": 73
    },
    {
      "heading": "Figure 5-2 shows the new distribution of keys based on Table 5-2.",
      "level": 3,
      "page": 73
    },
    {
      "heading": "As shown in Figure 5-2, most keys are redistributed, not just the ones originally stored in the",
      "level": 3,
      "page": 74
    },
    {
      "heading": "offline server (server 1). This means that when server 1 goes offline, most cache clients will",
      "level": 3,
      "page": 74
    },
    {
      "heading": "connect to the wrong servers to fetch data. This causes a storm of cache misses. Consistent",
      "level": 3,
      "page": 74
    },
    {
      "heading": "hashing is an effective technique to mitigate this problem.",
      "level": 3,
      "page": 74
    },
    {
      "heading": "Consistent hashing",
      "level": 3,
      "page": 75
    },
    {
      "heading": "Quoted from Wikipedia: \"Consistent hashing is a special kind of hashing such that when a",
      "level": 3,
      "page": 75
    },
    {
      "heading": "hash table is re-sized and consistent hashing is used, only k/n  keys need to be remapped on",
      "level": 3,
      "page": 75
    },
    {
      "heading": "average, where k is the number of keys, and n is the number of slots. In contrast, in most",
      "level": 3,
      "page": 75
    },
    {
      "heading": "traditional hash tables, a change in the number of array slots causes nearly all keys to be",
      "level": 3,
      "page": 75
    },
    {
      "heading": "remapped [1]”.",
      "level": 3,
      "page": 75
    },
    {
      "heading": "Hash space and hash ring",
      "level": 3,
      "page": 75
    },
    {
      "heading": "Now we understand the definition of consistent hashing, let us find out how it works. Assume",
      "level": 3,
      "page": 75
    },
    {
      "heading": "SHA-1 is used as the hash function f, and the output range of the hash function is: x0, x1, x2,",
      "level": 3,
      "page": 75
    },
    {
      "heading": "x3, …, xn. In cryptography, SHA-1’s hash space goes from 0 to 2^160 - 1. That means x0",
      "level": 3,
      "page": 75
    },
    {
      "heading": "corresponds to 0, xn corresponds to 2^160 – 1, and all the other hash values in the middle fall",
      "level": 3,
      "page": 75
    },
    {
      "heading": "between 0 and 2^160 - 1. Figure 5-3 shows the hash space.",
      "level": 3,
      "page": 75
    },
    {
      "heading": "By collecting both ends, we get a hash ring as shown in Figure 5-4:",
      "level": 3,
      "page": 75
    },
    {
      "heading": "Hash servers",
      "level": 3,
      "page": 75
    },
    {
      "heading": "Using the same hash function f, we map servers based on server IP or name onto the ring.",
      "level": 3,
      "page": 75
    },
    {
      "heading": "Figure 5-5 shows that 4 servers are mapped on the hash ring.",
      "level": 3,
      "page": 75
    },
    {
      "heading": "Hash keys",
      "level": 3,
      "page": 76
    },
    {
      "heading": "One thing worth mentioning is that hash function used here is different from the one in “the",
      "level": 3,
      "page": 76
    },
    {
      "heading": "rehashing problem,” and there is no modular operation. As shown in Figure 5-6, 4 cache keys",
      "level": 3,
      "page": 76
    },
    {
      "heading": "(key0, key1, key2, and key3) are hashed onto the hash ring",
      "level": 3,
      "page": 76
    },
    {
      "heading": "Server lookup",
      "level": 3,
      "page": 76
    },
    {
      "heading": "To determine which server a key is stored on, we go clockwise from the key position on the",
      "level": 3,
      "page": 77
    },
    {
      "heading": "ring until a server is found. Figure 5-7 explains this process. Going clockwise, key0  is stored",
      "level": 3,
      "page": 77
    },
    {
      "heading": "on server 0; key1 is stored on server 1; key2 is stored on server 2 and key3 is stored on server",
      "level": 3,
      "page": 77
    },
    {
      "heading": "Add a server",
      "level": 3,
      "page": 77
    },
    {
      "heading": "Using the logic described above, adding a new server will only require redistribution of a",
      "level": 3,
      "page": 77
    },
    {
      "heading": "fraction of keys.",
      "level": 3,
      "page": 77
    },
    {
      "heading": "In Figure 5-8, after a new server 4 is added, only key0 needs to be redistributed. k1, k2, and",
      "level": 3,
      "page": 77
    },
    {
      "heading": "k3 remain on the same servers. Let us take a close look at the logic. Before server 4 is added,",
      "level": 3,
      "page": 77
    },
    {
      "heading": "key0 is stored on server 0. Now, key0 will be stored on server 4 because server 4 is the first",
      "level": 3,
      "page": 77
    },
    {
      "heading": "server it encounters by going clockwise from key0’s position on the ring. The other keys are",
      "level": 3,
      "page": 77
    },
    {
      "heading": "not redistributed based on consistent hashing algorithm.",
      "level": 3,
      "page": 77
    },
    {
      "heading": "Remove a server",
      "level": 3,
      "page": 78
    },
    {
      "heading": "When a server is removed, only a small fraction of keys require redistribution with consistent",
      "level": 3,
      "page": 78
    },
    {
      "heading": "hashing. In Figure 5-9, when server 1 is removed, only key1 must be remapped to server 2.",
      "level": 3,
      "page": 78
    },
    {
      "heading": "The rest of the keys are unaffected.",
      "level": 3,
      "page": 78
    },
    {
      "heading": "Two issues in the basic approach",
      "level": 3,
      "page": 79
    },
    {
      "heading": "The consistent hashing algorithm was introduced by Karger et al. at MIT [1]. The basic steps",
      "level": 3,
      "page": 79
    },
    {
      "heading": "are:",
      "level": 3,
      "page": 79
    },
    {
      "heading": "• Map servers and keys on to the ring using a uniformly distributed hash function.",
      "level": 3,
      "page": 79
    },
    {
      "heading": "• To find out which server a key is mapped to, go clockwise from the key position until the",
      "level": 3,
      "page": 79
    },
    {
      "heading": "first server on the ring is found.",
      "level": 3,
      "page": 79
    },
    {
      "heading": "Two problems are identified with this approach. First, it is impossible to keep the same size",
      "level": 3,
      "page": 79
    },
    {
      "heading": "of partitions on the ring for all servers considering a server can be added or removed. A",
      "level": 3,
      "page": 79
    },
    {
      "heading": "partition is the hash space between adjacent servers. It is possible that the size of the",
      "level": 3,
      "page": 79
    },
    {
      "heading": "partitions on the ring assigned to each server is very small or fairly large. In Figure 5-10, if s1",
      "level": 3,
      "page": 79
    },
    {
      "heading": "is removed, s2’s partition (highlighted with the bidirectional arrows) is twice as large as s0",
      "level": 3,
      "page": 79
    },
    {
      "heading": "and s3’s partition.",
      "level": 3,
      "page": 79
    },
    {
      "heading": "Second, it is possible to have a non-uniform key distribution on the ring. For instance, if",
      "level": 3,
      "page": 80
    },
    {
      "heading": "servers are mapped to positions listed in Figure 5-11, most of the keys are stored on server 2.",
      "level": 3,
      "page": 80
    },
    {
      "heading": "However, server 1 and server 3 have no data.",
      "level": 3,
      "page": 80
    },
    {
      "heading": "A technique called virtual nodes or replicas is used to solve these problems.",
      "level": 3,
      "page": 80
    },
    {
      "heading": "Virtual nodes",
      "level": 3,
      "page": 80
    },
    {
      "heading": "A virtual node refers to the real node, and each server is represented by multiple virtual nodes",
      "level": 3,
      "page": 80
    },
    {
      "heading": "on the ring. In Figure 5-12, both server 0 and server 1 have 3 virtual nodes. The 3 is",
      "level": 3,
      "page": 80
    },
    {
      "heading": "arbitrarily chosen; and in real-world systems, the number of virtual nodes is much larger.",
      "level": 3,
      "page": 81
    },
    {
      "heading": "Instead of using s0, we have s0_0, s0_1, and s0_2 to represent server 0 on the ring. Similarly,",
      "level": 3,
      "page": 81
    },
    {
      "heading": "s1_0, s1_1, and s1_2 represent server 1 on the ring. With virtual nodes, each server is",
      "level": 3,
      "page": 81
    },
    {
      "heading": "responsible for multiple partitions. Partitions (edges) with label s0 are managed by server 0.",
      "level": 3,
      "page": 81
    },
    {
      "heading": "On the other hand, partitions with label s1 are managed by server 1.",
      "level": 3,
      "page": 81
    },
    {
      "heading": "To find which server a key is stored on, we go clockwise from the key’s location and find the",
      "level": 3,
      "page": 81
    },
    {
      "heading": "first virtual node encountered on the ring. In Figure 5-13, to find out which server k0 is stored",
      "level": 3,
      "page": 81
    },
    {
      "heading": "on, we go clockwise from k0’s location and find virtual node s1_1, which refers to server 1.",
      "level": 3,
      "page": 81
    },
    {
      "heading": "As the number of virtual nodes increases, the distribution of keys becomes more balanced.",
      "level": 3,
      "page": 82
    },
    {
      "heading": "This is because the standard deviation gets smaller with more virtual nodes, leading to",
      "level": 3,
      "page": 82
    },
    {
      "heading": "balanced data distribution. Standard deviation measures how data are spread out. The",
      "level": 3,
      "page": 82
    },
    {
      "heading": "outcome of an experiment carried out by online research [2] shows that with one or two",
      "level": 3,
      "page": 82
    },
    {
      "heading": "hundred virtual nodes, the standard deviation is between 5% (200 virtual nodes) and 10%",
      "level": 3,
      "page": 82
    },
    {
      "heading": "(100 virtual nodes) of the mean. The standard deviation will be smaller when we increase the",
      "level": 3,
      "page": 82
    },
    {
      "heading": "number of virtual nodes. However, more spaces are needed to store data about virtual nodes.",
      "level": 3,
      "page": 82
    },
    {
      "heading": "This is a tradeoff, and we can tune the number of virtual nodes to fit our system requirements.",
      "level": 3,
      "page": 82
    },
    {
      "heading": "Find affected keys",
      "level": 3,
      "page": 82
    },
    {
      "heading": "When a server is added or removed, a fraction of data needs to be redistributed. How can we",
      "level": 3,
      "page": 82
    },
    {
      "heading": "find the affected range to redistribute the keys?",
      "level": 3,
      "page": 82
    },
    {
      "heading": "In Figure 5-14, server 4 is added onto the ring. The affected range starts from s4 (newly",
      "level": 3,
      "page": 82
    },
    {
      "heading": "added node) and moves anticlockwise around the ring until a server is found (s3). Thus, keys",
      "level": 3,
      "page": 82
    },
    {
      "heading": "located between s3 and s4 need to be redistributed to s4.",
      "level": 3,
      "page": 82
    },
    {
      "heading": "When a server (s1) is removed as shown in Figure 5-15, the affected range starts from s1",
      "level": 3,
      "page": 83
    },
    {
      "heading": "(removed node) and moves anticlockwise around the ring until a server is found (s0). Thus,",
      "level": 3,
      "page": 83
    },
    {
      "heading": "keys located between s0 and s1 must be redistributed to s2.",
      "level": 3,
      "page": 83
    },
    {
      "heading": "Wrap up",
      "level": 3,
      "page": 85
    },
    {
      "heading": "In this chapter, we had an in-depth discussion about consistent hashing, including why it is",
      "level": 3,
      "page": 85
    },
    {
      "heading": "needed and how it works. The benefits of consistent hashing include:",
      "level": 3,
      "page": 85
    },
    {
      "heading": "• Minimized keys are redistributed when servers are added or removed.",
      "level": 3,
      "page": 85
    },
    {
      "heading": "• It is easy to scale horizontally because data are more evenly distributed.",
      "level": 3,
      "page": 85
    },
    {
      "heading": "• Mitigate hotspot key problem. Excessive access to a specific shard could cause server",
      "level": 3,
      "page": 85
    },
    {
      "heading": "overload. Imagine data for Katy Perry, Justin Bieber, and Lady Gaga all end up on the",
      "level": 3,
      "page": 85
    },
    {
      "heading": "same shard. Consistent hashing helps to mitigate the problem by distributing the data more",
      "level": 3,
      "page": 85
    },
    {
      "heading": "evenly.",
      "level": 3,
      "page": 85
    },
    {
      "heading": "Consistent hashing is widely used in real-world systems, including some notable ones:",
      "level": 3,
      "page": 85
    },
    {
      "heading": "• Partitioning component of Amazon’s Dynamo database [3]",
      "level": 3,
      "page": 85
    },
    {
      "heading": "• Data partitioning across the cluster in Apache Cassandra [4]",
      "level": 3,
      "page": 85
    },
    {
      "heading": "• Discord chat application [5]",
      "level": 3,
      "page": 85
    },
    {
      "heading": "• Akamai content delivery network [6]",
      "level": 3,
      "page": 85
    },
    {
      "heading": "• Maglev network load balancer [7]",
      "level": 3,
      "page": 85
    },
    {
      "heading": "Congratulations on getting this far! Now give yourself a pat on the back. Good job!",
      "level": 3,
      "page": 85
    },
    {
      "heading": "Reference materials",
      "level": 2,
      "page": 86
    },
    {
      "heading": "[1] Consistent hashing: https://en.wikipedia.org/wiki/Consistent_hashing",
      "level": 3,
      "page": 86
    },
    {
      "heading": "[2] Consistent Hashing:",
      "level": 3,
      "page": 86
    },
    {
      "heading": "https://tom-e-white.com/2007/11/consistent-hashing.html",
      "level": 3,
      "page": 86
    },
    {
      "heading": "[3] Dynamo: Amazon’s Highly Available Key-value Store:",
      "level": 3,
      "page": 86
    },
    {
      "heading": "https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf",
      "level": 3,
      "page": 86
    },
    {
      "heading": "[4] Cassandra - A Decentralized Structured Storage System:",
      "level": 3,
      "page": 86
    },
    {
      "heading": "http://www.cs.cornell.edu/Projects/ladis2009/papers/Lakshman-ladis2009.PDF",
      "level": 3,
      "page": 86
    },
    {
      "heading": "[5] How Discord Scaled Elixir to 5,000,000 Concurrent Users:",
      "level": 3,
      "page": 86
    },
    {
      "heading": "https://blog.discord.com/scaling-elixir-f9b8e1e7c29b",
      "level": 3,
      "page": 86
    },
    {
      "heading": "[6] CS168: The Modern Algorithmic Toolbox Lecture #1: Introduction and Consistent",
      "level": 3,
      "page": 86
    },
    {
      "heading": "Hashing: http://theory.stanford.edu/~tim/s16/l/l1.pdf",
      "level": 3,
      "page": 86
    },
    {
      "heading": "[7] Maglev: A Fast and Reliable Software Network Load Balancer:",
      "level": 3,
      "page": 86
    },
    {
      "heading": "https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/44824.pdf",
      "level": 3,
      "page": 86
    },
    {
      "heading": "CHAPTER 6: DESIGN A KEY-VALUE STORE",
      "level": 1,
      "page": 87
    },
    {
      "heading": "A key-value store, also referred to as a key-value database, is a non-relational database. Each",
      "level": 3,
      "page": 87
    },
    {
      "heading": "unique identifier is stored as a key with its associated value. This data pairing is known as a",
      "level": 3,
      "page": 87
    },
    {
      "heading": "“key-value” pair.",
      "level": 3,
      "page": 87
    },
    {
      "heading": "In a key-value pair, the key must be unique, and the value associated with the key can be",
      "level": 3,
      "page": 87
    },
    {
      "heading": "accessed through the key. Keys can be plain text or hashed values. For performance reasons,",
      "level": 3,
      "page": 87
    },
    {
      "heading": "a short key works better. What do keys look like? Here are a few examples:",
      "level": 3,
      "page": 87
    },
    {
      "heading": "• Plain text key: “last_logged_in_at”",
      "level": 3,
      "page": 87
    },
    {
      "heading": "• Hashed key: 253DDEC4",
      "level": 3,
      "page": 87
    },
    {
      "heading": "The value in a key-value pair can be strings, lists, objects, etc. The value is usually treated as",
      "level": 3,
      "page": 87
    },
    {
      "heading": "an opaque object in key-value stores, such as Amazon dynamo [1], Memcached [2], Redis",
      "level": 3,
      "page": 87
    },
    {
      "heading": "[3], etc.",
      "level": 3,
      "page": 87
    },
    {
      "heading": "Here is a data snippet in a key-value store:",
      "level": 3,
      "page": 87
    },
    {
      "heading": "In this chapter, you are asked to design a key-value store that supports the following",
      "level": 3,
      "page": 87
    },
    {
      "heading": "operations:",
      "level": 3,
      "page": 87
    },
    {
      "heading": "- put(key, value)  // insert “value” associated with “key”",
      "level": 3,
      "page": 87
    },
    {
      "heading": "- get(key)  // get “value” associated with “key”",
      "level": 3,
      "page": 87
    },
    {
      "heading": "Understand the problem and establish design scope",
      "level": 3,
      "page": 88
    },
    {
      "heading": "There is no perfect design. Each design achieves a specific balance regarding the tradeoffs of",
      "level": 3,
      "page": 88
    },
    {
      "heading": "the read, write, and memory usage. Another tradeoff has to be made was between consistency",
      "level": 3,
      "page": 88
    },
    {
      "heading": "and availability. In this chapter, we design a key-value store that comprises of the following",
      "level": 3,
      "page": 88
    },
    {
      "heading": "characteristics:",
      "level": 3,
      "page": 88
    },
    {
      "heading": "• The size of a key-value pair is small: less than 10 KB.",
      "level": 3,
      "page": 88
    },
    {
      "heading": "• Ability to store big data.",
      "level": 3,
      "page": 88
    },
    {
      "heading": "• High availability: The system responds quickly, even during failures.",
      "level": 3,
      "page": 88
    },
    {
      "heading": "• High scalability: The system can be scaled to support large data set.",
      "level": 3,
      "page": 88
    },
    {
      "heading": "• Automatic scaling: The addition/deletion of servers should be automatic based on traffic.",
      "level": 3,
      "page": 88
    },
    {
      "heading": "• Tunable consistency.",
      "level": 3,
      "page": 88
    },
    {
      "heading": "• Low latency.",
      "level": 3,
      "page": 88
    },
    {
      "heading": "Single server key-value store",
      "level": 3,
      "page": 89
    },
    {
      "heading": "Developing a key-value store that resides in a single server is easy. An intuitive approach is",
      "level": 3,
      "page": 89
    },
    {
      "heading": "to store key-value pairs in a hash table, which keeps everything in memory. Even though",
      "level": 3,
      "page": 89
    },
    {
      "heading": "memory access is fast, fitting everything in memory may be impossible due to the space",
      "level": 3,
      "page": 89
    },
    {
      "heading": "constraint. Two optimizations can be done to fit more data in a single server:",
      "level": 3,
      "page": 89
    },
    {
      "heading": "• Data compression",
      "level": 3,
      "page": 89
    },
    {
      "heading": "• Store only frequently used data in memory and the rest on disk",
      "level": 3,
      "page": 89
    },
    {
      "heading": "Even with these optimizations, a single server can reach its capacity very quickly. A",
      "level": 3,
      "page": 89
    },
    {
      "heading": "distributed key-value store is required to support big data.",
      "level": 3,
      "page": 89
    },
    {
      "heading": "Distributed key-value store",
      "level": 3,
      "page": 90
    },
    {
      "heading": "A distributed key-value store is also called a distributed hash table, which distributes key-",
      "level": 3,
      "page": 90
    },
    {
      "heading": "value pairs across many servers. When designing a distributed system, it is important to",
      "level": 3,
      "page": 90
    },
    {
      "heading": "understand CAP (Consistency, Availability, Partition Tolerance) theorem.",
      "level": 3,
      "page": 90
    },
    {
      "heading": "CAP theorem",
      "level": 3,
      "page": 90
    },
    {
      "heading": "CAP theorem states it is impossible for a distributed system to simultaneously provide more",
      "level": 3,
      "page": 90
    },
    {
      "heading": "than two of these three guarantees: consistency, availability, and partition tolerance. Let us",
      "level": 3,
      "page": 90
    },
    {
      "heading": "establish a few definitions.",
      "level": 3,
      "page": 90
    },
    {
      "heading": "Consistency: consistency means all clients see the same data at the same time no matter",
      "level": 3,
      "page": 90
    },
    {
      "heading": "which node they connect to.",
      "level": 3,
      "page": 90
    },
    {
      "heading": "Availability: availability means any client which requests data gets a response even if some",
      "level": 3,
      "page": 90
    },
    {
      "heading": "of the nodes are down.",
      "level": 3,
      "page": 90
    },
    {
      "heading": "Partition Tolerance: a partition indicates a communication break between two nodes.",
      "level": 3,
      "page": 90
    },
    {
      "heading": "Partition tolerance means the system continues to operate despite network partitions.",
      "level": 3,
      "page": 90
    },
    {
      "heading": "CAP theorem states that one of the three properties must be sacrificed to support 2 of the 3",
      "level": 3,
      "page": 90
    },
    {
      "heading": "properties as shown in Figure 6-1.",
      "level": 3,
      "page": 90
    },
    {
      "heading": "Nowadays, key-value stores are classified based on the two CAP characteristics they support:",
      "level": 3,
      "page": 90
    },
    {
      "heading": "CP (consistency and partition tolerance) systems: a CP key-value store supports",
      "level": 3,
      "page": 90
    },
    {
      "heading": "consistency and partition tolerance while sacrificing availability.",
      "level": 3,
      "page": 90
    },
    {
      "heading": "AP (availability and partition tolerance) systems: an AP key-value store supports",
      "level": 3,
      "page": 90
    },
    {
      "heading": "availability and partition tolerance while sacrificing consistency.",
      "level": 3,
      "page": 90
    },
    {
      "heading": "CA (consistency and availability) systems: a CA key-value store supports consistency and",
      "level": 3,
      "page": 90
    },
    {
      "heading": "availability while sacrificing partition tolerance. Since network failure is unavoidable, a",
      "level": 3,
      "page": 91
    },
    {
      "heading": "distributed system must tolerate network partition. Thus, a CA system cannot exist in real-",
      "level": 3,
      "page": 91
    },
    {
      "heading": "world applications.",
      "level": 3,
      "page": 91
    },
    {
      "heading": "What you read above is mostly the definition part. To make it easier to understand, let us take",
      "level": 3,
      "page": 91
    },
    {
      "heading": "a look at some concrete examples. In distributed systems, data is usually replicated multiple",
      "level": 3,
      "page": 91
    },
    {
      "heading": "times. Assume data are replicated on three replica nodes, n1, n2 and n3 as shown in Figure 6-",
      "level": 3,
      "page": 91
    },
    {
      "heading": "Ideal situation",
      "level": 3,
      "page": 91
    },
    {
      "heading": "In the ideal world, network partition never occurs. Data written to n1 is automatically",
      "level": 3,
      "page": 91
    },
    {
      "heading": "replicated to n2 and n3. Both consistency and availability are achieved.",
      "level": 3,
      "page": 91
    },
    {
      "heading": "Real-world distributed systems",
      "level": 3,
      "page": 91
    },
    {
      "heading": "In a distributed system, partitions cannot be avoided, and when a partition occurs, we must",
      "level": 3,
      "page": 91
    },
    {
      "heading": "choose between consistency and availability. In Figure 6-3, n3 goes down and cannot",
      "level": 3,
      "page": 91
    },
    {
      "heading": "communicate with n1 and n2. If clients write data to n1 or n2, data cannot be propagated to",
      "level": 3,
      "page": 91
    },
    {
      "heading": "n3. If data is written to n3 but not propagated to n1 and n2 yet, n1 and n2 would have stale",
      "level": 3,
      "page": 91
    },
    {
      "heading": "data.",
      "level": 3,
      "page": 91
    },
    {
      "heading": "If we choose consistency over availability (CP system), we must block all write operations to",
      "level": 3,
      "page": 92
    },
    {
      "heading": "n1 and n2 to avoid data inconsistency among these three servers, which makes the system",
      "level": 3,
      "page": 92
    },
    {
      "heading": "unavailable. Bank systems usually have extremely high consistent requirements. For",
      "level": 3,
      "page": 92
    },
    {
      "heading": "example, it is crucial for a bank system to display the most up-to-date balance info. If",
      "level": 3,
      "page": 92
    },
    {
      "heading": "inconsistency occurs due to a network partition, the bank system returns an error before the",
      "level": 3,
      "page": 92
    },
    {
      "heading": "inconsistency is resolved.",
      "level": 3,
      "page": 92
    },
    {
      "heading": "However, if we choose availability over consistency (AP system), the system keeps accepting",
      "level": 3,
      "page": 92
    },
    {
      "heading": "reads, even though it might return stale data. For writes, n1 and n2 will keep accepting writes,",
      "level": 3,
      "page": 92
    },
    {
      "heading": "and data will be synced to n3 when the network partition is resolved.",
      "level": 3,
      "page": 92
    },
    {
      "heading": "Choosing the right CAP guarantees that fit your use case is an important step in building a",
      "level": 3,
      "page": 92
    },
    {
      "heading": "distributed key-value store. You can discuss this with your interviewer and design the system",
      "level": 3,
      "page": 92
    },
    {
      "heading": "accordingly.",
      "level": 3,
      "page": 92
    },
    {
      "heading": "System components",
      "level": 3,
      "page": 92
    },
    {
      "heading": "In this section, we will discuss the following core components and techniques used to build a",
      "level": 3,
      "page": 92
    },
    {
      "heading": "key-value store:",
      "level": 3,
      "page": 92
    },
    {
      "heading": "• Data partition",
      "level": 3,
      "page": 92
    },
    {
      "heading": "• Data replication",
      "level": 3,
      "page": 92
    },
    {
      "heading": "• Consistency",
      "level": 3,
      "page": 92
    },
    {
      "heading": "• Inconsistency resolution",
      "level": 3,
      "page": 92
    },
    {
      "heading": "• Handling failures",
      "level": 3,
      "page": 92
    },
    {
      "heading": "• System architecture diagram",
      "level": 3,
      "page": 92
    },
    {
      "heading": "• Write path",
      "level": 3,
      "page": 92
    },
    {
      "heading": "• Read path",
      "level": 3,
      "page": 92
    },
    {
      "heading": "The content below is largely based on three popular key-value store systems: Dynamo [4],",
      "level": 3,
      "page": 93
    },
    {
      "heading": "Cassandra [5], and BigTable [6].",
      "level": 3,
      "page": 93
    },
    {
      "heading": "Data partition",
      "level": 3,
      "page": 93
    },
    {
      "heading": "For large applications, it is infeasible to fit the complete data set in a single server. The",
      "level": 3,
      "page": 93
    },
    {
      "heading": "simplest way to accomplish this is to split the data into smaller partitions and store them in",
      "level": 3,
      "page": 93
    },
    {
      "heading": "multiple servers. There are two challenges while partitioning the data:",
      "level": 3,
      "page": 93
    },
    {
      "heading": "• Distribute data across multiple servers evenly.",
      "level": 3,
      "page": 93
    },
    {
      "heading": "• Minimize data movement when nodes are added or removed.",
      "level": 3,
      "page": 93
    },
    {
      "heading": "Consistent hashing discussed in Chapter 5 is a great technique to solve these problems. Let us",
      "level": 3,
      "page": 93
    },
    {
      "heading": "revisit how consistent hashing works at a high-level.",
      "level": 3,
      "page": 93
    },
    {
      "heading": "• First, servers are placed on a hash ring. In Figure 6-4, eight servers, represented by s0,",
      "level": 3,
      "page": 93
    },
    {
      "heading": "s1, …, s7, are placed on the hash ring.",
      "level": 3,
      "page": 93
    },
    {
      "heading": "• Next, a key is hashed onto the same ring, and it is stored on the first server encountered",
      "level": 3,
      "page": 93
    },
    {
      "heading": "while moving in the clockwise direction. For instance, key0 is stored in s1 using this logic.",
      "level": 3,
      "page": 93
    },
    {
      "heading": "Using consistent hashing to partition data has the following advantages:",
      "level": 3,
      "page": 93
    },
    {
      "heading": "Automatic scaling: servers could be added and removed automatically depending on the",
      "level": 3,
      "page": 93
    },
    {
      "heading": "load.",
      "level": 3,
      "page": 94
    },
    {
      "heading": "Heterogeneity: the number of virtual nodes for a server is proportional to the server capacity.",
      "level": 3,
      "page": 94
    },
    {
      "heading": "For example, servers with higher capacity are assigned with more virtual nodes.",
      "level": 3,
      "page": 94
    },
    {
      "heading": "Data replication",
      "level": 3,
      "page": 94
    },
    {
      "heading": "To achieve high availability and reliability, data must be replicated asynchronously over N",
      "level": 3,
      "page": 94
    },
    {
      "heading": "servers, where N is a configurable parameter. These N servers are chosen using the following",
      "level": 3,
      "page": 94
    },
    {
      "heading": "logic: after a key is mapped to a position on the hash ring, walk clockwise from that position",
      "level": 3,
      "page": 94
    },
    {
      "heading": "and choose the first N servers on the ring to store data copies. In Figure 6-5 (N = 3), key0 is",
      "level": 3,
      "page": 94
    },
    {
      "heading": "replicated at s1, s2, and s3.",
      "level": 3,
      "page": 94
    },
    {
      "heading": "With virtual nodes, the first N nodes on the ring may be owned by fewer than N physical",
      "level": 3,
      "page": 94
    },
    {
      "heading": "servers. To avoid this issue, we only choose unique servers while performing the clockwise",
      "level": 3,
      "page": 94
    },
    {
      "heading": "walk logic.",
      "level": 3,
      "page": 94
    },
    {
      "heading": "Nodes in the same data center often fail at the same time due to power outages, network",
      "level": 3,
      "page": 94
    },
    {
      "heading": "issues, natural disasters, etc. For better reliability, replicas are placed in distinct data centers,",
      "level": 3,
      "page": 94
    },
    {
      "heading": "and data centers are connected through high-speed networks.",
      "level": 3,
      "page": 94
    },
    {
      "heading": "Consistency",
      "level": 3,
      "page": 95
    },
    {
      "heading": "Since data is replicated at multiple nodes, it must be synchronized across replicas. Quorum",
      "level": 3,
      "page": 95
    },
    {
      "heading": "consensus can guarantee consistency for both read and write operations. Let us establish a",
      "level": 3,
      "page": 95
    },
    {
      "heading": "few definitions first.",
      "level": 3,
      "page": 95
    },
    {
      "heading": "N = The number of replicas",
      "level": 3,
      "page": 95
    },
    {
      "heading": "W = A write quorum of size W. For a write operation to be considered as successful, write",
      "level": 3,
      "page": 95
    },
    {
      "heading": "operation must be acknowledged from W replicas.",
      "level": 3,
      "page": 95
    },
    {
      "heading": "R = A read quorum of size R. For a read operation to be considered as successful, read",
      "level": 3,
      "page": 95
    },
    {
      "heading": "operation must wait for responses from at least R replicas.",
      "level": 3,
      "page": 95
    },
    {
      "heading": "Consider the following example shown in Figure 6-6 with N = 3.",
      "level": 3,
      "page": 95
    },
    {
      "heading": "W = 1 does not mean data is written on one server. For instance, with the configuration in",
      "level": 3,
      "page": 95
    },
    {
      "heading": "Figure 6-6, data is replicated at s0, s1, and s2. W = 1 means that the coordinator must receive",
      "level": 3,
      "page": 95
    },
    {
      "heading": "at least one acknowledgment before the write operation is considered as successful. For",
      "level": 3,
      "page": 95
    },
    {
      "heading": "instance, if we get an acknowledgment from s1, we no longer need to wait for",
      "level": 3,
      "page": 95
    },
    {
      "heading": "acknowledgements from s0 and s2. A coordinator acts as a proxy between the client and the",
      "level": 3,
      "page": 95
    },
    {
      "heading": "nodes.",
      "level": 3,
      "page": 95
    },
    {
      "heading": "The configuration of W, R and N is a typical tradeoff between latency and consistency. If W =",
      "level": 3,
      "page": 95
    },
    {
      "heading": "1 or R = 1, an operation is returned quickly because a coordinator only needs to wait for a",
      "level": 3,
      "page": 95
    },
    {
      "heading": "response from any of the replicas. If W or R > 1, the system offers better consistency;",
      "level": 3,
      "page": 95
    },
    {
      "heading": "however, the query will be slower because the coordinator must wait for the response from",
      "level": 3,
      "page": 95
    },
    {
      "heading": "the slowest replica.",
      "level": 3,
      "page": 95
    },
    {
      "heading": "If W + R > N, strong consistency is guaranteed because there must be at least one",
      "level": 3,
      "page": 95
    },
    {
      "heading": "overlapping node that has the latest data to ensure consistency.",
      "level": 3,
      "page": 96
    },
    {
      "heading": "How to configure N, W, and R to fit our use cases? Here are some of the possible setups:",
      "level": 3,
      "page": 96
    },
    {
      "heading": "If R = 1 and W = N, the system is optimized for a fast read.",
      "level": 3,
      "page": 96
    },
    {
      "heading": "If W = 1 and R = N, the system is optimized for fast write.",
      "level": 3,
      "page": 96
    },
    {
      "heading": "If W + R > N, strong consistency is guaranteed (Usually N = 3, W = R = 2).",
      "level": 3,
      "page": 96
    },
    {
      "heading": "If W + R <= N, strong consistency is not guaranteed.",
      "level": 3,
      "page": 96
    },
    {
      "heading": "Depending on the requirement, we can tune the values of W, R, N to achieve the desired level",
      "level": 3,
      "page": 96
    },
    {
      "heading": "of consistency.",
      "level": 3,
      "page": 96
    },
    {
      "heading": "Consistency models",
      "level": 3,
      "page": 96
    },
    {
      "heading": "Consistency model is other important factor to consider when designing a key-value store. A",
      "level": 3,
      "page": 96
    },
    {
      "heading": "consistency model defines the degree of data consistency, and a wide spectrum of possible",
      "level": 3,
      "page": 96
    },
    {
      "heading": "consistency models exist:",
      "level": 3,
      "page": 96
    },
    {
      "heading": "• Strong consistency: any read operation returns a value corresponding to the result of the",
      "level": 3,
      "page": 96
    },
    {
      "heading": "most updated write data item. A client never sees out-of-date data.",
      "level": 3,
      "page": 96
    },
    {
      "heading": "• Weak consistency: subsequent read operations may not see the most updated value.",
      "level": 3,
      "page": 96
    },
    {
      "heading": "• Eventual consistency: this is a specific form of weak consistency. Given enough time, all",
      "level": 3,
      "page": 96
    },
    {
      "heading": "updates are propagated, and all replicas are consistent.",
      "level": 3,
      "page": 96
    },
    {
      "heading": "Strong consistency is usually achieved by forcing a replica not to accept new reads/writes",
      "level": 3,
      "page": 96
    },
    {
      "heading": "until every replica has agreed on current write. This approach is not ideal for highly available",
      "level": 3,
      "page": 96
    },
    {
      "heading": "systems because it could block new operations. Dynamo and Cassandra adopt eventual",
      "level": 3,
      "page": 96
    },
    {
      "heading": "consistency, which is our recommended consistency model for our key-value store. From",
      "level": 3,
      "page": 96
    },
    {
      "heading": "concurrent writes, eventual consistency allows inconsistent values to enter the system and",
      "level": 3,
      "page": 96
    },
    {
      "heading": "force the client to read the values to reconcile. The next section explains how reconciliation",
      "level": 3,
      "page": 96
    },
    {
      "heading": "works with versioning.",
      "level": 3,
      "page": 96
    },
    {
      "heading": "Inconsistency resolution: versioning",
      "level": 3,
      "page": 97
    },
    {
      "heading": "Replication gives high availability but causes inconsistencies among replicas. Versioning and",
      "level": 3,
      "page": 97
    },
    {
      "heading": "vector locks are used to solve inconsistency problems. Versioning means treating each data",
      "level": 3,
      "page": 97
    },
    {
      "heading": "modification as a new immutable version of data. Before we talk about versioning, let us use",
      "level": 3,
      "page": 97
    },
    {
      "heading": "an example to explain how inconsistency happens:",
      "level": 3,
      "page": 97
    },
    {
      "heading": "As shown in Figure 6-7, both replica nodes n1 and n2 have the same value. Let us call this",
      "level": 3,
      "page": 97
    },
    {
      "heading": "value the original value. Server 1 and server 2 get the same value for get(“name”) operation.",
      "level": 3,
      "page": 97
    },
    {
      "heading": "Next, server 1 changes the name to “johnSanFrancisco”, and server 2 changes the name to",
      "level": 3,
      "page": 97
    },
    {
      "heading": "“johnNewYork” as shown in Figure 6-8. These two changes are performed simultaneously.",
      "level": 3,
      "page": 97
    },
    {
      "heading": "Now, we have conflicting values, called versions v1 and v2.",
      "level": 3,
      "page": 97
    },
    {
      "heading": "In this example, the original value could be ignored because the modifications were based on",
      "level": 3,
      "page": 97
    },
    {
      "heading": "it. However, there is no clear way to resolve the conflict of the last two versions. To resolve",
      "level": 3,
      "page": 97
    },
    {
      "heading": "this issue, we need a versioning system that can detect conflicts and reconcile conflicts. A",
      "level": 3,
      "page": 97
    },
    {
      "heading": "vector clock is a common technique to solve this problem. Let us examine how vector clocks",
      "level": 3,
      "page": 97
    },
    {
      "heading": "work.",
      "level": 3,
      "page": 97
    },
    {
      "heading": "A vector clock is a [server, version] pair associated with a data item. It can be used to check",
      "level": 3,
      "page": 98
    },
    {
      "heading": "if one version precedes, succeeds, or in conflict with others.",
      "level": 3,
      "page": 98
    },
    {
      "heading": "Assume a vector clock is represented by D([S1, v1], [S2, v2], …, [Sn, vn]), where D is a data",
      "level": 3,
      "page": 98
    },
    {
      "heading": "Si, the system must perform one of the following tasks.",
      "level": 3,
      "page": 98
    },
    {
      "heading": "• Increment vi if [Si, vi] exists.",
      "level": 3,
      "page": 98
    },
    {
      "heading": "• Otherwise, create a new entry [Si, 1].",
      "level": 3,
      "page": 98
    },
    {
      "heading": "The above abstract logic is explained with a concrete example as shown in Figure 6-9.",
      "level": 3,
      "page": 98
    },
    {
      "heading": "1. A client writes a data item D1 to the system, and the write is handled by server Sx,",
      "level": 3,
      "page": 98
    },
    {
      "heading": "which now has the vector clock D1[(Sx, 1)].",
      "level": 3,
      "page": 98
    },
    {
      "heading": "2. Another client reads the latest D1, updates it to D2, and writes it back. D2 descends",
      "level": 3,
      "page": 98
    },
    {
      "heading": "from D1 so it overwrites D1. Assume the write is handled by the same server Sx, which",
      "level": 3,
      "page": 98
    },
    {
      "heading": "now has vector clock D2([Sx, 2]).",
      "level": 3,
      "page": 98
    },
    {
      "heading": "3. Another client reads the latest D2, updates it to D3, and writes it back. Assume the write",
      "level": 3,
      "page": 98
    },
    {
      "heading": "is handled by server Sy, which now has vector clock D3([Sx, 2], [Sy, 1])).",
      "level": 3,
      "page": 98
    },
    {
      "heading": "4. Another client reads the latest D2, updates it to D4, and writes it back. Assume the write",
      "level": 3,
      "page": 98
    },
    {
      "heading": "is handled by server Sz, which now has D4([Sx, 2], [Sz, 1])).",
      "level": 3,
      "page": 99
    },
    {
      "heading": "5. When another client reads D3 and D4, it discovers a conflict, which is caused by data",
      "level": 3,
      "page": 99
    },
    {
      "heading": "item D2 being modified by both Sy and Sz. The conflict is resolved by the client and",
      "level": 3,
      "page": 99
    },
    {
      "heading": "updated data is sent to the server. Assume the write is handled by Sx, which now has",
      "level": 3,
      "page": 99
    },
    {
      "heading": "D5([Sx, 3], [Sy, 1], [Sz, 1]). We will explain how to detect conflict shortly.",
      "level": 3,
      "page": 99
    },
    {
      "heading": "Using vector clocks, it is easy to tell that a version X is an ancestor (i.e. no conflict) of",
      "level": 3,
      "page": 99
    },
    {
      "heading": "version Y if the version counters for each participant in the vector clock of Y is greater than or",
      "level": 3,
      "page": 99
    },
    {
      "heading": "equal to the ones in version X. For example, the vector clock D([s0, 1], [s1, 1])] is an",
      "level": 3,
      "page": 99
    },
    {
      "heading": "ancestor of D([s0, 1], [s1, 2]). Therefore, no conflict is recorded.",
      "level": 3,
      "page": 99
    },
    {
      "heading": "Similarly, you can tell that a version X is a sibling (i.e., a conflict exists) of Y if there is any",
      "level": 3,
      "page": 99
    },
    {
      "heading": "participant in Y's vector clock who has a counter that is less than its corresponding counter in",
      "level": 3,
      "page": 99
    },
    {
      "heading": "X. For example, the following two vector clocks indicate there is a conflict: D([s0, 1], [s1,",
      "level": 3,
      "page": 99
    },
    {
      "heading": "2]) and D([s0, 2], [s1, 1]).",
      "level": 3,
      "page": 99
    },
    {
      "heading": "Even though vector clocks can resolve conflicts, there are two notable downsides. First,",
      "level": 3,
      "page": 99
    },
    {
      "heading": "vector clocks add complexity to the client because it needs to implement conflict resolution",
      "level": 3,
      "page": 99
    },
    {
      "heading": "logic.",
      "level": 3,
      "page": 99
    },
    {
      "heading": "Second, the [server: version] pairs in the vector clock could grow rapidly. To fix this",
      "level": 3,
      "page": 99
    },
    {
      "heading": "problem, we set a threshold for the length, and if it exceeds the limit, the oldest pairs are",
      "level": 3,
      "page": 99
    },
    {
      "heading": "removed. This can lead to inefficiencies in reconciliation because the descendant relationship",
      "level": 3,
      "page": 99
    },
    {
      "heading": "cannot be determined accurately. However, based on Dynamo paper [4], Amazon has not yet",
      "level": 3,
      "page": 99
    },
    {
      "heading": "encountered this problem in production; therefore, it is probably an acceptable solution for",
      "level": 3,
      "page": 99
    },
    {
      "heading": "most companies.",
      "level": 3,
      "page": 99
    },
    {
      "heading": "Handling failures",
      "level": 3,
      "page": 99
    },
    {
      "heading": "As with any large system at scale, failures are not only inevitable but common. Handling",
      "level": 3,
      "page": 99
    },
    {
      "heading": "failure scenarios is very important. In this section, we first introduce techniques to detect",
      "level": 3,
      "page": 99
    },
    {
      "heading": "failures. Then, we go over common failure resolution strategies.",
      "level": 3,
      "page": 99
    },
    {
      "heading": "Failure detection",
      "level": 3,
      "page": 99
    },
    {
      "heading": "In a distributed system, it is insufficient to believe that a server is down because another",
      "level": 3,
      "page": 99
    },
    {
      "heading": "server says so. Usually, it requires at least two independent sources of information to mark a",
      "level": 3,
      "page": 99
    },
    {
      "heading": "server down.",
      "level": 3,
      "page": 99
    },
    {
      "heading": "As shown in Figure 6-10, all-to-all multicasting is a straightforward solution. However, this is",
      "level": 3,
      "page": 99
    },
    {
      "heading": "inefficient when many servers are in the system.",
      "level": 3,
      "page": 99
    },
    {
      "heading": "A better solution is to use decentralized failure detection methods like gossip protocol.",
      "level": 3,
      "page": 100
    },
    {
      "heading": "Gossip protocol works as follows:",
      "level": 3,
      "page": 100
    },
    {
      "heading": "• Each node maintains a node membership list, which contains member IDs and heartbeat",
      "level": 3,
      "page": 100
    },
    {
      "heading": "counters.",
      "level": 3,
      "page": 100
    },
    {
      "heading": "• Each node periodically increments its heartbeat counter.",
      "level": 3,
      "page": 100
    },
    {
      "heading": "• Each node periodically sends heartbeats to a set of random nodes, which in turn",
      "level": 3,
      "page": 100
    },
    {
      "heading": "propagate to another set of nodes.",
      "level": 3,
      "page": 100
    },
    {
      "heading": "• Once nodes receive heartbeats, membership list is updated to the latest info.",
      "level": 3,
      "page": 100
    },
    {
      "heading": "• If the heartbeat has not increased for more than predefined periods, the member is",
      "level": 3,
      "page": 100
    },
    {
      "heading": "considered as offline.",
      "level": 3,
      "page": 100
    },
    {
      "heading": "As shown in Figure 6-11:",
      "level": 3,
      "page": 100
    },
    {
      "heading": "• Node s0 maintains a node membership list shown on the left side.",
      "level": 3,
      "page": 101
    },
    {
      "heading": "• Node s0 notices that node s2’s (member ID = 2) heartbeat counter has not increased for a",
      "level": 3,
      "page": 101
    },
    {
      "heading": "long time.",
      "level": 3,
      "page": 101
    },
    {
      "heading": "• Node s0 sends heartbeats that include s2’s info to a set of random nodes. Once other",
      "level": 3,
      "page": 101
    },
    {
      "heading": "nodes confirm that s2’s heartbeat counter has not been updated for a long time, node s2 is",
      "level": 3,
      "page": 101
    },
    {
      "heading": "marked down, and this information is propagated to other nodes.",
      "level": 3,
      "page": 101
    },
    {
      "heading": "Handling temporary failures",
      "level": 3,
      "page": 101
    },
    {
      "heading": "After failures have been detected through the gossip protocol, the system needs to deploy",
      "level": 3,
      "page": 101
    },
    {
      "heading": "certain mechanisms to ensure availability. In the strict quorum approach, read and write",
      "level": 3,
      "page": 101
    },
    {
      "heading": "operations could be blocked as illustrated in the quorum consensus section.",
      "level": 3,
      "page": 101
    },
    {
      "heading": "A technique called “sloppy quorum” [4] is used to improve availability. Instead of enforcing",
      "level": 3,
      "page": 101
    },
    {
      "heading": "the quorum requirement, the system chooses the first W healthy servers for writes and first R",
      "level": 3,
      "page": 101
    },
    {
      "heading": "healthy servers for reads on the hash ring. Offline servers are ignored.",
      "level": 3,
      "page": 101
    },
    {
      "heading": "If a server is unavailable due to network or server failures, another server will process",
      "level": 3,
      "page": 101
    },
    {
      "heading": "requests temporarily. When the down server is up, changes will be pushed back to achieve",
      "level": 3,
      "page": 101
    },
    {
      "heading": "data consistency. This process is called hinted handoff. Since s2 is unavailable in Figure 6-",
      "level": 3,
      "page": 101
    },
    {
      "heading": "12, reads and writes will be handled by s3 temporarily. When s2 comes back online, s3 will",
      "level": 3,
      "page": 101
    },
    {
      "heading": "hand the data back to s2.",
      "level": 3,
      "page": 101
    },
    {
      "heading": "Handling permanent failures",
      "level": 3,
      "page": 101
    },
    {
      "heading": "Hinted handoff is used to handle temporary failures. What if a replica is permanently",
      "level": 3,
      "page": 102
    },
    {
      "heading": "unavailable? To handle such a situation, we implement an anti-entropy protocol to keep",
      "level": 3,
      "page": 102
    },
    {
      "heading": "replicas in sync. Anti-entropy involves comparing each piece of data on replicas and updating",
      "level": 3,
      "page": 102
    },
    {
      "heading": "each replica to the newest version. A Merkle tree is used for inconsistency detection and",
      "level": 3,
      "page": 102
    },
    {
      "heading": "minimizing the amount of data transferred.",
      "level": 3,
      "page": 102
    },
    {
      "heading": "Quoted from Wikipedia [7]: “A hash tree or Merkle tree is a tree in which every non-leaf",
      "level": 3,
      "page": 102
    },
    {
      "heading": "node is labeled with the hash of the labels or values (in case of leaves) of its child nodes.",
      "level": 3,
      "page": 102
    },
    {
      "heading": "Hash trees allow efficient and secure verification of the contents of large data structures”.",
      "level": 3,
      "page": 102
    },
    {
      "heading": "Assuming key space is from 1 to 12, the following steps show how to build a Merkle tree.",
      "level": 3,
      "page": 102
    },
    {
      "heading": "Highlighted boxes indicate inconsistency.",
      "level": 3,
      "page": 102
    },
    {
      "heading": "Step 1: Divide key space into buckets (4 in our example) as shown in Figure 6-13.  A bucket",
      "level": 3,
      "page": 102
    },
    {
      "heading": "is used as the root level node to maintain a limited depth of the tree.",
      "level": 3,
      "page": 102
    },
    {
      "heading": "Step 2: Once the buckets are created, hash each key in a bucket using a uniform hashing",
      "level": 3,
      "page": 102
    },
    {
      "heading": "method (Figure 6-14).",
      "level": 3,
      "page": 102
    },
    {
      "heading": "Step 3: Create a single hash node per bucket (Figure 6-15).",
      "level": 3,
      "page": 102
    },
    {
      "heading": "Step 4: Build the tree upwards till root by calculating hashes of children (Figure 6-16).",
      "level": 3,
      "page": 102
    },
    {
      "heading": "To compare two Merkle trees, start by comparing the root hashes. If root hashes match, both",
      "level": 3,
      "page": 103
    },
    {
      "heading": "servers have the same data. If root hashes disagree, then the left child hashes are compared",
      "level": 3,
      "page": 103
    },
    {
      "heading": "followed by right child hashes. You can traverse the tree to find which buckets are not",
      "level": 3,
      "page": 103
    },
    {
      "heading": "synchronized and synchronize those buckets only.",
      "level": 3,
      "page": 103
    },
    {
      "heading": "Using Merkle trees, the amount of data needed to be synchronized is proportional to the",
      "level": 3,
      "page": 103
    },
    {
      "heading": "differences between the two replicas, and not the amount of data they contain. In real-world",
      "level": 3,
      "page": 103
    },
    {
      "heading": "systems, the bucket size is quite big. For instance, a possible configuration is one million",
      "level": 3,
      "page": 103
    },
    {
      "heading": "buckets per one billion keys, so each bucket only contains 1000 keys.",
      "level": 3,
      "page": 103
    },
    {
      "heading": "Handling data center outage",
      "level": 3,
      "page": 103
    },
    {
      "heading": "To build a system capable of handling data center outage, it is important to replicate data",
      "level": 3,
      "page": 103
    },
    {
      "heading": "across multiple data centers. Even if a data center is completely offline, users can still access",
      "level": 3,
      "page": 103
    },
    {
      "heading": "data through the other data centers.",
      "level": 3,
      "page": 103
    },
    {
      "heading": "System architecture diagram",
      "level": 3,
      "page": 104
    },
    {
      "heading": "Now that we have discussed different technical considerations in designing a key-value store,",
      "level": 3,
      "page": 104
    },
    {
      "heading": "we can shift our focus on the architecture diagram, shown in Figure 6-17.",
      "level": 3,
      "page": 104
    },
    {
      "heading": "Main features of the architecture are listed as follows:",
      "level": 3,
      "page": 104
    },
    {
      "heading": "• Clients communicate with the key-value store through simple APIs: get(key) and put(key,",
      "level": 3,
      "page": 104
    },
    {
      "heading": "value).",
      "level": 3,
      "page": 104
    },
    {
      "heading": "• A coordinator is a node that acts as a proxy between the client and the key-value store.",
      "level": 3,
      "page": 104
    },
    {
      "heading": "• Nodes are distributed on a ring using consistent hashing.",
      "level": 3,
      "page": 104
    },
    {
      "heading": "• The system is completely decentralized so adding and moving nodes can be automatic.",
      "level": 3,
      "page": 104
    },
    {
      "heading": "• Data is replicated at multiple nodes.",
      "level": 3,
      "page": 104
    },
    {
      "heading": "• There is no single point of failure as every node has the same set of responsibilities.",
      "level": 3,
      "page": 104
    },
    {
      "heading": "As the design is decentralized, each node performs many tasks as presented in Figure 6-18.",
      "level": 3,
      "page": 104
    },
    {
      "heading": "Write path",
      "level": 3,
      "page": 105
    },
    {
      "heading": "Figure 6-19 explains what happens after a write request is directed to a specific node. Please",
      "level": 3,
      "page": 105
    },
    {
      "heading": "note the proposed designs for write/read paths are primary based on the architecture of",
      "level": 3,
      "page": 105
    },
    {
      "heading": "Cassandra [8].",
      "level": 3,
      "page": 105
    },
    {
      "heading": "1. The write request is persisted on a commit log file.",
      "level": 3,
      "page": 105
    },
    {
      "heading": "2. Data is saved in the memory cache.",
      "level": 3,
      "page": 105
    },
    {
      "heading": "3. When the memory cache is full or reaches a predefined threshold, data is flushed to",
      "level": 3,
      "page": 106
    },
    {
      "heading": "SSTable [9] on disk. Note: A sorted-string table (SSTable) is a sorted list of <key, value>",
      "level": 3,
      "page": 106
    },
    {
      "heading": "pairs. For readers interested in learning more about SStable, refer to the reference material",
      "level": 3,
      "page": 106
    },
    {
      "heading": "[9].",
      "level": 3,
      "page": 106
    },
    {
      "heading": "Read path",
      "level": 3,
      "page": 106
    },
    {
      "heading": "After a read request is directed to a specific node, it first checks if data is in the memory",
      "level": 3,
      "page": 106
    },
    {
      "heading": "cache. If so, the data is returned to the client as shown in Figure 6-20.",
      "level": 3,
      "page": 106
    },
    {
      "heading": "If the data is not in memory, it will be retrieved from the disk instead. We need an efficient",
      "level": 3,
      "page": 106
    },
    {
      "heading": "way to find out which SSTable contains the key. Bloom filter [10] is commonly used to solve",
      "level": 3,
      "page": 106
    },
    {
      "heading": "this problem.",
      "level": 3,
      "page": 106
    },
    {
      "heading": "The read path is shown in Figure 6-21 when data is not in memory.",
      "level": 3,
      "page": 106
    },
    {
      "heading": "1. The system first checks if data is in memory. If not, go to step 2.",
      "level": 3,
      "page": 106
    },
    {
      "heading": "2. If data is not in memory, the system checks the bloom filter.",
      "level": 3,
      "page": 106
    },
    {
      "heading": "3. The bloom filter is used to figure out which SSTables might contain the key.",
      "level": 3,
      "page": 107
    },
    {
      "heading": "4. SSTables return the result of the data set.",
      "level": 3,
      "page": 107
    },
    {
      "heading": "5. The result of the data set is returned to the client.",
      "level": 3,
      "page": 107
    },
    {
      "heading": "Summary",
      "level": 3,
      "page": 108
    },
    {
      "heading": "This chapter covers many concepts and techniques. To refresh your memory, the following",
      "level": 3,
      "page": 108
    },
    {
      "heading": "table summarizes features and corresponding techniques used for a distributed key-value",
      "level": 3,
      "page": 108
    },
    {
      "heading": "store.",
      "level": 3,
      "page": 108
    },
    {
      "heading": "Reference materials",
      "level": 2,
      "page": 109
    },
    {
      "heading": "[1] Amazon DynamoDB: https://aws.amazon.com/dynamodb/",
      "level": 3,
      "page": 109
    },
    {
      "heading": "[2] memcached: https://memcached.org/",
      "level": 3,
      "page": 109
    },
    {
      "heading": "[3] Redis: https://redis.io/",
      "level": 3,
      "page": 109
    },
    {
      "heading": "[4] Dynamo: Amazon’s Highly Available Key-value Store:",
      "level": 3,
      "page": 109
    },
    {
      "heading": "https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf",
      "level": 3,
      "page": 109
    },
    {
      "heading": "[5] Cassandra: https://cassandra.apache.org/",
      "level": 3,
      "page": 109
    },
    {
      "heading": "[6] Bigtable: A Distributed Storage System for Structured Data:",
      "level": 3,
      "page": 109
    },
    {
      "heading": "https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-",
      "level": 3,
      "page": 109
    },
    {
      "heading": "osdi06.pdf",
      "level": 3,
      "page": 109
    },
    {
      "heading": "[7] Merkle tree: https://en.wikipedia.org/wiki/Merkle_tree",
      "level": 3,
      "page": 109
    },
    {
      "heading": "[8] Cassandra architecture: https://cassandra.apache.org/doc/latest/architecture/",
      "level": 3,
      "page": 109
    },
    {
      "heading": "[9] SStable: https://www.igvita.com/2012/02/06/sstable-and-log-structured-storage-leveldb/",
      "level": 3,
      "page": 109
    },
    {
      "heading": "[10] Bloom filter https://en.wikipedia.org/wiki/Bloom_filter",
      "level": 3,
      "page": 109
    },
    {
      "heading": "CHAPTER 7: DESIGN A UNIQUE ID GENERATOR IN",
      "level": 1,
      "page": 110
    },
    {
      "heading": "DISTRIBUTED SYSTEMS",
      "level": 1,
      "page": 110
    },
    {
      "heading": "In this chapter, you are asked to design a unique ID generator in distributed systems. Your",
      "level": 3,
      "page": 110
    },
    {
      "heading": "first thought might be to use a primary key with the auto_increment attribute in a traditional",
      "level": 3,
      "page": 110
    },
    {
      "heading": "database. However, auto_increment does not work in a distributed environment because a",
      "level": 3,
      "page": 110
    },
    {
      "heading": "single database server is not large enough and generating unique IDs across multiple",
      "level": 3,
      "page": 110
    },
    {
      "heading": "databases with minimal delay is challenging.",
      "level": 3,
      "page": 110
    },
    {
      "heading": "Here are a few examples of unique IDs:",
      "level": 3,
      "page": 110
    },
    {
      "heading": "Step 1 - Understand the problem and establish design scope",
      "level": 3,
      "page": 111
    },
    {
      "heading": "Asking clarification questions is the first step to tackle any system design interview question.",
      "level": 3,
      "page": 111
    },
    {
      "heading": "Here is an example of candidate-interviewer interaction:",
      "level": 3,
      "page": 111
    },
    {
      "heading": "Candidate: What are the characteristics of unique IDs?",
      "level": 3,
      "page": 111
    },
    {
      "heading": "Interviewer: IDs must be unique and sortable.",
      "level": 3,
      "page": 111
    },
    {
      "heading": "Candidate: For each new record, does ID increment by 1?",
      "level": 3,
      "page": 111
    },
    {
      "heading": "Interviewer: The ID increments by time but not necessarily only increments by 1. IDs",
      "level": 3,
      "page": 111
    },
    {
      "heading": "created in the evening are larger than those created in the morning on the same day.",
      "level": 3,
      "page": 111
    },
    {
      "heading": "Candidate: Do IDs only contain numerical values?",
      "level": 3,
      "page": 111
    },
    {
      "heading": "Interviewer: Yes, that is correct.",
      "level": 3,
      "page": 111
    },
    {
      "heading": "Candidate: What is the ID length requirement?",
      "level": 3,
      "page": 111
    },
    {
      "heading": "Interviewer: IDs should fit into 64-bit.",
      "level": 3,
      "page": 111
    },
    {
      "heading": "Candidate: What is the scale of the system?",
      "level": 3,
      "page": 111
    },
    {
      "heading": "Interviewer: The system should be able to generate 10,000 IDs per second.",
      "level": 3,
      "page": 111
    },
    {
      "heading": "Above are some of the sample questions that you can ask your interviewer. It is important to",
      "level": 3,
      "page": 111
    },
    {
      "heading": "understand the requirements and clarify ambiguities. For this interview question, the",
      "level": 3,
      "page": 111
    },
    {
      "heading": "requirements are listed as follows:",
      "level": 3,
      "page": 111
    },
    {
      "heading": "• IDs must be unique.",
      "level": 3,
      "page": 111
    },
    {
      "heading": "• IDs are numerical values only.",
      "level": 3,
      "page": 111
    },
    {
      "heading": "• IDs fit into 64-bit.",
      "level": 3,
      "page": 111
    },
    {
      "heading": "• IDs are ordered by date.",
      "level": 3,
      "page": 111
    },
    {
      "heading": "• Ability to generate over 10,000 unique IDs per second.",
      "level": 3,
      "page": 111
    },
    {
      "heading": "Step 2 - Propose high-level design and get buy-in",
      "level": 3,
      "page": 112
    },
    {
      "heading": "Multiple options can be used to generate unique IDs in distributed systems. The options we",
      "level": 3,
      "page": 112
    },
    {
      "heading": "considered are:",
      "level": 3,
      "page": 112
    },
    {
      "heading": "• Multi-master replication",
      "level": 3,
      "page": 112
    },
    {
      "heading": "• Universally unique identifier (UUID)",
      "level": 3,
      "page": 112
    },
    {
      "heading": "• Ticket server",
      "level": 3,
      "page": 112
    },
    {
      "heading": "• Twitter snowflake approach",
      "level": 3,
      "page": 112
    },
    {
      "heading": "Let us look at each of them, how they work, and the pros/cons of each option.",
      "level": 3,
      "page": 112
    },
    {
      "heading": "Multi-master replication",
      "level": 3,
      "page": 112
    },
    {
      "heading": "As shown in Figure 7-2, the first approach is multi-master replication.",
      "level": 3,
      "page": 112
    },
    {
      "heading": "This approach uses the databases’ auto_increment  feature. Instead of increasing the next ID",
      "level": 3,
      "page": 112
    },
    {
      "heading": "by 1, we increase it by k, where k is the number of database servers in use. As illustrated in",
      "level": 3,
      "page": 112
    },
    {
      "heading": "Figure 7-2, next ID to be generated is equal to the previous ID in the same server plus 2. This",
      "level": 3,
      "page": 112
    },
    {
      "heading": "solves some scalability issues because IDs can scale with the number of database servers.",
      "level": 3,
      "page": 112
    },
    {
      "heading": "However, this strategy has some major drawbacks:",
      "level": 3,
      "page": 112
    },
    {
      "heading": "• Hard to scale with multiple data centers",
      "level": 3,
      "page": 112
    },
    {
      "heading": "• IDs do not go up with time across multiple servers.",
      "level": 3,
      "page": 112
    },
    {
      "heading": "• It does not scale well when a server is added or removed.",
      "level": 3,
      "page": 112
    },
    {
      "heading": "UUID",
      "level": 3,
      "page": 112
    },
    {
      "heading": "A UUID is another easy way to obtain unique IDs. UUID is a 128-bit number used to identify",
      "level": 3,
      "page": 112
    },
    {
      "heading": "information in computer systems. UUID has a very low probability of getting collusion.",
      "level": 3,
      "page": 112
    },
    {
      "heading": "Quoted from Wikipedia, “after generating 1 billion UUIDs every second for approximately",
      "level": 3,
      "page": 112
    },
    {
      "heading": "100 years would the probability of creating a single duplicate reach 50%” [1].",
      "level": 3,
      "page": 112
    },
    {
      "heading": "Here is an example of UUID: 09c93e62-50b4-468d-bf8a-c07e1040bfb2. UUIDs can be",
      "level": 3,
      "page": 112
    },
    {
      "heading": "generated independently without coordination between servers. Figure 7-3 presents the",
      "level": 3,
      "page": 112
    },
    {
      "heading": "UUIDs design.",
      "level": 3,
      "page": 112
    },
    {
      "heading": "In this design, each web server contains an ID generator, and a web server is responsible for",
      "level": 3,
      "page": 113
    },
    {
      "heading": "generating IDs independently.",
      "level": 3,
      "page": 113
    },
    {
      "heading": "Pros:",
      "level": 3,
      "page": 113
    },
    {
      "heading": "• Generating UUID is simple. No coordination between servers is needed so there will not",
      "level": 3,
      "page": 113
    },
    {
      "heading": "be any synchronization issues.",
      "level": 3,
      "page": 113
    },
    {
      "heading": "• The system is easy to scale because each web server is responsible for generating IDs",
      "level": 3,
      "page": 113
    },
    {
      "heading": "they consume. ID generator can easily scale with web servers.",
      "level": 3,
      "page": 113
    },
    {
      "heading": "Cons:",
      "level": 3,
      "page": 113
    },
    {
      "heading": "• IDs are 128 bits long, but our requirement is 64 bits.",
      "level": 3,
      "page": 113
    },
    {
      "heading": "• IDs do not go up with time.",
      "level": 3,
      "page": 113
    },
    {
      "heading": "• IDs could be non-numeric.",
      "level": 3,
      "page": 113
    },
    {
      "heading": "Ticket Server",
      "level": 3,
      "page": 113
    },
    {
      "heading": "Ticket servers are another interesting way to generate unique IDs. Flicker developed ticket",
      "level": 3,
      "page": 113
    },
    {
      "heading": "servers to generate distributed primary keys [2]. It is worth mentioning how the system",
      "level": 3,
      "page": 113
    },
    {
      "heading": "works.",
      "level": 3,
      "page": 113
    },
    {
      "heading": "The idea is to use a centralized auto_increment feature in a single database server (Ticket",
      "level": 3,
      "page": 113
    },
    {
      "heading": "Server). To learn more about this, refer to flicker’s engineering blog article [2].",
      "level": 3,
      "page": 113
    },
    {
      "heading": "Pros:",
      "level": 3,
      "page": 113
    },
    {
      "heading": "• Numeric IDs.",
      "level": 3,
      "page": 113
    },
    {
      "heading": "• It is easy to implement, and it works for small to medium-scale applications.",
      "level": 3,
      "page": 113
    },
    {
      "heading": "Cons:",
      "level": 3,
      "page": 113
    },
    {
      "heading": "• Single point of failure. Single ticket server means if the ticket server goes down, all",
      "level": 3,
      "page": 114
    },
    {
      "heading": "systems that depend on it will face issues. To avoid a single point of failure, we can set up",
      "level": 3,
      "page": 114
    },
    {
      "heading": "multiple ticket servers. However, this will introduce new challenges such as data",
      "level": 3,
      "page": 114
    },
    {
      "heading": "synchronization.",
      "level": 3,
      "page": 114
    },
    {
      "heading": "Twitter snowflake approach",
      "level": 3,
      "page": 114
    },
    {
      "heading": "Approaches mentioned above give us some ideas about how different ID generation systems",
      "level": 3,
      "page": 114
    },
    {
      "heading": "work. However, none of them meet our specific requirements; thus, we need another",
      "level": 3,
      "page": 114
    },
    {
      "heading": "approach. Twitter’s unique ID generation system called “snowflake” [3] is inspiring and can",
      "level": 3,
      "page": 114
    },
    {
      "heading": "satisfy our requirements.",
      "level": 3,
      "page": 114
    },
    {
      "heading": "Divide and conquer is our friend. Instead of generating an ID directly, we divide an ID into",
      "level": 3,
      "page": 114
    },
    {
      "heading": "different sections. Figure 7-5 shows the layout of a 64-bit ID.",
      "level": 3,
      "page": 114
    },
    {
      "heading": "Each section is explained below.",
      "level": 3,
      "page": 114
    },
    {
      "heading": "• Sign bit: 1 bit. It will always be 0. This is reserved for future uses. It can potentially be",
      "level": 3,
      "page": 114
    },
    {
      "heading": "used to distinguish between signed and unsigned numbers.",
      "level": 3,
      "page": 114
    },
    {
      "heading": "• Timestamp: 41 bits. Milliseconds since the epoch or custom epoch. We use Twitter",
      "level": 3,
      "page": 114
    },
    {
      "heading": "snowflake default epoch 1288834974657, equivalent to Nov 04, 2010, 01:42:54 UTC.",
      "level": 3,
      "page": 114
    },
    {
      "heading": "• Datacenter ID: 5 bits, which gives us 2 ^ 5 = 32 datacenters.",
      "level": 3,
      "page": 114
    },
    {
      "heading": "• Machine ID: 5 bits, which gives us 2 ^ 5 = 32 machines per datacenter.",
      "level": 3,
      "page": 114
    },
    {
      "heading": "• Sequence number: 12 bits. For every ID generated on that machine/process, the sequence",
      "level": 3,
      "page": 114
    },
    {
      "heading": "number is incremented by 1. The number is reset to 0 every millisecond.",
      "level": 3,
      "page": 114
    },
    {
      "heading": "Step 3 - Design deep dive",
      "level": 3,
      "page": 115
    },
    {
      "heading": "In the high-level design, we discussed various options to design a unique ID generator in",
      "level": 3,
      "page": 115
    },
    {
      "heading": "distributed systems. We settle on an approach that is based on the Twitter snowflake ID",
      "level": 3,
      "page": 115
    },
    {
      "heading": "generator. Let us dive deep into the design. To refresh our memory, the design diagram is",
      "level": 3,
      "page": 115
    },
    {
      "heading": "relisted below.",
      "level": 3,
      "page": 115
    },
    {
      "heading": "Datacenter IDs and machine IDs are chosen at the startup time, generally fixed once the",
      "level": 3,
      "page": 115
    },
    {
      "heading": "system is up running. Any changes in datacenter IDs and machine IDs require careful review",
      "level": 3,
      "page": 115
    },
    {
      "heading": "since an accidental change in those values can lead to ID conflicts. Timestamp and sequence",
      "level": 3,
      "page": 115
    },
    {
      "heading": "numbers are generated when the ID generator is running.",
      "level": 3,
      "page": 115
    },
    {
      "heading": "Timestamp",
      "level": 3,
      "page": 115
    },
    {
      "heading": "The most important 41 bits make up the timestamp section. As timestamps grow with time,",
      "level": 3,
      "page": 115
    },
    {
      "heading": "IDs are sortable by time. Figure 7-7 shows an example of how binary representation is",
      "level": 3,
      "page": 115
    },
    {
      "heading": "converted to UTC. You can also convert UTC back to binary representation using a similar",
      "level": 3,
      "page": 115
    },
    {
      "heading": "method.",
      "level": 3,
      "page": 115
    },
    {
      "heading": "The maximum timestamp that can be represented in 41 bits is",
      "level": 3,
      "page": 116
    },
    {
      "heading": "2 ^ 41 - 1 = 2199023255551 milliseconds (ms), which gives us: ~ 69 years =",
      "level": 3,
      "page": 116
    },
    {
      "heading": "2199023255551 ms / 1000 seconds / 365 days / 24 hours/ 3600 seconds. This means the ID",
      "level": 3,
      "page": 116
    },
    {
      "heading": "the overflow time. After 69 years, we will need a new epoch time or adopt other techniques",
      "level": 3,
      "page": 116
    },
    {
      "heading": "to migrate IDs.",
      "level": 3,
      "page": 116
    },
    {
      "heading": "Sequence number",
      "level": 3,
      "page": 116
    },
    {
      "heading": "Sequence number is 12 bits, which give us 2 ^ 12 = 4096 combinations. This field is 0 unless",
      "level": 3,
      "page": 116
    },
    {
      "heading": "more than one ID is generated in a millisecond on the same server. In theory, a machine can",
      "level": 3,
      "page": 116
    },
    {
      "heading": "support a maximum of 4096 new IDs per millisecond.",
      "level": 3,
      "page": 116
    },
    {
      "heading": "Step 4 - Wrap up",
      "level": 3,
      "page": 117
    },
    {
      "heading": "In this chapter, we discussed different approaches to design a unique ID generator: multi-",
      "level": 3,
      "page": 117
    },
    {
      "heading": "master replication, UUID, ticket server, and Twitter snowflake-like unique ID generator. We",
      "level": 3,
      "page": 117
    },
    {
      "heading": "settle on snowflake as it supports all our use cases and is scalable in a distributed",
      "level": 3,
      "page": 117
    },
    {
      "heading": "environment.",
      "level": 3,
      "page": 117
    },
    {
      "heading": "If there is extra time at the end of the interview, here are a few additional talking points:",
      "level": 3,
      "page": 117
    },
    {
      "heading": "• Clock synchronization. In our design, we assume ID generation servers have the same",
      "level": 3,
      "page": 117
    },
    {
      "heading": "clock. This assumption might not be true when a server is running on multiple cores. The",
      "level": 3,
      "page": 117
    },
    {
      "heading": "same challenge exists in multi-machine scenarios. Solutions to clock synchronization are",
      "level": 3,
      "page": 117
    },
    {
      "heading": "out of the scope of this book; however, it is important to understand the problem exists.",
      "level": 3,
      "page": 117
    },
    {
      "heading": "Network Time Protocol is the most popular solution to this problem. For interested",
      "level": 3,
      "page": 117
    },
    {
      "heading": "readers, refer to the reference material [4].",
      "level": 3,
      "page": 117
    },
    {
      "heading": "are effective for low concurrency and long-term applications.",
      "level": 3,
      "page": 117
    },
    {
      "heading": "• High availability. Since an ID generator is a mission-critical system, it must be highly",
      "level": 3,
      "page": 117
    },
    {
      "heading": "available.",
      "level": 3,
      "page": 117
    },
    {
      "heading": "Congratulations on getting this far! Now give yourself a pat on the back. Good job!",
      "level": 3,
      "page": 117
    },
    {
      "heading": "Reference materials",
      "level": 2,
      "page": 118
    },
    {
      "heading": "[1] Universally unique identifier: https://en.wikipedia.org/wiki/Universally_unique_identifier",
      "level": 3,
      "page": 118
    },
    {
      "heading": "[2] Ticket Servers: Distributed Unique Primary Keys on the Cheap:",
      "level": 3,
      "page": 118
    },
    {
      "heading": "https://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-",
      "level": 3,
      "page": 118
    },
    {
      "heading": "cheap/",
      "level": 3,
      "page": 118
    },
    {
      "heading": "[3] Announcing Snowflake: https://blog.twitter.com/engineering/en_us/a/2010/announcing-",
      "level": 3,
      "page": 118
    },
    {
      "heading": "snowflake.html",
      "level": 3,
      "page": 118
    },
    {
      "heading": "[4] Network time protocol: https://en.wikipedia.org/wiki/Network_Time_Protocol",
      "level": 3,
      "page": 118
    },
    {
      "heading": "CHAPTER 8: DESIGN A URL SHORTENER",
      "level": 1,
      "page": 119
    },
    {
      "heading": "In this chapter, we will tackle an interesting and classic system design interview question:",
      "level": 3,
      "page": 119
    },
    {
      "heading": "designing a URL shortening service like tinyurl.",
      "level": 3,
      "page": 119
    },
    {
      "heading": "Step 1 - Understand the problem and establish design scope",
      "level": 3,
      "page": 120
    },
    {
      "heading": "System design interview questions are intentionally left open-ended. To design a well-crafted",
      "level": 3,
      "page": 120
    },
    {
      "heading": "system, it is critical to ask clarification questions.",
      "level": 3,
      "page": 120
    },
    {
      "heading": "Candidate: Can you give an example of how a URL shortener work?",
      "level": 3,
      "page": 120
    },
    {
      "heading": "Interviewer: Assume URL",
      "level": 3,
      "page": 120
    },
    {
      "heading": "https://www.systeminterview.com/q=chatsystem&c=loggedin&v=v3&l=long is the original",
      "level": 3,
      "page": 120
    },
    {
      "heading": "URL. Your service creates an alias with shorter length: https://tinyurl.com/ y7keocwj. If you",
      "level": 3,
      "page": 120
    },
    {
      "heading": "click the alias, it redirects you to the original URL.",
      "level": 3,
      "page": 120
    },
    {
      "heading": "Candidate: What is the traffic volume?",
      "level": 3,
      "page": 120
    },
    {
      "heading": "Interviewer: 100 million URLs are generated per day.",
      "level": 3,
      "page": 120
    },
    {
      "heading": "Candidate: How long is the shortened URL?",
      "level": 3,
      "page": 120
    },
    {
      "heading": "Interviewer: As short as possible.",
      "level": 3,
      "page": 120
    },
    {
      "heading": "Candidate: What characters are allowed in the shortened URL?",
      "level": 3,
      "page": 120
    },
    {
      "heading": "Interviewer: Shortened URL can be a combination of numbers (0-9) and characters (a-z, A-",
      "level": 3,
      "page": 120
    },
    {
      "heading": "Z).",
      "level": 3,
      "page": 120
    },
    {
      "heading": "Candidate: Can shortened URLs be deleted or updated?",
      "level": 3,
      "page": 120
    },
    {
      "heading": "Interviewer: For simplicity, let us assume shortened URLs cannot be deleted or updated.",
      "level": 3,
      "page": 120
    },
    {
      "heading": "Here are the basic use cases:",
      "level": 3,
      "page": 120
    },
    {
      "heading": "1.URL shortening: given a long URL => return a much shorter URL",
      "level": 3,
      "page": 120
    },
    {
      "heading": "2.URL redirecting: given a shorter URL => redirect to the original URL",
      "level": 3,
      "page": 120
    },
    {
      "heading": "3.High availability, scalability, and fault tolerance considerations",
      "level": 3,
      "page": 120
    },
    {
      "heading": "Back of the envelope estimation",
      "level": 3,
      "page": 120
    },
    {
      "heading": "• Write operation: 100 million URLs are generated per day.",
      "level": 3,
      "page": 120
    },
    {
      "heading": "• Write operation per second: 100 million / 24 /3600 = 1160",
      "level": 3,
      "page": 120
    },
    {
      "heading": "• Read operation: Assuming ratio of read operation to write operation is 10:1, read",
      "level": 3,
      "page": 120
    },
    {
      "heading": "operation per second: 1160 * 10 = 11,600",
      "level": 3,
      "page": 120
    },
    {
      "heading": "• Assuming the URL shortener service will run for 10 years, this means we must support",
      "level": 3,
      "page": 120
    },
    {
      "heading": "100 million * 365 * 10 = 365 billion records.",
      "level": 3,
      "page": 120
    },
    {
      "heading": "• Assume average URL length is 100.",
      "level": 3,
      "page": 120
    },
    {
      "heading": "• Storage requirement over 10 years: 365 billion * 100 bytes * 10 years = 365 TB",
      "level": 3,
      "page": 120
    },
    {
      "heading": "It is important for you to walk through the assumptions and calculations with your",
      "level": 3,
      "page": 120
    },
    {
      "heading": "interviewer so that both of you are on the same page.",
      "level": 3,
      "page": 120
    },
    {
      "heading": "Step 2 - Propose high-level design and get buy-in",
      "level": 3,
      "page": 121
    },
    {
      "heading": "API Endpoints",
      "level": 3,
      "page": 121
    },
    {
      "heading": "API endpoints facilitate the communication between clients and servers. We will design the",
      "level": 3,
      "page": 121
    },
    {
      "heading": "APIs REST-style. If you are unfamiliar with restful API, you can consult external materials,",
      "level": 3,
      "page": 121
    },
    {
      "heading": "such as the one in the reference material [1]. A URL shortener primary needs two API",
      "level": 3,
      "page": 121
    },
    {
      "heading": "endpoints.",
      "level": 3,
      "page": 121
    },
    {
      "heading": "1.URL shortening. To create a new short URL, a client sends a POST request, which contains",
      "level": 3,
      "page": 121
    },
    {
      "heading": "one parameter: the original long URL. The API looks like this:",
      "level": 3,
      "page": 121
    },
    {
      "heading": "POST api/v1/data/shorten",
      "level": 3,
      "page": 121
    },
    {
      "heading": "• request parameter: {longUrl: longURLString}",
      "level": 3,
      "page": 121
    },
    {
      "heading": "• return shortURL",
      "level": 3,
      "page": 121
    },
    {
      "heading": "2.URL redirecting. To redirect a short URL to the corresponding long URL, a client sends a",
      "level": 3,
      "page": 121
    },
    {
      "heading": "GET request. The API looks like this:",
      "level": 3,
      "page": 121
    },
    {
      "heading": "GET api/v1/shortUrl",
      "level": 3,
      "page": 121
    },
    {
      "heading": "• Return longURL for HTTP redirection",
      "level": 3,
      "page": 121
    },
    {
      "heading": "URL redirecting",
      "level": 3,
      "page": 121
    },
    {
      "heading": "Figure 8-1 shows what happens when you enter a tinyurl onto the browser. Once the server",
      "level": 3,
      "page": 121
    },
    {
      "heading": "receives a tinyurl request, it changes the short URL to the long URL with 301 redirect.",
      "level": 3,
      "page": 121
    },
    {
      "heading": "The detailed communication between clients and servers is shown in Figure 8-2.",
      "level": 3,
      "page": 121
    },
    {
      "heading": "One thing worth discussing here is 301 redirect vs 302 redirect.",
      "level": 3,
      "page": 122
    },
    {
      "heading": "301 redirect. A 301 redirect shows that the requested URL is “permanently” moved to the",
      "level": 3,
      "page": 122
    },
    {
      "heading": "long URL. Since it is permanently redirected, the browser caches the response, and",
      "level": 3,
      "page": 122
    },
    {
      "heading": "subsequent requests for the same URL will not be sent to the URL shortening service.",
      "level": 3,
      "page": 122
    },
    {
      "heading": "Instead, requests are redirected to the long URL server directly.",
      "level": 3,
      "page": 122
    },
    {
      "heading": "302 redirect. A 302 redirect means that the URL is “temporarily” moved to the long URL,",
      "level": 3,
      "page": 122
    },
    {
      "heading": "meaning that subsequent requests for the same URL will be sent to the URL shortening",
      "level": 3,
      "page": 122
    },
    {
      "heading": "service first. Then, they are redirected to the long URL server.",
      "level": 3,
      "page": 122
    },
    {
      "heading": "Each redirection method has its pros and cons. If the priority is to reduce the server load,",
      "level": 3,
      "page": 122
    },
    {
      "heading": "using 301 redirect makes sense as only the first request of the same URL is sent to URL",
      "level": 3,
      "page": 122
    },
    {
      "heading": "shortening servers. However, if analytics is important, 302 redirect is a better choice as it can",
      "level": 3,
      "page": 122
    },
    {
      "heading": "track click rate and source of the click more easily.",
      "level": 3,
      "page": 122
    },
    {
      "heading": "The most intuitive way to implement URL redirecting is to use hash tables. Assuming the",
      "level": 3,
      "page": 122
    },
    {
      "heading": "hash table stores <shortURL, longURL> pairs, URL redirecting can be implemented by the",
      "level": 3,
      "page": 122
    },
    {
      "heading": "following:",
      "level": 3,
      "page": 122
    },
    {
      "heading": "• Get longURL: longURL = hashTable.get(shortURL)",
      "level": 3,
      "page": 122
    },
    {
      "heading": "• Once you get the longURL, perform the URL redirect.",
      "level": 3,
      "page": 122
    },
    {
      "heading": "URL shortening",
      "level": 3,
      "page": 122
    },
    {
      "heading": "Let us assume the short URL looks like this: www.tinyurl.com/{hashValue}. To support the",
      "level": 3,
      "page": 122
    },
    {
      "heading": "URL shortening use case, we must find a hash function  fx  that maps a long URL to the",
      "level": 3,
      "page": 122
    },
    {
      "heading": "hashValue, as shown in Figure 8-3.",
      "level": 3,
      "page": 122
    },
    {
      "heading": "The hash function must satisfy the following requirements:",
      "level": 3,
      "page": 123
    },
    {
      "heading": "• Each longURL must be hashed to one hashValue.",
      "level": 3,
      "page": 123
    },
    {
      "heading": "• Each hashValue can be mapped back to the longURL.",
      "level": 3,
      "page": 123
    },
    {
      "heading": "Detailed design for the hash function is discussed in deep dive.",
      "level": 3,
      "page": 123
    },
    {
      "heading": "Step 3 - Design deep dive",
      "level": 3,
      "page": 124
    },
    {
      "heading": "Up until now, we have discussed the high-level design of URL shortening and URL",
      "level": 3,
      "page": 124
    },
    {
      "heading": "redirecting. In this section, we dive deep into the following: data model, hash function, URL",
      "level": 3,
      "page": 124
    },
    {
      "heading": "shortening and URL redirecting.",
      "level": 3,
      "page": 124
    },
    {
      "heading": "Data model",
      "level": 3,
      "page": 124
    },
    {
      "heading": "In the high-level design, everything is stored in a hash table. This is a good starting point;",
      "level": 3,
      "page": 124
    },
    {
      "heading": "however, this approach is not feasible for real-world systems as memory resources are limited",
      "level": 3,
      "page": 124
    },
    {
      "heading": "and expensive. A better option is to store <shortURL, longURL> mapping in a relational",
      "level": 3,
      "page": 124
    },
    {
      "heading": "database. Figure 8-4 shows a simple database table design. The simplified version of the table",
      "level": 3,
      "page": 124
    },
    {
      "heading": "contains 3 columns: id, shortURL, longURL.",
      "level": 3,
      "page": 124
    },
    {
      "heading": "Hash function",
      "level": 3,
      "page": 124
    },
    {
      "heading": "Hash function is used to hash a long URL to a short URL, also known as hashValue.",
      "level": 3,
      "page": 124
    },
    {
      "heading": "Hash value length",
      "level": 3,
      "page": 124
    },
    {
      "heading": "The hashValue consists of characters from [0-9, a-z, A-Z], containing 10 + 26 + 26 = 62",
      "level": 3,
      "page": 124
    },
    {
      "heading": "possible characters. To figure out the length of hashValue, find the smallest n such that 62^n",
      "level": 3,
      "page": 124
    },
    {
      "heading": "≥ 365 billion. The system must support up to 365 billion URLs based on the back of the",
      "level": 3,
      "page": 124
    },
    {
      "heading": "envelope estimation. Table 8-1 shows the length of hashValue and the corresponding",
      "level": 3,
      "page": 124
    },
    {
      "heading": "maximal number of URLs it can support.",
      "level": 3,
      "page": 124
    },
    {
      "heading": "When n = 7, 62 ^ n = ~3.5 trillion, 3.5 trillion is more than enough to hold 365 billion URLs,",
      "level": 3,
      "page": 125
    },
    {
      "heading": "so the length of hashValue is 7.",
      "level": 3,
      "page": 125
    },
    {
      "heading": "We will explore two types of hash functions for a URL shortener. The first one is “hash +",
      "level": 3,
      "page": 125
    },
    {
      "heading": "collision resolution”, and the second one is “base 62 conversion.” Let us look at them one by",
      "level": 3,
      "page": 125
    },
    {
      "heading": "one.",
      "level": 3,
      "page": 125
    },
    {
      "heading": "Hash + collision resolution",
      "level": 3,
      "page": 125
    },
    {
      "heading": "To shorten a long URL, we should implement a hash function that hashes a long URL to a 7-",
      "level": 3,
      "page": 125
    },
    {
      "heading": "character string. A straightforward solution is to use well-known hash functions like CRC32,",
      "level": 3,
      "page": 125
    },
    {
      "heading": "MD5, or SHA-1. The following table compares the hash results after applying different hash",
      "level": 3,
      "page": 125
    },
    {
      "heading": "functions on this URL: https://en.wikipedia.org/wiki/Systems_design.",
      "level": 3,
      "page": 125
    },
    {
      "heading": "As shown in Table 8-2, even the shortest hash value (from CRC32) is too long (more than 7",
      "level": 3,
      "page": 125
    },
    {
      "heading": "characters). How can we make it shorter?",
      "level": 3,
      "page": 125
    },
    {
      "heading": "The first approach is to collect the first 7 characters of a hash value; however, this method",
      "level": 3,
      "page": 125
    },
    {
      "heading": "can lead to hash collisions. To resolve hash collisions, we can recursively append a new",
      "level": 3,
      "page": 125
    },
    {
      "heading": "predefined string until no more collision is discovered. This process is explained in Figure 8-",
      "level": 3,
      "page": 125
    },
    {
      "heading": "This method can eliminate collision; however, it is expensive to query the database to check",
      "level": 3,
      "page": 126
    },
    {
      "heading": "if a shortURL exists for every request. A technique called bloom filters [2] can improve",
      "level": 3,
      "page": 126
    },
    {
      "heading": "performance. A bloom filter is a space-efficient probabilistic technique to test if an element is",
      "level": 3,
      "page": 126
    },
    {
      "heading": "a member of a set. Refer to the reference material [2] for more details.",
      "level": 3,
      "page": 126
    },
    {
      "heading": "Base 62 conversion",
      "level": 3,
      "page": 126
    },
    {
      "heading": "Base conversion is another approach commonly used for URL shorteners. Base conversion",
      "level": 3,
      "page": 126
    },
    {
      "heading": "helps to convert the same number between its different number representation systems. Base",
      "level": 3,
      "page": 126
    },
    {
      "heading": "62 conversion is used as there are 62 possible characters for hashValue. Let us use an",
      "level": 3,
      "page": 126
    },
    {
      "heading": "example to explain how the conversion works: convert 1115710 to base 62 representation",
      "level": 3,
      "page": 126
    },
    {
      "heading": "(1115710 represents 11157 in a base 10 system).",
      "level": 3,
      "page": 126
    },
    {
      "heading": "• From its name, base 62 is a way of using 62 characters for encoding. The mappings are:",
      "level": 3,
      "page": 126
    },
    {
      "heading": "0-0, ..., 9-9, 10-a, 11-b, ..., 35-z, 36-A, ..., 61-Z, where ‘a’ stands for 10, ‘Z’ stands for 61,",
      "level": 3,
      "page": 126
    },
    {
      "heading": "etc.",
      "level": 3,
      "page": 126
    },
    {
      "heading": "• 1115710 = 2 x 622 + 55 x 621 + 59 x 620 = [2, 55, 59] -> [2, T, X] in base 62",
      "level": 3,
      "page": 126
    },
    {
      "heading": "representation. Figure 8-6 shows the conversation process.",
      "level": 3,
      "page": 126
    },
    {
      "heading": "• Thus, the short URL is https://tinyurl.com /2TX",
      "level": 3,
      "page": 127
    },
    {
      "heading": "Comparison of the two approaches",
      "level": 3,
      "page": 127
    },
    {
      "heading": "Table 8-3 shows the differences of the two approaches.",
      "level": 3,
      "page": 127
    },
    {
      "heading": "URL shortening deep dive",
      "level": 3,
      "page": 127
    },
    {
      "heading": "As one of the core pieces of the system, we want the URL shortening flow to be logically",
      "level": 3,
      "page": 127
    },
    {
      "heading": "simple and functional. Base 62 conversion is used in our design. We build the following",
      "level": 3,
      "page": 127
    },
    {
      "heading": "diagram (Figure 8-7) to demonstrate the flow.",
      "level": 3,
      "page": 127
    },
    {
      "heading": "1. longURL is the input.",
      "level": 3,
      "page": 128
    },
    {
      "heading": "2. The system checks if the longURL is in the database.",
      "level": 3,
      "page": 128
    },
    {
      "heading": "3. If it is, it means the longURL was converted to shortURL before. In this case, fetch the",
      "level": 3,
      "page": 128
    },
    {
      "heading": "shortURL from the database and return it to the client.",
      "level": 3,
      "page": 128
    },
    {
      "heading": "4. If not, the longURL is new. A new unique ID (primary key) Is generated by the unique",
      "level": 3,
      "page": 128
    },
    {
      "heading": "ID generator.",
      "level": 3,
      "page": 128
    },
    {
      "heading": "5. Convert the ID to shortURL with base 62 conversion.",
      "level": 3,
      "page": 128
    },
    {
      "heading": "6. Create a new database row with the ID, shortURL, and longURL.",
      "level": 3,
      "page": 128
    },
    {
      "heading": "To make the flow easier to understand, let us look at a concrete example.",
      "level": 3,
      "page": 128
    },
    {
      "heading": "• Assuming the input longURL is: https://en.wikipedia.org/wiki/Systems_design",
      "level": 3,
      "page": 128
    },
    {
      "heading": "• Unique ID generator returns ID: 2009215674938.",
      "level": 3,
      "page": 128
    },
    {
      "heading": "• Convert the ID to shortURL using the base 62 conversion. ID (2009215674938) is",
      "level": 3,
      "page": 128
    },
    {
      "heading": "converted to “zn9edcu”.",
      "level": 3,
      "page": 128
    },
    {
      "heading": "• Save ID, shortURL, and longURL to the database as shown in Table 8-4.",
      "level": 3,
      "page": 128
    },
    {
      "heading": "The distributed unique ID generator is worth mentioning. Its primary function is to generate",
      "level": 3,
      "page": 128
    },
    {
      "heading": "globally unique IDs, which are used for creating shortURLs. In a highly distributed",
      "level": 3,
      "page": 128
    },
    {
      "heading": "environment, implementing a unique ID generator is challenging. Luckily, we have already",
      "level": 3,
      "page": 129
    },
    {
      "heading": "discussed a few solutions in “Chapter 7: Design A Unique ID Generator in Distributed",
      "level": 3,
      "page": 129
    },
    {
      "heading": "Systems”. You can refer back to it to refresh your memory.",
      "level": 3,
      "page": 129
    },
    {
      "heading": "URL redirecting deep dive",
      "level": 3,
      "page": 129
    },
    {
      "heading": "Figure 8-8 shows the detailed design of the URL redirecting. As there are more reads than",
      "level": 3,
      "page": 129
    },
    {
      "heading": "writes, <shortURL, longURL> mapping is stored in a cache to improve performance.",
      "level": 3,
      "page": 129
    },
    {
      "heading": "The flow of URL redirecting is summarized as follows:",
      "level": 3,
      "page": 129
    },
    {
      "heading": "1. A user clicks a short URL link: https://tinyurl.com/zn9edcu",
      "level": 3,
      "page": 129
    },
    {
      "heading": "2. The load balancer forwards the request to web servers.",
      "level": 3,
      "page": 129
    },
    {
      "heading": "3. If a shortURL is already in the cache, return the longURL directly.",
      "level": 3,
      "page": 129
    },
    {
      "heading": "4. If a shortURL is not in the cache, fetch the longURL from the database. If it is not in the",
      "level": 3,
      "page": 129
    },
    {
      "heading": "database, it is likely a user entered an invalid shortURL.",
      "level": 3,
      "page": 129
    },
    {
      "heading": "5. The longURL is returned to the user.",
      "level": 3,
      "page": 129
    },
    {
      "heading": "Step 4 - Wrap up",
      "level": 3,
      "page": 130
    },
    {
      "heading": "and URL redirecting.",
      "level": 3,
      "page": 130
    },
    {
      "heading": "If there is extra time at the end of the interview, here are a few additional talking points.",
      "level": 3,
      "page": 130
    },
    {
      "heading": "• Rate limiter: A potential security problem we could face is that malicious users send an",
      "level": 3,
      "page": 130
    },
    {
      "heading": "overwhelmingly large number of URL shortening requests. Rate limiter helps to filter out",
      "level": 3,
      "page": 130
    },
    {
      "heading": "requests based on IP address or other filtering rules. If you want to refresh your memory",
      "level": 3,
      "page": 130
    },
    {
      "heading": "about rate limiting, refer to “Chapter 4: Design a rate limiter”.",
      "level": 3,
      "page": 130
    },
    {
      "heading": "• Web server scaling: Since the web tier is stateless, it is easy to scale the web tier by",
      "level": 3,
      "page": 130
    },
    {
      "heading": "adding or removing web servers.",
      "level": 3,
      "page": 130
    },
    {
      "heading": "• Database scaling: Database replication and sharding are common techniques.",
      "level": 3,
      "page": 130
    },
    {
      "heading": "• Analytics: Data is increasingly important for business success. Integrating an analytics",
      "level": 3,
      "page": 130
    },
    {
      "heading": "solution to the URL shortener could help to answer important questions like how many",
      "level": 3,
      "page": 130
    },
    {
      "heading": "people click on a link? When do they click the link? etc.",
      "level": 3,
      "page": 130
    },
    {
      "heading": "• Availability, consistency, and reliability. These concepts are at the core of any large",
      "level": 3,
      "page": 130
    },
    {
      "heading": "system’s success. We discussed them in detail in Chapter 1, please refresh your memory",
      "level": 3,
      "page": 130
    },
    {
      "heading": "on these topics.",
      "level": 3,
      "page": 130
    },
    {
      "heading": "Congratulations on getting this far! Now give yourself a pat on the back. Good job!",
      "level": 3,
      "page": 130
    },
    {
      "heading": "Reference materials",
      "level": 2,
      "page": 131
    },
    {
      "heading": "[1] A RESTful Tutorial: https://www.restapitutorial.com/index.html",
      "level": 3,
      "page": 131
    },
    {
      "heading": "[2] Bloom filter: https://en.wikipedia.org/wiki/Bloom_filter",
      "level": 3,
      "page": 131
    },
    {
      "heading": "CHAPTER 9: DESIGN A WEB CRAWLER",
      "level": 1,
      "page": 132
    },
    {
      "heading": "In this chapter, we focus on web crawler design: an interesting and classic system design",
      "level": 3,
      "page": 132
    },
    {
      "heading": "interview question.",
      "level": 3,
      "page": 132
    },
    {
      "heading": "A web crawler is known as a robot or spider. It is widely used by search engines to discover",
      "level": 3,
      "page": 132
    },
    {
      "heading": "file, etc. A web crawler starts by collecting a few web pages and then follows links on those",
      "level": 3,
      "page": 132
    },
    {
      "heading": "pages to collect new content. Figure 9-1 shows a visual example of the crawl process.",
      "level": 3,
      "page": 132
    },
    {
      "heading": "A crawler is used for many purposes:",
      "level": 3,
      "page": 132
    },
    {
      "heading": "pages to create a local index for search engines. For example, Googlebot is the web",
      "level": 3,
      "page": 132
    },
    {
      "heading": "crawler behind the Google search engine.",
      "level": 3,
      "page": 132
    },
    {
      "heading": "• Web archiving: This is the process of collecting information from the web to preserve",
      "level": 3,
      "page": 132
    },
    {
      "heading": "data for future uses. For instance, many national libraries run crawlers to archive web",
      "level": 3,
      "page": 132
    },
    {
      "heading": "sites. Notable examples are the US Library of Congress [1] and the EU web archive [2].",
      "level": 3,
      "page": 132
    },
    {
      "heading": "• Web mining: The explosive growth of the web presents an unprecedented opportunity for",
      "level": 3,
      "page": 132
    },
    {
      "heading": "data mining. Web mining helps to discover useful knowledge from the internet. For",
      "level": 3,
      "page": 133
    },
    {
      "heading": "example, top financial firms use crawlers to download shareholder meetings and annual",
      "level": 3,
      "page": 133
    },
    {
      "heading": "reports to learn key company initiatives.",
      "level": 3,
      "page": 133
    },
    {
      "heading": "• Web monitoring. The crawlers help to monitor copyright and trademark infringements",
      "level": 3,
      "page": 133
    },
    {
      "heading": "over the Internet. For example, Digimarc [3] utilizes crawlers to discover pirated works",
      "level": 3,
      "page": 133
    },
    {
      "heading": "and reports.",
      "level": 3,
      "page": 133
    },
    {
      "heading": "The complexity of developing a web crawler depends on the scale we intend to support. It",
      "level": 3,
      "page": 133
    },
    {
      "heading": "could be either a small school project, which takes only a few hours to complete or a gigantic",
      "level": 3,
      "page": 133
    },
    {
      "heading": "project that requires continuous improvement from a dedicated engineering team. Thus, we",
      "level": 3,
      "page": 133
    },
    {
      "heading": "will explore the scale and features to support below.",
      "level": 3,
      "page": 133
    },
    {
      "heading": "Step 1 - Understand the problem and establish design scope",
      "level": 3,
      "page": 134
    },
    {
      "heading": "The basic algorithm of a web crawler is simple:",
      "level": 3,
      "page": 134
    },
    {
      "heading": "1. Given a set of URLs, download all the web pages addressed by the URLs.",
      "level": 3,
      "page": 134
    },
    {
      "heading": "2. Extract URLs from these web pages",
      "level": 3,
      "page": 134
    },
    {
      "heading": "3. Add new URLs to the list of URLs to be downloaded. Repeat these 3 steps.",
      "level": 3,
      "page": 134
    },
    {
      "heading": "Does a web crawler work truly as simple as this basic algorithm? Not exactly. Designing a",
      "level": 3,
      "page": 134
    },
    {
      "heading": "vastly scalable web crawler is an extremely complex task. It is unlikely for anyone to design",
      "level": 3,
      "page": 134
    },
    {
      "heading": "a massive web crawler within the interview duration. Before jumping into the design, we",
      "level": 3,
      "page": 134
    },
    {
      "heading": "must ask questions to understand the requirements and establish design scope:",
      "level": 3,
      "page": 134
    },
    {
      "heading": "Candidate: What is the main purpose of the crawler? Is it used for search engine indexing,",
      "level": 3,
      "page": 134
    },
    {
      "heading": "data mining, or something else?",
      "level": 3,
      "page": 134
    },
    {
      "heading": "Interviewer: Search engine indexing.",
      "level": 3,
      "page": 134
    },
    {
      "heading": "Candidate: How many web pages does the web crawler collect per month?",
      "level": 3,
      "page": 134
    },
    {
      "heading": "Interviewer: 1 billion pages.",
      "level": 3,
      "page": 134
    },
    {
      "heading": "Candidate: What content types are included? HTML only or other content types such as",
      "level": 3,
      "page": 134
    },
    {
      "heading": "PDFs and images as well?",
      "level": 3,
      "page": 134
    },
    {
      "heading": "Interviewer: HTML only.",
      "level": 3,
      "page": 134
    },
    {
      "heading": "Candidate: Shall we consider newly added or edited web pages?",
      "level": 3,
      "page": 134
    },
    {
      "heading": "Interviewer: Yes, we should consider the newly added or edited web pages.",
      "level": 3,
      "page": 134
    },
    {
      "heading": "Candidate: Do we need to store HTML pages crawled from the web?",
      "level": 3,
      "page": 134
    },
    {
      "heading": "Interviewer: Yes, up to 5 years",
      "level": 3,
      "page": 134
    },
    {
      "heading": "Candidate: How do we handle web pages with duplicate content?",
      "level": 3,
      "page": 134
    },
    {
      "heading": "Interviewer: Pages with duplicate content should be ignored.",
      "level": 3,
      "page": 134
    },
    {
      "heading": "Above are some of the sample questions that you can ask your interviewer. It is important to",
      "level": 3,
      "page": 134
    },
    {
      "heading": "understand the requirements and clarify ambiguities. Even if you are asked to design a",
      "level": 3,
      "page": 134
    },
    {
      "heading": "straightforward product like a web crawler, you and your interviewer might not have the",
      "level": 3,
      "page": 134
    },
    {
      "heading": "same assumptions.",
      "level": 3,
      "page": 134
    },
    {
      "heading": "Beside functionalities to clarify with your interviewer, it is also important to note down the",
      "level": 3,
      "page": 134
    },
    {
      "heading": "following characteristics of a good web crawler:",
      "level": 3,
      "page": 134
    },
    {
      "heading": "• Scalability: The web is very large. There are billions of web pages out there. Web",
      "level": 3,
      "page": 134
    },
    {
      "heading": "crawling should be extremely efficient using parallelization.",
      "level": 3,
      "page": 134
    },
    {
      "heading": "• Robustness: The web is full of traps. Bad HTML, unresponsive servers, crashes,",
      "level": 3,
      "page": 134
    },
    {
      "heading": "malicious links, etc. are all common. The crawler must handle all those edge cases.",
      "level": 3,
      "page": 134
    },
    {
      "heading": "• Politeness: The crawler should not make too many requests to a website within a short",
      "level": 3,
      "page": 134
    },
    {
      "heading": "time interval.",
      "level": 3,
      "page": 134
    },
    {
      "heading": "• Extensibility: The system is flexible so that minimal changes are needed to support new",
      "level": 3,
      "page": 134
    },
    {
      "heading": "content types. For example, if we want to crawl image files in the future, we should not",
      "level": 3,
      "page": 134
    },
    {
      "heading": "need to redesign the entire system.",
      "level": 3,
      "page": 134
    },
    {
      "heading": "Back of the envelope estimation",
      "level": 3,
      "page": 134
    },
    {
      "heading": "The following estimations are based on many assumptions, and it is important to",
      "level": 3,
      "page": 134
    },
    {
      "heading": "communicate with the interviewer to be on the same page.",
      "level": 3,
      "page": 134
    },
    {
      "heading": "• Assume 1 billion web pages are downloaded every month.",
      "level": 3,
      "page": 134
    },
    {
      "heading": "• QPS: 1,000,000,000 / 30 days / 24 hours / 3600 seconds = ~400 pages per second.",
      "level": 3,
      "page": 135
    },
    {
      "heading": "•  Peak QPS = 2 * QPS = 800",
      "level": 3,
      "page": 135
    },
    {
      "heading": "• Assume the average web page size is 500k.",
      "level": 3,
      "page": 135
    },
    {
      "heading": "• 1-billion-page x 500k = 500 TB storage per month. If you are unclear about digital",
      "level": 3,
      "page": 135
    },
    {
      "heading": "storage units, go through “Power of 2” section in Chapter 2 again.",
      "level": 3,
      "page": 135
    },
    {
      "heading": "• Assuming data are stored for five years, 500 TB * 12 months * 5 years = 30 PB. A 30 PB",
      "level": 3,
      "page": 135
    },
    {
      "heading": "storage is needed to store five-year content.",
      "level": 3,
      "page": 135
    },
    {
      "heading": "Step 2 - Propose high-level design and get buy-in",
      "level": 3,
      "page": 136
    },
    {
      "heading": "Once the requirements are clear, we move on to the high-level design. Inspired by previous",
      "level": 3,
      "page": 136
    },
    {
      "heading": "studies on web crawling [4] [5], we propose a high-level design as shown in Figure 9-2.",
      "level": 3,
      "page": 136
    },
    {
      "heading": "First, we explore each design component to understand their functionalities. Then, we",
      "level": 3,
      "page": 136
    },
    {
      "heading": "examine the crawler workflow step-by-step.",
      "level": 3,
      "page": 136
    },
    {
      "heading": "Seed URLs",
      "level": 3,
      "page": 136
    },
    {
      "heading": "use the university’s domain name.",
      "level": 3,
      "page": 136
    },
    {
      "heading": "To crawl the entire web, we need to be creative in selecting seed URLs. A good seed URL",
      "level": 3,
      "page": 136
    },
    {
      "heading": "serves as a good starting point that a crawler can utilize to traverse as many links as possible.",
      "level": 3,
      "page": 136
    },
    {
      "heading": "The general strategy is to divide the entire URL space into smaller ones. The first proposed",
      "level": 3,
      "page": 136
    },
    {
      "heading": "approach is based on locality as different countries may have different popular websites.",
      "level": 3,
      "page": 136
    },
    {
      "heading": "Another way is to choose seed URLs based on topics; for example, we can divide URL space",
      "level": 3,
      "page": 136
    },
    {
      "heading": "into shopping, sports, healthcare, etc. Seed URL selection is an open-ended question. You are",
      "level": 3,
      "page": 136
    },
    {
      "heading": "not expected to give the perfect answer. Just think out loud.",
      "level": 3,
      "page": 136
    },
    {
      "heading": "URL Frontier",
      "level": 3,
      "page": 136
    },
    {
      "heading": "Most modern web crawlers split the crawl state into two: to be downloaded and already",
      "level": 3,
      "page": 136
    },
    {
      "heading": "downloaded. The component that stores URLs to be downloaded is called the URL Frontier.",
      "level": 3,
      "page": 136
    },
    {
      "heading": "You can refer to this as a First-in-First-out (FIFO) queue. For detailed information about the",
      "level": 3,
      "page": 136
    },
    {
      "heading": "URL Frontier, refer to the deep dive.",
      "level": 3,
      "page": 136
    },
    {
      "heading": "HTML Downloader",
      "level": 3,
      "page": 137
    },
    {
      "heading": "The HTML downloader downloads web pages from the internet. Those URLs are provided",
      "level": 3,
      "page": 137
    },
    {
      "heading": "by the URL Frontier.",
      "level": 3,
      "page": 137
    },
    {
      "heading": "DNS Resolver",
      "level": 3,
      "page": 137
    },
    {
      "heading": "To download a web page, a URL must be translated into an IP address. The HTML",
      "level": 3,
      "page": 137
    },
    {
      "heading": "Downloader calls the DNS Resolver to get the corresponding IP address for the URL. For",
      "level": 3,
      "page": 137
    },
    {
      "heading": "instance, URL www.wikipedia.org is converted to IP address 198.35.26.96 as of 3/5/2019.",
      "level": 3,
      "page": 137
    },
    {
      "heading": "Content Parser",
      "level": 3,
      "page": 137
    },
    {
      "heading": "After a web page is downloaded, it must be parsed and validated because malformed web",
      "level": 3,
      "page": 137
    },
    {
      "heading": "pages could provoke problems and waste storage space. Implementing a content parser in a",
      "level": 3,
      "page": 137
    },
    {
      "heading": "crawl server will slow down the crawling process. Thus, the content parser is a separate",
      "level": 3,
      "page": 137
    },
    {
      "heading": "component.",
      "level": 3,
      "page": 137
    },
    {
      "heading": "Content Seen?",
      "level": 3,
      "page": 137
    },
    {
      "heading": "Online research [6] reveals that 29% of the web pages are duplicated contents, which may",
      "level": 3,
      "page": 137
    },
    {
      "heading": "cause the same content to be stored multiple times. We introduce the “Content Seen?” data",
      "level": 3,
      "page": 137
    },
    {
      "heading": "structure to eliminate data redundancy and shorten processing time. It helps to detect new",
      "level": 3,
      "page": 137
    },
    {
      "heading": "content previously stored in the system. To compare two HTML documents, we can compare",
      "level": 3,
      "page": 137
    },
    {
      "heading": "them character by character. However, this method is slow and time-consuming, especially",
      "level": 3,
      "page": 137
    },
    {
      "heading": "when billions of web pages are involved. An efficient way to accomplish this task is to",
      "level": 3,
      "page": 137
    },
    {
      "heading": "compare the hash values of the two web pages [7].",
      "level": 3,
      "page": 137
    },
    {
      "heading": "Content Storage",
      "level": 3,
      "page": 137
    },
    {
      "heading": "It is a storage system for storing HTML content. The choice of storage system depends on",
      "level": 3,
      "page": 137
    },
    {
      "heading": "are used.",
      "level": 3,
      "page": 137
    },
    {
      "heading": "• Most of the content is stored on disk because the data set is too big to fit in memory.",
      "level": 3,
      "page": 137
    },
    {
      "heading": "• Popular content is kept in memory to reduce latency.",
      "level": 3,
      "page": 137
    },
    {
      "heading": "URL Extractor",
      "level": 3,
      "page": 137
    },
    {
      "heading": "URL Extractor parses and extracts links from HTML pages. Figure 9-3 shows an example of",
      "level": 3,
      "page": 137
    },
    {
      "heading": "a link extraction process. Relative paths are converted to absolute URLs by adding the",
      "level": 3,
      "page": 137
    },
    {
      "heading": "“https://en.wikipedia.org” prefix.",
      "level": 3,
      "page": 137
    },
    {
      "heading": "URL Filter",
      "level": 3,
      "page": 138
    },
    {
      "heading": "“blacklisted” sites.",
      "level": 3,
      "page": 138
    },
    {
      "heading": "URL Seen?",
      "level": 3,
      "page": 138
    },
    {
      "heading": "“URL Seen?” is a data structure that keeps track of URLs that are visited before or already in",
      "level": 3,
      "page": 138
    },
    {
      "heading": "the Frontier. “URL Seen?” helps to avoid adding the same URL multiple times as this can",
      "level": 3,
      "page": 138
    },
    {
      "heading": "increase server load and cause potential infinite loops.",
      "level": 3,
      "page": 138
    },
    {
      "heading": "Bloom filter and hash table are common techniques to implement the “URL Seen?”",
      "level": 3,
      "page": 138
    },
    {
      "heading": "component. We will not cover the detailed implementation of the bloom filter and hash table",
      "level": 3,
      "page": 138
    },
    {
      "heading": "here. For more information, refer to the reference materials [4] [8].",
      "level": 3,
      "page": 138
    },
    {
      "heading": "URL Storage",
      "level": 3,
      "page": 138
    },
    {
      "heading": "URL Storage stores already visited URLs.",
      "level": 3,
      "page": 138
    },
    {
      "heading": "So far, we have discussed every system component. Next, we put them together to explain the",
      "level": 3,
      "page": 138
    },
    {
      "heading": "workflow.",
      "level": 3,
      "page": 138
    },
    {
      "heading": "Web crawler workflow",
      "level": 3,
      "page": 138
    },
    {
      "heading": "To better explain the workflow step-by-step, sequence numbers are added in the design",
      "level": 3,
      "page": 138
    },
    {
      "heading": "diagram as shown in Figure 9-4.",
      "level": 3,
      "page": 138
    },
    {
      "heading": "Step 1: Add seed URLs to the URL Frontier",
      "level": 3,
      "page": 139
    },
    {
      "heading": "Step 2: HTML Downloader fetches a list of URLs from URL Frontier.",
      "level": 3,
      "page": 139
    },
    {
      "heading": "Step 3: HTML Downloader gets IP addresses of URLs from DNS resolver and starts",
      "level": 3,
      "page": 139
    },
    {
      "heading": "downloading.",
      "level": 3,
      "page": 139
    },
    {
      "heading": "Step 4: Content Parser parses HTML pages and checks if pages are malformed.",
      "level": 3,
      "page": 139
    },
    {
      "heading": "Step 5: After content is parsed and validated, it is passed to the “Content Seen?” component.",
      "level": 3,
      "page": 139
    },
    {
      "heading": "Step 6: “Content Seen” component checks if a HTML page is already in the storage.",
      "level": 3,
      "page": 139
    },
    {
      "heading": "• If it is in the storage, this means the same content in a different URL has already been",
      "level": 3,
      "page": 139
    },
    {
      "heading": "processed. In this case, the HTML page is discarded.",
      "level": 3,
      "page": 139
    },
    {
      "heading": "• If it is not in the storage, the system has not processed the same content before. The",
      "level": 3,
      "page": 139
    },
    {
      "heading": "content is passed to Link Extractor.",
      "level": 3,
      "page": 139
    },
    {
      "heading": "Step 7: Link extractor extracts links from HTML pages.",
      "level": 3,
      "page": 139
    },
    {
      "heading": "Step 8: Extracted links are passed to the URL filter.",
      "level": 3,
      "page": 139
    },
    {
      "heading": "Step 9: After links are filtered, they are passed to the “URL Seen?” component.",
      "level": 3,
      "page": 139
    },
    {
      "heading": "Step 10: “URL Seen” component checks if a URL is already in the storage, if yes, it is",
      "level": 3,
      "page": 139
    },
    {
      "heading": "processed before, and nothing needs to be done.",
      "level": 3,
      "page": 139
    },
    {
      "heading": "Step 11: If a URL has not been processed before, it is added to the URL Frontier.",
      "level": 3,
      "page": 139
    },
    {
      "heading": "Step 3 - Design deep dive",
      "level": 3,
      "page": 140
    },
    {
      "heading": "Up until now, we have discussed the high-level design. Next, we will discuss the most",
      "level": 3,
      "page": 140
    },
    {
      "heading": "important building components and techniques in depth:",
      "level": 3,
      "page": 140
    },
    {
      "heading": "• Depth-first search (DFS) vs Breadth-first search (BFS)",
      "level": 3,
      "page": 140
    },
    {
      "heading": "• URL frontier",
      "level": 3,
      "page": 140
    },
    {
      "heading": "• HTML Downloader",
      "level": 3,
      "page": 140
    },
    {
      "heading": "• Robustness",
      "level": 3,
      "page": 140
    },
    {
      "heading": "• Extensibility",
      "level": 3,
      "page": 140
    },
    {
      "heading": "• Detect and avoid problematic content",
      "level": 3,
      "page": 140
    },
    {
      "heading": "DFS vs BFS",
      "level": 3,
      "page": 140
    },
    {
      "heading": "You can think of the web as a directed graph where web pages serve as nodes and hyperlinks",
      "level": 3,
      "page": 140
    },
    {
      "heading": "(URLs) as edges. The crawl process can be seen as traversing a directed graph from one web",
      "level": 3,
      "page": 140
    },
    {
      "heading": "page to others. Two common graph traversal algorithms are DFS and BFS. However, DFS is",
      "level": 3,
      "page": 140
    },
    {
      "heading": "usually not a good choice because the depth of DFS can be very deep.",
      "level": 3,
      "page": 140
    },
    {
      "heading": "BFS is commonly used by web crawlers and is implemented by a first-in-first-out (FIFO)",
      "level": 3,
      "page": 140
    },
    {
      "heading": "queue. In a FIFO queue, URLs are dequeued in the order they are enqueued. However, this",
      "level": 3,
      "page": 140
    },
    {
      "heading": "implementation has two problems:",
      "level": 3,
      "page": 140
    },
    {
      "heading": "• Most links from the same web page are linked back to the same host. In Figure 9-5, all",
      "level": 3,
      "page": 140
    },
    {
      "heading": "the links in wikipedia.com are internal links, making the crawler busy processing URLs",
      "level": 3,
      "page": 140
    },
    {
      "heading": "from the same host (wikipedia.com). When the crawler tries to download web pages in",
      "level": 3,
      "page": 140
    },
    {
      "heading": "parallel, Wikipedia servers will be flooded with requests. This is considered as “impolite”.",
      "level": 3,
      "page": 140
    },
    {
      "heading": "• Standard BFS does not take the priority of a URL into consideration. The web is large",
      "level": 3,
      "page": 141
    },
    {
      "heading": "and not every page has the same level of quality and importance. Therefore, we may want",
      "level": 3,
      "page": 141
    },
    {
      "heading": "to prioritize URLs according to their page ranks, web traffic, update frequency, etc.",
      "level": 3,
      "page": 141
    },
    {
      "heading": "URL frontier",
      "level": 3,
      "page": 141
    },
    {
      "heading": "URLs to be downloaded. The URL frontier is an important component to ensure politeness,",
      "level": 3,
      "page": 141
    },
    {
      "heading": "URL prioritization, and freshness. A few noteworthy papers on URL frontier are mentioned",
      "level": 3,
      "page": 141
    },
    {
      "heading": "in the reference materials [5] [9]. The findings from these papers are as follows:",
      "level": 3,
      "page": 141
    },
    {
      "heading": "Politeness",
      "level": 3,
      "page": 141
    },
    {
      "heading": "Generally, a web crawler should avoid sending too many requests to the same hosting server",
      "level": 3,
      "page": 141
    },
    {
      "heading": "within a short period. Sending too many requests is considered as “impolite” or even treated",
      "level": 3,
      "page": 141
    },
    {
      "heading": "as denial-of-service (DOS) attack. For example, without any constraint, the crawler can send",
      "level": 3,
      "page": 141
    },
    {
      "heading": "thousands of requests every second to the same website. This can overwhelm the web",
      "level": 3,
      "page": 141
    },
    {
      "heading": "servers.",
      "level": 3,
      "page": 141
    },
    {
      "heading": "The general idea of enforcing politeness is to download one page at a time from the same",
      "level": 3,
      "page": 141
    },
    {
      "heading": "host. A delay can be added between two download tasks. The politeness constraint is",
      "level": 3,
      "page": 141
    },
    {
      "heading": "implemented by maintain a mapping from website hostnames to download (worker) threads.",
      "level": 3,
      "page": 141
    },
    {
      "heading": "Each downloader thread has a separate FIFO queue and only downloads URLs obtained from",
      "level": 3,
      "page": 141
    },
    {
      "heading": "that queue. Figure 9-6 shows the design that manages politeness.",
      "level": 3,
      "page": 141
    },
    {
      "heading": "• Queue router: It ensures that each queue (b1, b2, … bn) only contains URLs from the",
      "level": 3,
      "page": 142
    },
    {
      "heading": "same host.",
      "level": 3,
      "page": 142
    },
    {
      "heading": "• Mapping table: It maps each host to a queue.",
      "level": 3,
      "page": 142
    },
    {
      "heading": "• FIFO queues b1, b2 to bn: Each queue contains URLs from the same host.",
      "level": 3,
      "page": 142
    },
    {
      "heading": "• Queue selector: Each worker thread is mapped to a FIFO queue, and it only downloads",
      "level": 3,
      "page": 142
    },
    {
      "heading": "URLs from that queue. The queue selection logic is done by the Queue selector.",
      "level": 3,
      "page": 142
    },
    {
      "heading": "• Worker thread 1 to N. A worker thread downloads web pages one by one from the same",
      "level": 3,
      "page": 142
    },
    {
      "heading": "host. A delay can be added between two download tasks.",
      "level": 3,
      "page": 142
    },
    {
      "heading": "Priority",
      "level": 3,
      "page": 142
    },
    {
      "heading": "A random post from a discussion forum about Apple products carries very different weight",
      "level": 3,
      "page": 142
    },
    {
      "heading": "than posts on the Apple home page. Even though they both have the “Apple” keyword, it is",
      "level": 3,
      "page": 142
    },
    {
      "heading": "sensible for a crawler to crawl the Apple home page first.",
      "level": 3,
      "page": 142
    },
    {
      "heading": "We prioritize URLs based on usefulness, which can be measured by PageRank [10], website",
      "level": 3,
      "page": 142
    },
    {
      "heading": "traffic, update frequency, etc. “Prioritizer” is the component that handles URL prioritization.",
      "level": 3,
      "page": 142
    },
    {
      "heading": "Refer to the reference materials [5] [10] for in-depth information about this concept.",
      "level": 3,
      "page": 142
    },
    {
      "heading": "Figure 9-7 shows the design that manages URL priority.",
      "level": 3,
      "page": 142
    },
    {
      "heading": "• Prioritizer: It takes URLs as input and computes the priorities.",
      "level": 3,
      "page": 143
    },
    {
      "heading": "• Queue f1 to fn: Each queue has an assigned priority. Queues with high priority are",
      "level": 3,
      "page": 143
    },
    {
      "heading": "selected with higher probability.",
      "level": 3,
      "page": 143
    },
    {
      "heading": "• Queue selector: Randomly choose a queue with a bias towards queues with higher",
      "level": 3,
      "page": 143
    },
    {
      "heading": "priority.",
      "level": 3,
      "page": 143
    },
    {
      "heading": "Figure 9-8 presents the URL frontier design, and it contains two modules:",
      "level": 3,
      "page": 143
    },
    {
      "heading": "• Front queues: manage prioritization",
      "level": 3,
      "page": 143
    },
    {
      "heading": "• Back queues: manage politeness",
      "level": 3,
      "page": 143
    },
    {
      "heading": "Freshness",
      "level": 3,
      "page": 144
    },
    {
      "heading": "Web pages are constantly being added, deleted, and edited. A web crawler must periodically",
      "level": 3,
      "page": 144
    },
    {
      "heading": "recrawl downloaded pages to keep our data set fresh. Recrawl all the URLs is time-",
      "level": 3,
      "page": 144
    },
    {
      "heading": "consuming and resource intensive. Few strategies to optimize freshness are listed as follows:",
      "level": 3,
      "page": 144
    },
    {
      "heading": "• Recrawl based on web pages’ update history.",
      "level": 3,
      "page": 145
    },
    {
      "heading": "• Prioritize URLs and recrawl important pages first and more frequently.",
      "level": 3,
      "page": 145
    },
    {
      "heading": "Storage for URL Frontier",
      "level": 3,
      "page": 145
    },
    {
      "heading": "of millions [4]. Putting everything in memory is neither durable nor scalable. Keeping",
      "level": 3,
      "page": 145
    },
    {
      "heading": "everything in the disk is undesirable neither because the disk is slow; and it can easily",
      "level": 3,
      "page": 145
    },
    {
      "heading": "become a bottleneck for the crawl.",
      "level": 3,
      "page": 145
    },
    {
      "heading": "We adopted a hybrid approach. The majority of URLs are stored on disk, so the storage space",
      "level": 3,
      "page": 145
    },
    {
      "heading": "is not a problem. To reduce the cost of reading from the disk and writing to the disk, we",
      "level": 3,
      "page": 145
    },
    {
      "heading": "maintain buffers in memory for enqueue/dequeue operations. Data in the buffer is",
      "level": 3,
      "page": 145
    },
    {
      "heading": "periodically written to the disk.",
      "level": 3,
      "page": 145
    },
    {
      "heading": "HTML Downloader",
      "level": 3,
      "page": 145
    },
    {
      "heading": "The HTML Downloader downloads web pages from the internet using the HTTP protocol.",
      "level": 3,
      "page": 145
    },
    {
      "heading": "Before discussing the HTML Downloader, we look at Robots Exclusion Protocol first.",
      "level": 3,
      "page": 145
    },
    {
      "heading": "Robots.txt",
      "level": 3,
      "page": 145
    },
    {
      "heading": "Robots.txt, called Robots Exclusion Protocol, is a standard used by websites to communicate",
      "level": 3,
      "page": 145
    },
    {
      "heading": "with crawlers. It specifies what pages crawlers are allowed to download. Before attempting to",
      "level": 3,
      "page": 145
    },
    {
      "heading": "crawl a web site, a crawler should check its corresponding robots.txt first and follow its rules.",
      "level": 3,
      "page": 145
    },
    {
      "heading": "To avoid repeat downloads of robots.txt file, we cache the results of the file. The file is",
      "level": 3,
      "page": 145
    },
    {
      "heading": "downloaded and saved to cache periodically. Here is a piece of robots.txt file taken from",
      "level": 3,
      "page": 145
    },
    {
      "heading": "https://www.amazon.com/robots.txt. Some of the directories like creatorhub are disallowed",
      "level": 3,
      "page": 145
    },
    {
      "heading": "for Google bot.",
      "level": 3,
      "page": 145
    },
    {
      "heading": "User-agent: Googlebot",
      "level": 3,
      "page": 145
    },
    {
      "heading": "Disallow: /creatorhub/*",
      "level": 3,
      "page": 145
    },
    {
      "heading": "Disallow: /rss/people/*/reviews",
      "level": 3,
      "page": 145
    },
    {
      "heading": "Disallow: /gp/pdp/rss/*/reviews",
      "level": 3,
      "page": 145
    },
    {
      "heading": "Disallow: /gp/cdp/member-reviews/",
      "level": 3,
      "page": 145
    },
    {
      "heading": "Disallow: /gp/aw/cr/",
      "level": 3,
      "page": 145
    },
    {
      "heading": "Besides robots.txt, performance optimization is another important concept we will cover for",
      "level": 3,
      "page": 145
    },
    {
      "heading": "the HTML downloader.",
      "level": 3,
      "page": 145
    },
    {
      "heading": "Performance optimization",
      "level": 3,
      "page": 145
    },
    {
      "heading": "Below is a list of performance optimizations for HTML downloader.",
      "level": 3,
      "page": 145
    },
    {
      "heading": "1. Distributed crawl",
      "level": 3,
      "page": 145
    },
    {
      "heading": "To achieve high performance, crawl jobs are distributed into multiple servers, and each server",
      "level": 3,
      "page": 145
    },
    {
      "heading": "runs multiple threads. The URL space is partitioned into smaller pieces; so, each downloader",
      "level": 3,
      "page": 145
    },
    {
      "heading": "is responsible for a subset of the URLs. Figure 9-9 shows an example of a distributed crawl.",
      "level": 3,
      "page": 145
    },
    {
      "heading": "2. Cache DNS Resolver",
      "level": 3,
      "page": 146
    },
    {
      "heading": "DNS Resolver is a bottleneck for crawlers because DNS requests might take time due to the",
      "level": 3,
      "page": 146
    },
    {
      "heading": "synchronous nature of many DNS interfaces. DNS response time ranges from 10ms to",
      "level": 3,
      "page": 146
    },
    {
      "heading": "200ms. Once a request to DNS is carried out by a crawler thread, other threads are blocked",
      "level": 3,
      "page": 146
    },
    {
      "heading": "until the first request is completed. Maintaining our DNS cache to avoid calling DNS",
      "level": 3,
      "page": 146
    },
    {
      "heading": "frequently is an effective technique for speed optimization. Our DNS cache keeps the domain",
      "level": 3,
      "page": 146
    },
    {
      "heading": "name to IP address mapping and is updated periodically by cron jobs.",
      "level": 3,
      "page": 146
    },
    {
      "heading": "3. Locality",
      "level": 3,
      "page": 146
    },
    {
      "heading": "Distribute crawl servers geographically. When crawl servers are closer to website hosts,",
      "level": 3,
      "page": 146
    },
    {
      "heading": "crawlers experience faster download time. Design locality applies to most of the system",
      "level": 3,
      "page": 146
    },
    {
      "heading": "components: crawl servers, cache, queue, storage, etc.",
      "level": 3,
      "page": 146
    },
    {
      "heading": "4. Short timeout",
      "level": 3,
      "page": 146
    },
    {
      "heading": "Some web servers respond slowly or may not respond at all. To avoid long wait time, a",
      "level": 3,
      "page": 146
    },
    {
      "heading": "maximal wait time is specified. If a host does not respond within a predefined time, the",
      "level": 3,
      "page": 146
    },
    {
      "heading": "crawler will stop the job and crawl some other pages.",
      "level": 3,
      "page": 146
    },
    {
      "heading": "Robustness",
      "level": 3,
      "page": 146
    },
    {
      "heading": "Besides performance optimization, robustness is also an important consideration. We present",
      "level": 3,
      "page": 146
    },
    {
      "heading": "a few approaches to improve the system robustness:",
      "level": 3,
      "page": 146
    },
    {
      "heading": "• Consistent hashing: This helps to distribute loads among downloaders. A new",
      "level": 3,
      "page": 146
    },
    {
      "heading": "downloader server can be added or removed using consistent hashing. Refer to Chapter 5:",
      "level": 3,
      "page": 146
    },
    {
      "heading": "Design consistent hashing for more details.",
      "level": 3,
      "page": 146
    },
    {
      "heading": "• Save crawl states and data: To guard against failures, crawl states and data are written to",
      "level": 3,
      "page": 146
    },
    {
      "heading": "a storage system. A disrupted crawl can be restarted easily by loading saved states and",
      "level": 3,
      "page": 146
    },
    {
      "heading": "data.",
      "level": 3,
      "page": 146
    },
    {
      "heading": "• Exception handling: Errors are inevitable and common in a large-scale system. The",
      "level": 3,
      "page": 146
    },
    {
      "heading": "crawler must handle exceptions gracefully without crashing the system.",
      "level": 3,
      "page": 147
    },
    {
      "heading": "• Data validation: This is an important measure to prevent system errors.",
      "level": 3,
      "page": 147
    },
    {
      "heading": "Extensibility",
      "level": 3,
      "page": 147
    },
    {
      "heading": "As almost every system evolves, one of the design goals is to make the system flexible",
      "level": 3,
      "page": 147
    },
    {
      "heading": "enough to support new content types. The crawler can be extended by plugging in new",
      "level": 3,
      "page": 147
    },
    {
      "heading": "modules. Figure 9-10 shows how to add new modules.",
      "level": 3,
      "page": 147
    },
    {
      "heading": "• PNG Downloader module is plugged-in to download PNG files.",
      "level": 3,
      "page": 147
    },
    {
      "heading": "• Web Monitor module is added to monitor the web and prevent copyright and trademark",
      "level": 3,
      "page": 147
    },
    {
      "heading": "infringements.",
      "level": 3,
      "page": 147
    },
    {
      "heading": "Detect and avoid problematic content",
      "level": 3,
      "page": 147
    },
    {
      "heading": "This section discusses the detection and prevention of redundant, meaningless, or harmful",
      "level": 3,
      "page": 147
    },
    {
      "heading": "content.",
      "level": 3,
      "page": 147
    },
    {
      "heading": "1. Redundant content",
      "level": 3,
      "page": 147
    },
    {
      "heading": "As discussed previously, nearly 30% of the web pages are duplicates. Hashes or checksums",
      "level": 3,
      "page": 147
    },
    {
      "heading": "help to detect duplication [11].",
      "level": 3,
      "page": 147
    },
    {
      "heading": "2. Spider traps",
      "level": 3,
      "page": 147
    },
    {
      "heading": "deep directory structure is listed as follows:",
      "level": 3,
      "page": 147
    },
    {
      "heading": "www.spidertrapexample.com/foo/bar/foo/bar/foo/bar/…",
      "level": 3,
      "page": 147
    },
    {
      "heading": "Such spider traps can be avoided by setting a maximal length for URLs. However, no one-",
      "level": 3,
      "page": 147
    },
    {
      "heading": "identify due to an unusually large number of web pages discovered on such websites. It is",
      "level": 3,
      "page": 147
    },
    {
      "heading": "hard to develop automatic algorithms to avoid spider traps; however, a user can manually",
      "level": 3,
      "page": 147
    },
    {
      "heading": "verify and identify a spider trap, and either exclude those websites from the crawler or apply",
      "level": 3,
      "page": 148
    },
    {
      "heading": "some customized URL filters.",
      "level": 3,
      "page": 148
    },
    {
      "heading": "3. Data noise",
      "level": 3,
      "page": 148
    },
    {
      "heading": "Some of the contents have little or no value, such as advertisements, code snippets, spam",
      "level": 3,
      "page": 148
    },
    {
      "heading": "URLs, etc. Those contents are not useful for crawlers and should be excluded if possible.",
      "level": 3,
      "page": 148
    },
    {
      "heading": "Step 4 - Wrap up",
      "level": 3,
      "page": 149
    },
    {
      "heading": "In this chapter, we first discussed the characteristics of a good crawler: scalability, politeness,",
      "level": 3,
      "page": 149
    },
    {
      "heading": "extensibility, and robustness. Then, we proposed a design and discussed key components.",
      "level": 3,
      "page": 149
    },
    {
      "heading": "Building a scalable web crawler is not a trivial task because the web is enormously large and",
      "level": 3,
      "page": 149
    },
    {
      "heading": "full of traps. Even though we have covered many topics, we still miss many relevant talking",
      "level": 3,
      "page": 149
    },
    {
      "heading": "points:",
      "level": 3,
      "page": 149
    },
    {
      "heading": "• Server-side rendering: Numerous websites use scripts like JavaScript, AJAX, etc to",
      "level": 3,
      "page": 149
    },
    {
      "heading": "generate links on the fly. If we download and parse web pages directly, we will not be able",
      "level": 3,
      "page": 149
    },
    {
      "heading": "to retrieve dynamically generated links. To solve this problem, we perform server-side",
      "level": 3,
      "page": 149
    },
    {
      "heading": "rendering (also called dynamic rendering) first before parsing a page [12].",
      "level": 3,
      "page": 149
    },
    {
      "heading": "• Filter out unwanted pages: With finite storage capacity and crawl resources, an anti-spam",
      "level": 3,
      "page": 149
    },
    {
      "heading": "component is beneficial in filtering out low quality and spam pages [13] [14].",
      "level": 3,
      "page": 149
    },
    {
      "heading": "• Database replication and sharding: Techniques like replication and sharding are used to",
      "level": 3,
      "page": 149
    },
    {
      "heading": "improve the data layer availability, scalability, and reliability.",
      "level": 3,
      "page": 149
    },
    {
      "heading": "• Horizontal scaling: For large scale crawl, hundreds or even thousands of servers are",
      "level": 3,
      "page": 149
    },
    {
      "heading": "needed to perform download tasks. The key is to keep servers stateless.",
      "level": 3,
      "page": 149
    },
    {
      "heading": "• Availability, consistency, and reliability: These concepts are at the core of any large",
      "level": 3,
      "page": 149
    },
    {
      "heading": "system’s success. We discussed these concepts in detail in Chapter 1. Refresh your",
      "level": 3,
      "page": 149
    },
    {
      "heading": "memory on these topics.",
      "level": 3,
      "page": 149
    },
    {
      "heading": "• Analytics: Collecting and analyzing data are important parts of any system because data",
      "level": 3,
      "page": 149
    },
    {
      "heading": "is key ingredient for fine-tuning.",
      "level": 3,
      "page": 149
    },
    {
      "heading": "Congratulations on getting this far! Now give yourself a pat on the back. Good job!",
      "level": 3,
      "page": 149
    },
    {
      "heading": "Reference materials",
      "level": 2,
      "page": 150
    },
    {
      "heading": "[1] US Library of Congress: https://www.loc.gov/websites/",
      "level": 3,
      "page": 150
    },
    {
      "heading": "[2] EU Web Archive: http://data.europa.eu/webarchive",
      "level": 3,
      "page": 150
    },
    {
      "heading": "[3] Digimarc: https://www.digimarc.com/products/digimarc-services/piracy-intelligence",
      "level": 3,
      "page": 150
    },
    {
      "heading": "[4] Heydon A., Najork M. Mercator: A scalable, extensible web crawler World Wide Web, 2",
      "level": 3,
      "page": 150
    },
    {
      "heading": "(4) (1999), pp. 219-229",
      "level": 3,
      "page": 150
    },
    {
      "heading": "[5] By Christopher Olston, Marc Najork: Web Crawling.",
      "level": 3,
      "page": 150
    },
    {
      "heading": "http://infolab.stanford.edu/~olston/publications/crawling_survey.pdf",
      "level": 3,
      "page": 150
    },
    {
      "heading": "[6] 29% Of Sites Face Duplicate Content Issues: https://tinyurl.com/y6tmh55y",
      "level": 3,
      "page": 150
    },
    {
      "heading": "[7] Rabin M.O., et al. Fingerprinting by random polynomials Center for Research in",
      "level": 3,
      "page": 150
    },
    {
      "heading": "Computing Techn., Aiken Computation Laboratory, Univ. (1981)",
      "level": 3,
      "page": 150
    },
    {
      "heading": "[8] B. H. Bloom, “Space/time trade-offs in hash coding with allowable errors,”",
      "level": 3,
      "page": 150
    },
    {
      "heading": "Communications of the ACM, vol. 13, no. 7, pp. 422–426, 1970.",
      "level": 3,
      "page": 150
    },
    {
      "heading": "[9] Donald J. Patterson, Web Crawling:",
      "level": 3,
      "page": 150
    },
    {
      "heading": "https://www.ics.uci.edu/~lopes/teaching/cs221W12/slides/Lecture05.pdf",
      "level": 3,
      "page": 150
    },
    {
      "heading": "[10] L. Page, S. Brin, R. Motwani, and T. Winograd, “The PageRank citation",
      "level": 3,
      "page": 150
    },
    {
      "heading": "ranking: Bringing order to the web,” Technical Report, Stanford University,",
      "level": 3,
      "page": 150
    },
    {
      "heading": "1998.",
      "level": 3,
      "page": 150
    },
    {
      "heading": "[11] Burton Bloom. Space/time trade-offs in hash coding with allowable errors.",
      "level": 3,
      "page": 150
    },
    {
      "heading": "Communications of the ACM, 13(7), pages 422--426, July 1970.",
      "level": 3,
      "page": 150
    },
    {
      "heading": "[12] Google Dynamic Rendering:",
      "level": 3,
      "page": 150
    },
    {
      "heading": "https://developers.google.com/search/docs/guides/dynamic-rendering",
      "level": 3,
      "page": 150
    },
    {
      "heading": "[13] T. Urvoy, T. Lavergne, and P. Filoche, “Tracking web spam with hidden style",
      "level": 3,
      "page": 150
    },
    {
      "heading": "similarity,” in Proceedings of the 2nd International Workshop on Adversarial Information",
      "level": 3,
      "page": 150
    },
    {
      "heading": "Retrieval on the Web, 2006.",
      "level": 3,
      "page": 150
    },
    {
      "heading": "[14] H.-T. Lee, D. Leonard, X. Wang, and D. Loguinov, “IRLbot: Scaling to 6 billion pages",
      "level": 3,
      "page": 150
    },
    {
      "heading": "and beyond,” in Proceedings of the 17th International World Wide Web Conference, 2008.",
      "level": 3,
      "page": 150
    },
    {
      "heading": "CHAPTER 10: DESIGN A NOTIFICATION SYSTEM",
      "level": 1,
      "page": 151
    },
    {
      "heading": "A notification system has already become a very popular feature for many applications in",
      "level": 3,
      "page": 151
    },
    {
      "heading": "recent years. A notification alerts a user with important information like breaking news,",
      "level": 3,
      "page": 151
    },
    {
      "heading": "product updates, events, offerings, etc. It has become an indispensable part of our daily life.",
      "level": 3,
      "page": 151
    },
    {
      "heading": "In this chapter, you are asked to design a notification system.",
      "level": 3,
      "page": 151
    },
    {
      "heading": "A notification is more than just mobile push notification. Three types of notification formats",
      "level": 3,
      "page": 151
    },
    {
      "heading": "are: mobile push notification, SMS message, and Email. Figure 10-1 shows an example of",
      "level": 3,
      "page": 151
    },
    {
      "heading": "each of these notifications.",
      "level": 3,
      "page": 151
    },
    {
      "heading": "Step 1 - Understand the problem and establish design scope",
      "level": 3,
      "page": 152
    },
    {
      "heading": "Building a scalable system that sends out millions of notifications a day is not an easy task. It",
      "level": 3,
      "page": 152
    },
    {
      "heading": "requires a deep understanding of the notification ecosystem. The interview question is",
      "level": 3,
      "page": 152
    },
    {
      "heading": "purposely designed to be open-ended and ambiguous, and it is your responsibility to ask",
      "level": 3,
      "page": 152
    },
    {
      "heading": "questions to clarify the requirements.",
      "level": 3,
      "page": 152
    },
    {
      "heading": "Candidate: What types of notifications does the system support?",
      "level": 3,
      "page": 152
    },
    {
      "heading": "Interviewer: Push notification, SMS message, and email.",
      "level": 3,
      "page": 152
    },
    {
      "heading": "Candidate: Is it a real-time system?",
      "level": 3,
      "page": 152
    },
    {
      "heading": "Interviewer: Let us say it is a soft real-time system. We want a user to receive notifications",
      "level": 3,
      "page": 152
    },
    {
      "heading": "as soon as possible. However, if the system is under a high workload, a slight delay is",
      "level": 3,
      "page": 152
    },
    {
      "heading": "acceptable.",
      "level": 3,
      "page": 152
    },
    {
      "heading": "Candidate: What are the supported devices?",
      "level": 3,
      "page": 152
    },
    {
      "heading": "Interviewer: iOS devices, android devices, and laptop/desktop.",
      "level": 3,
      "page": 152
    },
    {
      "heading": "Candidate: What triggers notifications?",
      "level": 3,
      "page": 152
    },
    {
      "heading": "Interviewer: Notifications can be triggered by client applications. They can also be",
      "level": 3,
      "page": 152
    },
    {
      "heading": "scheduled on the server-side.",
      "level": 3,
      "page": 152
    },
    {
      "heading": "Candidate: Will users be able to opt-out?",
      "level": 3,
      "page": 152
    },
    {
      "heading": "Interviewer: Yes, users who choose to opt-out will no longer receive notifications.",
      "level": 3,
      "page": 152
    },
    {
      "heading": "Candidate: How many notifications are sent out each day?",
      "level": 3,
      "page": 152
    },
    {
      "heading": "Interviewer: 10 million mobile push notifications, 1 million SMS messages, and 5 million",
      "level": 3,
      "page": 152
    },
    {
      "heading": "emails.",
      "level": 3,
      "page": 152
    },
    {
      "heading": "Step 2 - Propose high-level design and get buy-in",
      "level": 3,
      "page": 153
    },
    {
      "heading": "This section shows the high-level design that supports various notification types: iOS push",
      "level": 3,
      "page": 153
    },
    {
      "heading": "notification, Android push notification, SMS message, and Email. It is structured as follows:",
      "level": 3,
      "page": 153
    },
    {
      "heading": "• Different types of notifications",
      "level": 3,
      "page": 153
    },
    {
      "heading": "• Contact info gathering flow",
      "level": 3,
      "page": 153
    },
    {
      "heading": "• Notification sending/receiving flow",
      "level": 3,
      "page": 153
    },
    {
      "heading": "Different types of notifications",
      "level": 3,
      "page": 153
    },
    {
      "heading": "We start by looking at how each notification type works at a high level.",
      "level": 3,
      "page": 153
    },
    {
      "heading": "iOS push notification",
      "level": 3,
      "page": 153
    },
    {
      "heading": "We primary need three components to send an iOS push notification:",
      "level": 3,
      "page": 153
    },
    {
      "heading": "• Provider. A provider builds and sends notification requests to Apple Push Notification",
      "level": 3,
      "page": 153
    },
    {
      "heading": "Service (APNS). To construct a push notification, the provider provides the following",
      "level": 3,
      "page": 153
    },
    {
      "heading": "data:",
      "level": 3,
      "page": 153
    },
    {
      "heading": "• Device token: This is a unique identifier used for sending push notifications.",
      "level": 3,
      "page": 153
    },
    {
      "heading": "• Payload: This is a JSON dictionary that contains a notification’s payload. Here is an",
      "level": 3,
      "page": 153
    },
    {
      "heading": "example:",
      "level": 3,
      "page": 153
    },
    {
      "heading": "• APNS: This is a remote service provided by Apple to propagate push notifications to iOS",
      "level": 3,
      "page": 153
    },
    {
      "heading": "devices.",
      "level": 3,
      "page": 153
    },
    {
      "heading": "• iOS Device: It is the end client, which receives push notifications.",
      "level": 3,
      "page": 153
    },
    {
      "heading": "Android push notification",
      "level": 3,
      "page": 153
    },
    {
      "heading": "Android adopts a similar notification flow. Instead of using APNs, Firebase Cloud Messaging",
      "level": 3,
      "page": 153
    },
    {
      "heading": "(FCM) is commonly used to send push notifications to android devices.",
      "level": 3,
      "page": 153
    },
    {
      "heading": "SMS message",
      "level": 3,
      "page": 154
    },
    {
      "heading": "For SMS messages, third party SMS services like Twilio [1], Nexmo [2], and many others are",
      "level": 3,
      "page": 154
    },
    {
      "heading": "commonly used. Most of them are commercial services.",
      "level": 3,
      "page": 154
    },
    {
      "heading": "Email",
      "level": 3,
      "page": 154
    },
    {
      "heading": "Although companies can set up their own email servers, many of them opt for commercial",
      "level": 3,
      "page": 154
    },
    {
      "heading": "email services. Sendgrid [3] and Mailchimp [4] are among the most popular email services,",
      "level": 3,
      "page": 154
    },
    {
      "heading": "which offer a better delivery rate and data analytics.",
      "level": 3,
      "page": 154
    },
    {
      "heading": "Figure 10-6 shows the design after including all the third-party services.",
      "level": 3,
      "page": 154
    },
    {
      "heading": "Contact info gathering flow",
      "level": 3,
      "page": 155
    },
    {
      "heading": "To send notifications, we need to gather mobile device tokens, phone numbers, or email",
      "level": 3,
      "page": 155
    },
    {
      "heading": "addresses. As shown in Figure 10-7, when a user installs our app or signs up for the first time,",
      "level": 3,
      "page": 155
    },
    {
      "heading": "API servers collect user contact info and store it in the database.",
      "level": 3,
      "page": 155
    },
    {
      "heading": "numbers are stored in the user table, whereas device tokens are stored in the device table. A",
      "level": 3,
      "page": 155
    },
    {
      "heading": "user can have multiple devices, indicating that a push notification can be sent to all the user",
      "level": 3,
      "page": 156
    },
    {
      "heading": "devices.",
      "level": 3,
      "page": 156
    },
    {
      "heading": "Notification sending/receiving flow",
      "level": 3,
      "page": 156
    },
    {
      "heading": "We will first present the initial design; then, propose some optimizations.",
      "level": 3,
      "page": 156
    },
    {
      "heading": "High-level design",
      "level": 3,
      "page": 156
    },
    {
      "heading": "Figure 10-9 shows the design, and each system component is explained below.",
      "level": 3,
      "page": 156
    },
    {
      "heading": "triggers notification sending events. For example, a billing service sends emails to remind",
      "level": 3,
      "page": 156
    },
    {
      "heading": "customers of their due payment or a shopping website tells customers that their packages will",
      "level": 3,
      "page": 156
    },
    {
      "heading": "be delivered tomorrow via SMS messages.",
      "level": 3,
      "page": 156
    },
    {
      "heading": "Notification system: The notification system is the centerpiece of sending/receiving",
      "level": 3,
      "page": 157
    },
    {
      "heading": "notifications. Starting with something simple, only one notification server is used. It provides",
      "level": 3,
      "page": 157
    },
    {
      "heading": "APIs for services 1 to N, and builds notification payloads for third party services.",
      "level": 3,
      "page": 157
    },
    {
      "heading": "Third-party services: Third party services are responsible for delivering notifications to",
      "level": 3,
      "page": 157
    },
    {
      "heading": "users. While integrating with third-party services, we need to pay extra attention to",
      "level": 3,
      "page": 157
    },
    {
      "heading": "extensibility. Good extensibility means a flexible system that can easily plugging or",
      "level": 3,
      "page": 157
    },
    {
      "heading": "unplugging of a third-party service. Another important consideration is that a third-party",
      "level": 3,
      "page": 157
    },
    {
      "heading": "service might be unavailable in new markets or in the future. For instance, FCM is",
      "level": 3,
      "page": 157
    },
    {
      "heading": "unavailable in China. Thus, alternative third-party services such as Jpush, PushY, etc are used",
      "level": 3,
      "page": 157
    },
    {
      "heading": "there.",
      "level": 3,
      "page": 157
    },
    {
      "heading": "iOS, Android, SMS, Email: Users receive notifications on their devices.",
      "level": 3,
      "page": 157
    },
    {
      "heading": "Three problems are identified in this design:",
      "level": 3,
      "page": 157
    },
    {
      "heading": "• Single point of failure (SPOF): A single notification server means SPOF.",
      "level": 3,
      "page": 157
    },
    {
      "heading": "• Hard to scale: The notification system handles everything related to push notifications in",
      "level": 3,
      "page": 157
    },
    {
      "heading": "one server. It is challenging to scale databases, caches, and different notification",
      "level": 3,
      "page": 157
    },
    {
      "heading": "processing components independently.",
      "level": 3,
      "page": 157
    },
    {
      "heading": "• Performance bottleneck: Processing and sending notifications can be resource intensive.",
      "level": 3,
      "page": 157
    },
    {
      "heading": "For example, constructing HTML pages and waiting for responses from third party",
      "level": 3,
      "page": 157
    },
    {
      "heading": "services could take time. Handling everything in one system can result in the system",
      "level": 3,
      "page": 157
    },
    {
      "heading": "overload, especially during peak hours.",
      "level": 3,
      "page": 157
    },
    {
      "heading": "High-level design (improved)",
      "level": 3,
      "page": 157
    },
    {
      "heading": "After enumerating challenges in the initial design, we improve the design as listed below:",
      "level": 3,
      "page": 157
    },
    {
      "heading": "• Move the database and cache out of the notification server.",
      "level": 3,
      "page": 157
    },
    {
      "heading": "• Add more notification servers and set up automatic horizontal scaling.",
      "level": 3,
      "page": 157
    },
    {
      "heading": "• Introduce message queues to decouple the system components.",
      "level": 3,
      "page": 157
    },
    {
      "heading": "Figure 10-10 shows the improved high-level design.",
      "level": 3,
      "page": 157
    },
    {
      "heading": "The best way to go through the above diagram is from left to right:",
      "level": 3,
      "page": 158
    },
    {
      "heading": "Service 1 to N: They represent different services that send notifications via APIs provided by",
      "level": 3,
      "page": 158
    },
    {
      "heading": "notification servers.",
      "level": 3,
      "page": 158
    },
    {
      "heading": "Notification servers: They provide the following functionalities:",
      "level": 3,
      "page": 158
    },
    {
      "heading": "• Provide APIs for services to send notifications. Those APIs are only accessible internally",
      "level": 3,
      "page": 158
    },
    {
      "heading": "or by verified clients to prevent spams.",
      "level": 3,
      "page": 158
    },
    {
      "heading": "• Carry out basic validations to verify emails, phone numbers, etc.",
      "level": 3,
      "page": 158
    },
    {
      "heading": "• Query the database or cache to fetch data needed to render a notification.",
      "level": 3,
      "page": 158
    },
    {
      "heading": "• Put notification data to message queues for parallel processing.",
      "level": 3,
      "page": 158
    },
    {
      "heading": "Here is an example of the API to send an email:",
      "level": 3,
      "page": 158
    },
    {
      "heading": "POST https://api.example.com/v/sms/send",
      "level": 3,
      "page": 158
    },
    {
      "heading": "Request body",
      "level": 3,
      "page": 158
    },
    {
      "heading": "Cache: User info, device info, notification templates are cached.",
      "level": 3,
      "page": 159
    },
    {
      "heading": "DB: It stores data about user, notification, settings, etc.",
      "level": 3,
      "page": 159
    },
    {
      "heading": "Message queues: They remove dependencies between components. Message queues serve as",
      "level": 3,
      "page": 159
    },
    {
      "heading": "buffers when high volumes of notifications are to be sent out. Each notification type is",
      "level": 3,
      "page": 159
    },
    {
      "heading": "assigned with a distinct message queue so an outage in one third-party service will not affect",
      "level": 3,
      "page": 159
    },
    {
      "heading": "other notification types.",
      "level": 3,
      "page": 159
    },
    {
      "heading": "send them to the corresponding third-party services.",
      "level": 3,
      "page": 159
    },
    {
      "heading": "Third-party services: Already explained in the initial design.",
      "level": 3,
      "page": 159
    },
    {
      "heading": "iOS, Android, SMS, Email: Already explained in the initial design.",
      "level": 3,
      "page": 159
    },
    {
      "heading": "Next, let us examine how every component works together to send a notification:",
      "level": 3,
      "page": 159
    },
    {
      "heading": "1. A service calls APIs provided by notification servers to send notifications.",
      "level": 3,
      "page": 159
    },
    {
      "heading": "2. Notification servers fetch metadata such as user info, device token, and notification",
      "level": 3,
      "page": 159
    },
    {
      "heading": "setting from the cache or database.",
      "level": 3,
      "page": 159
    },
    {
      "heading": "3. A notification event is sent to the corresponding queue for processing. For instance, an",
      "level": 3,
      "page": 159
    },
    {
      "heading": "iOS push notification event is sent to the iOS PN queue.",
      "level": 3,
      "page": 159
    },
    {
      "heading": "4. Workers pull notification events from message queues.",
      "level": 3,
      "page": 159
    },
    {
      "heading": "5. Workers send notifications to third party services.",
      "level": 3,
      "page": 159
    },
    {
      "heading": "6. Third-party services send notifications to user devices.",
      "level": 3,
      "page": 159
    },
    {
      "heading": "Step 3 - Design deep dive",
      "level": 3,
      "page": 160
    },
    {
      "heading": "In the high-level design, we discussed different types of notifications, contact info gathering",
      "level": 3,
      "page": 160
    },
    {
      "heading": "flow, and notification sending/receiving flow. We will explore the following in deep dive:",
      "level": 3,
      "page": 160
    },
    {
      "heading": "• Reliability.",
      "level": 3,
      "page": 160
    },
    {
      "heading": "• Additional component and considerations: notification template, notification settings,",
      "level": 3,
      "page": 160
    },
    {
      "heading": "and event tracking.",
      "level": 3,
      "page": 160
    },
    {
      "heading": "• Updated design.",
      "level": 3,
      "page": 160
    },
    {
      "heading": "Reliability",
      "level": 3,
      "page": 160
    },
    {
      "heading": "We must answer a few important reliability questions when designing a notification system in",
      "level": 3,
      "page": 160
    },
    {
      "heading": "distributed environments.",
      "level": 3,
      "page": 160
    },
    {
      "heading": "How to prevent data loss?",
      "level": 3,
      "page": 160
    },
    {
      "heading": "One of the most important requirements in a notification system is that it cannot lose data.",
      "level": 3,
      "page": 160
    },
    {
      "heading": "Notifications can usually be delayed or re-ordered, but never lost. To satisfy this requirement,",
      "level": 3,
      "page": 160
    },
    {
      "heading": "the notification system persists notification data in a database and implements a retry",
      "level": 3,
      "page": 160
    },
    {
      "heading": "mechanism. The notification log database is included for data persistence, as shown in Figure",
      "level": 3,
      "page": 160
    },
    {
      "heading": "10-11.",
      "level": 3,
      "page": 160
    },
    {
      "heading": "Will recipients receive a notification exactly once?",
      "level": 3,
      "page": 160
    },
    {
      "heading": "The short answer is no. Although notification is delivered exactly once most of the time, the",
      "level": 3,
      "page": 160
    },
    {
      "heading": "distributed nature could result in duplicate notifications. To reduce the duplication",
      "level": 3,
      "page": 160
    },
    {
      "heading": "occurrence, we introduce a dedupe mechanism and handle each failure case carefully. Here is",
      "level": 3,
      "page": 160
    },
    {
      "heading": "a simple dedupe logic:",
      "level": 3,
      "page": 160
    },
    {
      "heading": "When a notification event first arrives, we check if it is seen before by checking the event ID.",
      "level": 3,
      "page": 160
    },
    {
      "heading": "If it is seen before, it is discarded. Otherwise, we will send out the notification. For interested",
      "level": 3,
      "page": 160
    },
    {
      "heading": "readers to explore why we cannot have exactly once delivery, refer to the reference material",
      "level": 3,
      "page": 160
    },
    {
      "heading": "[5].",
      "level": 3,
      "page": 160
    },
    {
      "heading": "Additional components and considerations",
      "level": 3,
      "page": 160
    },
    {
      "heading": "We have discussed how to collect user contact info, send, and receive a notification. A",
      "level": 3,
      "page": 160
    },
    {
      "heading": "notification system is a lot more than that. Here we discuss additional components including",
      "level": 3,
      "page": 160
    },
    {
      "heading": "Notification template",
      "level": 3,
      "page": 160
    },
    {
      "heading": "A large notification system sends out millions of notifications per day, and many of these",
      "level": 3,
      "page": 161
    },
    {
      "heading": "notifications follow a similar format. Notification templates are introduced to avoid building",
      "level": 3,
      "page": 161
    },
    {
      "heading": "every notification from scratch. A notification template is a preformatted notification to",
      "level": 3,
      "page": 161
    },
    {
      "heading": "create your unique notification by customizing parameters, styling, tracking links, etc. Here is",
      "level": 3,
      "page": 161
    },
    {
      "heading": "an example template of push notifications.",
      "level": 3,
      "page": 161
    },
    {
      "heading": "BODY:",
      "level": 3,
      "page": 161
    },
    {
      "heading": "You dreamed of it. We dared it. [ITEM NAME] is back — only until [DATE].",
      "level": 3,
      "page": 161
    },
    {
      "heading": "CTA:",
      "level": 3,
      "page": 161
    },
    {
      "heading": "Order Now. Or, Save My [ITEM NAME]",
      "level": 3,
      "page": 161
    },
    {
      "heading": "The benefits of using notification templates include maintaining a consistent format, reducing",
      "level": 3,
      "page": 161
    },
    {
      "heading": "the margin error, and saving time.",
      "level": 3,
      "page": 161
    },
    {
      "heading": "Notification setting",
      "level": 3,
      "page": 161
    },
    {
      "heading": "Users generally receive way too many notifications daily and they can easily feel",
      "level": 3,
      "page": 161
    },
    {
      "heading": "overwhelmed. Thus, many websites and apps give users fine-grained control over notification",
      "level": 3,
      "page": 161
    },
    {
      "heading": "settings. This information is stored in the notification setting table, with the following fields:",
      "level": 3,
      "page": 161
    },
    {
      "heading": "user_id   bigInt",
      "level": 3,
      "page": 161
    },
    {
      "heading": "channel  varchar    # push notification, email or SMS",
      "level": 3,
      "page": 161
    },
    {
      "heading": "opt_in   boolean    # opt-in to receive notification",
      "level": 3,
      "page": 161
    },
    {
      "heading": "Before any notification is sent to a user, we first check if a user is opted-in to receive this type",
      "level": 3,
      "page": 161
    },
    {
      "heading": "of notification.",
      "level": 3,
      "page": 161
    },
    {
      "heading": "Rate limiting",
      "level": 3,
      "page": 161
    },
    {
      "heading": "To avoid overwhelming users with too many notifications, we can limit the number of",
      "level": 3,
      "page": 161
    },
    {
      "heading": "notifications a user can receive. This is important because receivers could turn off",
      "level": 3,
      "page": 161
    },
    {
      "heading": "notifications completely if we send too often.",
      "level": 3,
      "page": 161
    },
    {
      "heading": "Retry mechanism",
      "level": 3,
      "page": 161
    },
    {
      "heading": "When a third-party service fails to send a notification, the notification will be added to the",
      "level": 3,
      "page": 161
    },
    {
      "heading": "message queue for retrying. If the problem persists, an alert will be sent out to developers.",
      "level": 3,
      "page": 161
    },
    {
      "heading": "Security in push notifications",
      "level": 3,
      "page": 161
    },
    {
      "heading": "For iOS or Android apps, appKey and appSecret are used to secure push notification APIs",
      "level": 3,
      "page": 161
    },
    {
      "heading": "[6]. Only authenticated or verified clients are allowed to send push notifications using our",
      "level": 3,
      "page": 161
    },
    {
      "heading": "APIs. Interested users should refer to the reference material [6].",
      "level": 3,
      "page": 161
    },
    {
      "heading": "Monitor queued notifications",
      "level": 3,
      "page": 161
    },
    {
      "heading": "A key metric to monitor is the total number of queued notifications. If the number is large,",
      "level": 3,
      "page": 161
    },
    {
      "heading": "the notification events are not processed fast enough by workers. To avoid delay in the",
      "level": 3,
      "page": 161
    },
    {
      "heading": "notification delivery, more workers are needed. Figure 10-12 (credit to [7]) shows an",
      "level": 3,
      "page": 161
    },
    {
      "heading": "example of queued messages to be processed.",
      "level": 3,
      "page": 161
    },
    {
      "heading": "Figure 10-12",
      "level": 3,
      "page": 162
    },
    {
      "heading": "Events tracking",
      "level": 3,
      "page": 162
    },
    {
      "heading": "Notification metrics, such as open rate, click rate, and engagement are important in",
      "level": 3,
      "page": 162
    },
    {
      "heading": "understanding customer behaviors. Analytics service implements events tracking. Integration",
      "level": 3,
      "page": 162
    },
    {
      "heading": "between the notification system and the analytics service is usually required. Figure 10-13",
      "level": 3,
      "page": 162
    },
    {
      "heading": "shows an example of events that might be tracked for analytics purposes.",
      "level": 3,
      "page": 162
    },
    {
      "heading": "Updated design",
      "level": 3,
      "page": 162
    },
    {
      "heading": "Putting everything together, Figure 10-14 shows the updated notification system design.",
      "level": 3,
      "page": 162
    },
    {
      "heading": "In this design, many new components are added in comparison with the previous design.",
      "level": 3,
      "page": 163
    },
    {
      "heading": "• The notification servers are equipped with two more critical features: authentication and",
      "level": 3,
      "page": 163
    },
    {
      "heading": "rate-limiting.",
      "level": 3,
      "page": 163
    },
    {
      "heading": "• We also add a retry mechanism to handle notification failures. If the system fails to send",
      "level": 3,
      "page": 163
    },
    {
      "heading": "notifications, they are put back in the messaging queue and the workers will retry for a",
      "level": 3,
      "page": 163
    },
    {
      "heading": "predefined number of times.",
      "level": 3,
      "page": 163
    },
    {
      "heading": "• Furthermore, notification templates provide a consistent and efficient notification",
      "level": 3,
      "page": 163
    },
    {
      "heading": "creation process.",
      "level": 3,
      "page": 163
    },
    {
      "heading": "• Finally, monitoring and tracking systems are added for system health checks and future",
      "level": 3,
      "page": 163
    },
    {
      "heading": "improvements.",
      "level": 3,
      "page": 163
    },
    {
      "heading": "Step 4 - Wrap up",
      "level": 3,
      "page": 164
    },
    {
      "heading": "Notifications are indispensable because they keep us posted with important information. It",
      "level": 3,
      "page": 164
    },
    {
      "heading": "could be a push notification about your favorite movie on Netflix, an email about discounts",
      "level": 3,
      "page": 164
    },
    {
      "heading": "on new products, or a message about your online shopping payment confirmation.",
      "level": 3,
      "page": 164
    },
    {
      "heading": "In this chapter, we described the design of a scalable notification system that supports",
      "level": 3,
      "page": 164
    },
    {
      "heading": "multiple notification formats: push notification, SMS message, and email. We adopted",
      "level": 3,
      "page": 164
    },
    {
      "heading": "message queues to decouple system components.",
      "level": 3,
      "page": 164
    },
    {
      "heading": "Besides the high-level design, we dug deep into more components and optimizations.",
      "level": 3,
      "page": 164
    },
    {
      "heading": "• Reliability: We proposed a robust retry mechanism to minimize the failure rate.",
      "level": 3,
      "page": 164
    },
    {
      "heading": "• Security: AppKey/appSecret pair is used to ensure only verified clients can send",
      "level": 3,
      "page": 164
    },
    {
      "heading": "notifications.",
      "level": 3,
      "page": 164
    },
    {
      "heading": "• Tracking and monitoring: These are implemented in any stage of a notification flow to",
      "level": 3,
      "page": 164
    },
    {
      "heading": "capture important stats.",
      "level": 3,
      "page": 164
    },
    {
      "heading": "• Respect user settings: Users may opt-out of receiving notifications. Our system checks",
      "level": 3,
      "page": 164
    },
    {
      "heading": "user settings first before sending notifications.",
      "level": 3,
      "page": 164
    },
    {
      "heading": "• Rate limiting: Users will appreciate a frequency capping on the number of notifications",
      "level": 3,
      "page": 164
    },
    {
      "heading": "they receive.",
      "level": 3,
      "page": 164
    },
    {
      "heading": "Congratulations on getting this far! Now give yourself a pat on the back. Good job!",
      "level": 3,
      "page": 164
    },
    {
      "heading": "Reference materials",
      "level": 2,
      "page": 165
    },
    {
      "heading": "[1] Twilio SMS:  https://www.twilio.com/sms",
      "level": 3,
      "page": 165
    },
    {
      "heading": "[2] Nexmo SMS: https://www.nexmo.com/products/sms",
      "level": 3,
      "page": 165
    },
    {
      "heading": "[3] Sendgrid: https://sendgrid.com/",
      "level": 3,
      "page": 165
    },
    {
      "heading": "[4] Mailchimp: https://mailchimp.com/",
      "level": 3,
      "page": 165
    },
    {
      "heading": "[5] You Cannot Have Exactly-Once Delivery: https://bravenewgeek.com/you-cannot-have-",
      "level": 3,
      "page": 165
    },
    {
      "heading": "exactly-once-delivery/",
      "level": 3,
      "page": 165
    },
    {
      "heading": "[6] Security in Push Notifications: https://cloud.ibm.com/docs/services/mobilepush?",
      "level": 3,
      "page": 165
    },
    {
      "heading": "topic=mobile-pushnotification-security-in-push-notifications",
      "level": 3,
      "page": 165
    },
    {
      "heading": "[7] RadditMQ: https://bit.ly/2sotIa6",
      "level": 3,
      "page": 165
    },
    {
      "heading": "CHAPTER 11: DESIGN A NEWS FEED SYSTEM",
      "level": 1,
      "page": 166
    },
    {
      "heading": "In this chapter, you are asked to design a news feed system. What is news feed? According to",
      "level": 3,
      "page": 166
    },
    {
      "heading": "the Facebook help page, “News feed is the constantly updating list of stories in the middle of",
      "level": 3,
      "page": 166
    },
    {
      "heading": "likes from people, pages, and groups that you follow on Facebook” [1]. This is a popular",
      "level": 3,
      "page": 166
    },
    {
      "heading": "interview question. Similar questions commonly asked are: design Facebook news feed,",
      "level": 3,
      "page": 166
    },
    {
      "heading": "Instagram feed, Twitter timeline, etc.",
      "level": 3,
      "page": 166
    },
    {
      "heading": "Step 1 - Understand the problem and establish design scope",
      "level": 3,
      "page": 167
    },
    {
      "heading": "The first set of clarification questions are to understand what the interviewer has in mind",
      "level": 3,
      "page": 167
    },
    {
      "heading": "when she asks you to design a news feed system. At the very least, you should figure out",
      "level": 3,
      "page": 167
    },
    {
      "heading": "what features to support. Here is an example of candidate-interviewer interaction:",
      "level": 3,
      "page": 167
    },
    {
      "heading": "Candidate: Is this a mobile app? Or a web app? Or both?",
      "level": 3,
      "page": 167
    },
    {
      "heading": "Interviewer: Both",
      "level": 3,
      "page": 167
    },
    {
      "heading": "Candidate: What are the important features?",
      "level": 3,
      "page": 167
    },
    {
      "heading": "Candidate: Is the news feed sorted by reverse chronological order or any particular order",
      "level": 3,
      "page": 167
    },
    {
      "heading": "such as topic scores? For instance, posts from your close friends have higher scores.",
      "level": 3,
      "page": 167
    },
    {
      "heading": "Interviewer: To keep things simple, let us assume the feed is sorted by reverse chronological",
      "level": 3,
      "page": 167
    },
    {
      "heading": "order.",
      "level": 3,
      "page": 167
    },
    {
      "heading": "Candidate: How many friends can a user have?",
      "level": 3,
      "page": 167
    },
    {
      "heading": "Interviewer: 5000",
      "level": 3,
      "page": 167
    },
    {
      "heading": "Candidate: What is the traffic volume?",
      "level": 3,
      "page": 167
    },
    {
      "heading": "Interviewer: 10 million DAU",
      "level": 3,
      "page": 167
    },
    {
      "heading": "Candidate: Can feed contain images, videos, or just text?",
      "level": 3,
      "page": 167
    },
    {
      "heading": "Interviewer: It can contain media files, including both images and videos.",
      "level": 3,
      "page": 167
    },
    {
      "heading": "Now you have gathered the requirements, we focus on designing the system.",
      "level": 3,
      "page": 167
    },
    {
      "heading": "Step 2 - Propose high-level design and get buy-in",
      "level": 3,
      "page": 168
    },
    {
      "heading": "The design is divided into two flows: feed publishing and news feed building.",
      "level": 3,
      "page": 168
    },
    {
      "heading": "• Feed publishing: when a user publishes a post, corresponding data is written into cache",
      "level": 3,
      "page": 168
    },
    {
      "heading": "and database. A post is populated to her friends’ news feed.",
      "level": 3,
      "page": 168
    },
    {
      "heading": "• Newsfeed building: for simplicity, let us assume the news feed is built by aggregating",
      "level": 3,
      "page": 168
    },
    {
      "heading": "friends’ posts in reverse chronological order.",
      "level": 3,
      "page": 168
    },
    {
      "heading": "Newsfeed APIs",
      "level": 3,
      "page": 168
    },
    {
      "heading": "The news feed APIs are the primary ways for clients to communicate with servers. Those",
      "level": 3,
      "page": 168
    },
    {
      "heading": "APIs are HTTP based that allow clients to perform actions, which include posting a status,",
      "level": 3,
      "page": 168
    },
    {
      "heading": "retrieving news feed, adding friends, etc. We discuss two most important APIs: feed",
      "level": 3,
      "page": 168
    },
    {
      "heading": "publishing API and news feed retrieval API.",
      "level": 3,
      "page": 168
    },
    {
      "heading": "Feed publishing API",
      "level": 3,
      "page": 168
    },
    {
      "heading": "To publish a post, a HTTP POST request will be sent to the server. The API is shown below:",
      "level": 3,
      "page": 168
    },
    {
      "heading": "POST /v1/me/feed",
      "level": 3,
      "page": 168
    },
    {
      "heading": "Params:",
      "level": 3,
      "page": 168
    },
    {
      "heading": "• content: content is the text of the post.",
      "level": 3,
      "page": 168
    },
    {
      "heading": "• auth_token: it is used to authenticate API requests.",
      "level": 3,
      "page": 168
    },
    {
      "heading": "Newsfeed retrieval API",
      "level": 3,
      "page": 168
    },
    {
      "heading": "The API to retrieve news feed is shown below:",
      "level": 3,
      "page": 168
    },
    {
      "heading": "GET /v1/me/feed",
      "level": 3,
      "page": 168
    },
    {
      "heading": "Params:",
      "level": 3,
      "page": 168
    },
    {
      "heading": "• auth_token: it is used to authenticate API requests.",
      "level": 3,
      "page": 168
    },
    {
      "heading": "Feed publishing",
      "level": 3,
      "page": 168
    },
    {
      "heading": "Figure 11-2 shows the high-level design of the feed publishing flow.",
      "level": 3,
      "page": 168
    },
    {
      "heading": "• User: a user can view news feeds on a browser or mobile app. A user makes a post with",
      "level": 3,
      "page": 169
    },
    {
      "heading": "content “Hello” through API:",
      "level": 3,
      "page": 169
    },
    {
      "heading": "/v1/me/feed?content=Hello&auth_token={auth_token}",
      "level": 3,
      "page": 169
    },
    {
      "heading": "• Load balancer: distribute traffic to web servers.",
      "level": 3,
      "page": 169
    },
    {
      "heading": "• Web servers: web servers redirect traffic to different internal services.",
      "level": 3,
      "page": 169
    },
    {
      "heading": "• Post service: persist post in the database and cache.",
      "level": 3,
      "page": 169
    },
    {
      "heading": "• Fanout service: push new content to friends’ news feed. Newsfeed data is stored in the",
      "level": 3,
      "page": 169
    },
    {
      "heading": "cache for fast retrieval.",
      "level": 3,
      "page": 169
    },
    {
      "heading": "• Notification service: inform friends that new content is available and send out push",
      "level": 3,
      "page": 169
    },
    {
      "heading": "notifications.",
      "level": 3,
      "page": 169
    },
    {
      "heading": "Newsfeed building",
      "level": 3,
      "page": 169
    },
    {
      "heading": "In this section, we discuss how news feed is built behind the scenes. Figure 11-3 shows the",
      "level": 3,
      "page": 169
    },
    {
      "heading": "high-level design:",
      "level": 3,
      "page": 169
    },
    {
      "heading": "• User: a user sends a request to retrieve her news feed. The request looks like this:",
      "level": 3,
      "page": 170
    },
    {
      "heading": "/ v1/me/feed.",
      "level": 3,
      "page": 170
    },
    {
      "heading": "• Load balancer: load balancer redirects traffic to web servers.",
      "level": 3,
      "page": 170
    },
    {
      "heading": "• Web servers: web servers route requests to newsfeed service.",
      "level": 3,
      "page": 170
    },
    {
      "heading": "• Newsfeed service: news feed service fetches news feed from the cache.",
      "level": 3,
      "page": 170
    },
    {
      "heading": "• Newsfeed cache: store news feed IDs needed to render the news feed.",
      "level": 3,
      "page": 170
    },
    {
      "heading": "Step 3 - Design deep dive",
      "level": 3,
      "page": 171
    },
    {
      "heading": "Here, we discuss those topics in more depth.",
      "level": 3,
      "page": 171
    },
    {
      "heading": "Feed publishing deep dive",
      "level": 3,
      "page": 171
    },
    {
      "heading": "Figure 11-4 outlines the detailed design for feed publishing. We have discussed most of",
      "level": 3,
      "page": 171
    },
    {
      "heading": "components in high-level design, and we will focus on two components: web servers and",
      "level": 3,
      "page": 171
    },
    {
      "heading": "fanout service.",
      "level": 3,
      "page": 171
    },
    {
      "heading": "Web servers",
      "level": 3,
      "page": 171
    },
    {
      "heading": "Besides communicating with clients, web servers enforce authentication and rate-limiting.",
      "level": 3,
      "page": 171
    },
    {
      "heading": "Only users signed in with valid auth_token are allowed to make posts. The system limits the",
      "level": 3,
      "page": 172
    },
    {
      "heading": "number of posts a user can make within a certain period, vital to prevent spam and abusive",
      "level": 3,
      "page": 172
    },
    {
      "heading": "content.",
      "level": 3,
      "page": 172
    },
    {
      "heading": "Fanout service",
      "level": 3,
      "page": 172
    },
    {
      "heading": "Fanout is the process of delivering a post to all friends. Two types of fanout models are:",
      "level": 3,
      "page": 172
    },
    {
      "heading": "fanout on write (also called push model) and fanout on read (also called pull model). Both",
      "level": 3,
      "page": 172
    },
    {
      "heading": "models have pros and cons. We explain their workflows and explore the best approach to",
      "level": 3,
      "page": 172
    },
    {
      "heading": "support our system.",
      "level": 3,
      "page": 172
    },
    {
      "heading": "Fanout on write. With this approach, news feed is pre-computed during write time. A new",
      "level": 3,
      "page": 172
    },
    {
      "heading": "post is delivered to friends’ cache immediately after it is published.",
      "level": 3,
      "page": 172
    },
    {
      "heading": "Pros:",
      "level": 3,
      "page": 172
    },
    {
      "heading": "• The news feed is generated in real-time and can be pushed to friends immediately.",
      "level": 3,
      "page": 172
    },
    {
      "heading": "• Fetching news feed is fast because the news feed is pre-computed during write time.",
      "level": 3,
      "page": 172
    },
    {
      "heading": "Cons:",
      "level": 3,
      "page": 172
    },
    {
      "heading": "• If a user has many friends, fetching the friend list and generating news feeds for all of",
      "level": 3,
      "page": 172
    },
    {
      "heading": "them are slow and time consuming. It is called hotkey problem.",
      "level": 3,
      "page": 172
    },
    {
      "heading": "• For inactive users or those rarely log in, pre-computing news feeds waste computing",
      "level": 3,
      "page": 172
    },
    {
      "heading": "resources.",
      "level": 3,
      "page": 172
    },
    {
      "heading": "Fanout on read. The news feed is generated during read time. This is an on-demand model.",
      "level": 3,
      "page": 172
    },
    {
      "heading": "Recent posts are pulled when a user loads her home page.",
      "level": 3,
      "page": 172
    },
    {
      "heading": "Pros:",
      "level": 3,
      "page": 172
    },
    {
      "heading": "• For inactive users or those who rarely log in, fanout on read works better because it will",
      "level": 3,
      "page": 172
    },
    {
      "heading": "not waste computing resources on them.",
      "level": 3,
      "page": 172
    },
    {
      "heading": "• Data is not pushed to friends so there is no hotkey problem.",
      "level": 3,
      "page": 172
    },
    {
      "heading": "Cons:",
      "level": 3,
      "page": 172
    },
    {
      "heading": "• Fetching the news feed is slow as the news feed is not pre-computed.",
      "level": 3,
      "page": 172
    },
    {
      "heading": "We adopt a hybrid approach to get benefits of both approaches and avoid pitfalls in them.",
      "level": 3,
      "page": 172
    },
    {
      "heading": "Since fetching the news feed fast is crucial, we use a push model for the majority of users.",
      "level": 3,
      "page": 172
    },
    {
      "heading": "For celebrities or users who have many friends/followers, we let followers pull news content",
      "level": 3,
      "page": 172
    },
    {
      "heading": "on-demand to avoid system overload. Consistent hashing is a useful technique to mitigate the",
      "level": 3,
      "page": 172
    },
    {
      "heading": "hotkey problem as it helps to distribute requests/data more evenly.",
      "level": 3,
      "page": 172
    },
    {
      "heading": "Let us take a close look at the fanout service as shown in Figure 11-5.",
      "level": 3,
      "page": 172
    },
    {
      "heading": "The fanout service works as follows:",
      "level": 3,
      "page": 173
    },
    {
      "heading": "1. Fetch friend IDs from the graph database. Graph databases are suited for managing",
      "level": 3,
      "page": 173
    },
    {
      "heading": "friend relationship and friend recommendations. Interested readers wishing to learn more",
      "level": 3,
      "page": 173
    },
    {
      "heading": "about this concept should refer to the reference material [2].",
      "level": 3,
      "page": 173
    },
    {
      "heading": "2. Get friends info from the user cache. The system then filters out friends based on user",
      "level": 3,
      "page": 173
    },
    {
      "heading": "settings. For example, if you mute someone, her posts will not show up on your news feed",
      "level": 3,
      "page": 173
    },
    {
      "heading": "even though you are still friends. Another reason why posts may not show is that a user",
      "level": 3,
      "page": 173
    },
    {
      "heading": "could selectively share information with specific friends or hide it from other people.",
      "level": 3,
      "page": 173
    },
    {
      "heading": "3. Send friends list and new post ID to the message queue.",
      "level": 3,
      "page": 173
    },
    {
      "heading": "feed cache. You can think of the news feed cache as a <post_id, user_id> mapping table.",
      "level": 3,
      "page": 173
    },
    {
      "heading": "Whenever a new post is made, it will be appended to the news feed table as shown in",
      "level": 3,
      "page": 173
    },
    {
      "heading": "Figure 11-6. The memory consumption can become very large if we store the entire user",
      "level": 3,
      "page": 173
    },
    {
      "heading": "and post objects in the cache. Thus, only IDs are stored. To keep the memory size small,",
      "level": 3,
      "page": 173
    },
    {
      "heading": "we set a configurable limit. The chance of a user scrolling through thousands of posts in",
      "level": 3,
      "page": 173
    },
    {
      "heading": "news feed is slim. Most users are only interested in the latest content, so the cache miss",
      "level": 3,
      "page": 173
    },
    {
      "heading": "rate is low.",
      "level": 3,
      "page": 173
    },
    {
      "heading": "5. Store <post_id, user_id > in news feed cache. Figure 11-6 shows an example of what",
      "level": 3,
      "page": 173
    },
    {
      "heading": "the news feed looks like in cache.",
      "level": 3,
      "page": 173
    },
    {
      "heading": "Newsfeed retrieval deep dive",
      "level": 3,
      "page": 174
    },
    {
      "heading": "Figure 11-7 illustrates the detailed design for news feed retrieval.",
      "level": 3,
      "page": 174
    },
    {
      "heading": "As shown in Figure 11-7, media content (images, videos, etc.) are stored in CDN for fast",
      "level": 3,
      "page": 174
    },
    {
      "heading": "retrieval. Let us look at how a client retrieves news feed.",
      "level": 3,
      "page": 174
    },
    {
      "heading": "1. A user sends a request to retrieve her news feed. The request looks like this: /v1/me/feed",
      "level": 3,
      "page": 175
    },
    {
      "heading": "2. The load balancer redistributes requests to web servers.",
      "level": 3,
      "page": 175
    },
    {
      "heading": "3. Web servers call the news feed service to fetch news feeds.",
      "level": 3,
      "page": 175
    },
    {
      "heading": "5. A user’s news feed is more than just a list of feed IDs. It contains username, profile",
      "level": 3,
      "page": 175
    },
    {
      "heading": "hydrated news feed.",
      "level": 3,
      "page": 175
    },
    {
      "heading": "6. The fully hydrated news feed is returned in JSON format back to the client for",
      "level": 3,
      "page": 175
    },
    {
      "heading": "rendering.",
      "level": 3,
      "page": 175
    },
    {
      "heading": "Cache architecture",
      "level": 3,
      "page": 175
    },
    {
      "heading": "Cache is extremely important for a news feed system. We divide the cache tier into 5 layers",
      "level": 3,
      "page": 175
    },
    {
      "heading": "as shown in Figure 11-8.",
      "level": 3,
      "page": 175
    },
    {
      "heading": "• News Feed: It stores IDs of news feeds.",
      "level": 3,
      "page": 175
    },
    {
      "heading": "• Content: It stores every post data. Popular content is stored in hot cache.",
      "level": 3,
      "page": 175
    },
    {
      "heading": "• Social Graph: It stores user relationship data.",
      "level": 3,
      "page": 175
    },
    {
      "heading": "• Action: It stores info about whether a user liked a post, replied a post, or took other",
      "level": 3,
      "page": 175
    },
    {
      "heading": "actions on a post.",
      "level": 3,
      "page": 175
    },
    {
      "heading": "• Counters: It stores counters for like, reply, follower, following, etc.",
      "level": 3,
      "page": 175
    },
    {
      "heading": "Step 4 - Wrap up",
      "level": 3,
      "page": 176
    },
    {
      "heading": "In this chapter, we designed a news feed system. Our design contains two flows: feed",
      "level": 3,
      "page": 176
    },
    {
      "heading": "publishing and news feed retrieval.",
      "level": 3,
      "page": 176
    },
    {
      "heading": "Like any system design interview questions, there is no perfect way to design a system. Every",
      "level": 3,
      "page": 176
    },
    {
      "heading": "company has its unique constraints, and you must design a system to fit those constraints.",
      "level": 3,
      "page": 176
    },
    {
      "heading": "Understanding the tradeoffs of your design and technology choices are important. If there are",
      "level": 3,
      "page": 176
    },
    {
      "heading": "a few minutes left, you can talk about scalability issues. To avoid duplicated discussion, only",
      "level": 3,
      "page": 176
    },
    {
      "heading": "high-level talking points are listed below.",
      "level": 3,
      "page": 176
    },
    {
      "heading": "Scaling the database:",
      "level": 3,
      "page": 176
    },
    {
      "heading": "• Vertical scaling vs Horizontal scaling",
      "level": 3,
      "page": 176
    },
    {
      "heading": "• SQL vs NoSQL",
      "level": 3,
      "page": 176
    },
    {
      "heading": "• Master-slave replication",
      "level": 3,
      "page": 176
    },
    {
      "heading": "• Read replicas",
      "level": 3,
      "page": 176
    },
    {
      "heading": "• Consistency models",
      "level": 3,
      "page": 176
    },
    {
      "heading": "• Database sharding",
      "level": 3,
      "page": 176
    },
    {
      "heading": "Other talking points:",
      "level": 3,
      "page": 176
    },
    {
      "heading": "• Keep web tier stateless",
      "level": 3,
      "page": 176
    },
    {
      "heading": "• Cache data as much as you can",
      "level": 3,
      "page": 176
    },
    {
      "heading": "• Support multiple data centers",
      "level": 3,
      "page": 176
    },
    {
      "heading": "• Lose couple components with message queues",
      "level": 3,
      "page": 176
    },
    {
      "heading": "• Monitor key metrics. For instance, QPS during peak hours and latency while users",
      "level": 3,
      "page": 176
    },
    {
      "heading": "refreshing their news feed are interesting to monitor.",
      "level": 3,
      "page": 176
    },
    {
      "heading": "Congratulations on getting this far! Now give yourself a pat on the back. Good job!",
      "level": 3,
      "page": 176
    },
    {
      "heading": "Reference materials",
      "level": 2,
      "page": 177
    },
    {
      "heading": "[1] How News Feed Works:",
      "level": 3,
      "page": 177
    },
    {
      "heading": "https://www.facebook.com/help/327131014036297/",
      "level": 3,
      "page": 177
    },
    {
      "heading": "[2] Friend of Friend recommendations Neo4j and SQL Sever:",
      "level": 3,
      "page": 177
    },
    {
      "heading": "http://geekswithblogs.net/brendonpage/archive/2015/10/26/friend-of-friend-",
      "level": 3,
      "page": 177
    },
    {
      "heading": "recommendations-with-neo4j.aspx",
      "level": 3,
      "page": 177
    },
    {
      "heading": "CHAPTER 12: DESIGN A CHAT SYSTEM",
      "level": 1,
      "page": 178
    },
    {
      "heading": "In this chapter we explore the design of a chat system. Almost everyone uses a chat app.",
      "level": 3,
      "page": 178
    },
    {
      "heading": "Figure 12-1 shows some of the most popular apps in the marketplace.",
      "level": 3,
      "page": 178
    },
    {
      "heading": "A chat app performs different functions for different people. It is extremely important to nail",
      "level": 3,
      "page": 178
    },
    {
      "heading": "down the exact requirements. For example, you do not want to design a system that focuses",
      "level": 3,
      "page": 178
    },
    {
      "heading": "on group chat when the interviewer has one-on-one chat in mind. It is important to explore",
      "level": 3,
      "page": 178
    },
    {
      "heading": "the feature requirements.",
      "level": 3,
      "page": 178
    },
    {
      "heading": "Step 1 - Understand the problem and establish design scope",
      "level": 3,
      "page": 179
    },
    {
      "heading": "It is vital to agree on the type of chat app to design. In the marketplace, there are one-on-one",
      "level": 3,
      "page": 179
    },
    {
      "heading": "chat apps like Facebook Messenger, WeChat, and WhatsApp, office chat apps that focus on",
      "level": 3,
      "page": 179
    },
    {
      "heading": "group chat like Slack, or game chat apps, like Discord, that focus on large group interaction",
      "level": 3,
      "page": 179
    },
    {
      "heading": "and low voice chat latency.",
      "level": 3,
      "page": 179
    },
    {
      "heading": "The first set of clarification questions should nail down what the interviewer has in mind",
      "level": 3,
      "page": 179
    },
    {
      "heading": "exactly when she asks you to design a chat system. At the very least, figure out if you should",
      "level": 3,
      "page": 179
    },
    {
      "heading": "focus on a one-on-one chat or group chat app. Some questions you might ask are as follows:",
      "level": 3,
      "page": 179
    },
    {
      "heading": "Candidate: What kind of chat app shall we design? 1 on 1 or group based?",
      "level": 3,
      "page": 179
    },
    {
      "heading": "Interviewer: It should support both 1 on 1 and group chat.",
      "level": 3,
      "page": 179
    },
    {
      "heading": "Candidate: Is this a mobile app? Or a web app? Or both?",
      "level": 3,
      "page": 179
    },
    {
      "heading": "Interviewer: Both.",
      "level": 3,
      "page": 179
    },
    {
      "heading": "Candidate: What is the scale of this app? A startup app or massive scale?",
      "level": 3,
      "page": 179
    },
    {
      "heading": "Interviewer: It should support 50 million daily active users (DAU).",
      "level": 3,
      "page": 179
    },
    {
      "heading": "Candidate: For group chat, what is the group member limit?",
      "level": 3,
      "page": 179
    },
    {
      "heading": "Interviewer: A maximum of 100 people",
      "level": 3,
      "page": 179
    },
    {
      "heading": "Candidate: What features are important for the chat app? Can it support attachment?",
      "level": 3,
      "page": 179
    },
    {
      "heading": "Interviewer: 1 on 1 chat, group chat, online indicator. The system only supports text",
      "level": 3,
      "page": 179
    },
    {
      "heading": "messages.",
      "level": 3,
      "page": 179
    },
    {
      "heading": "Candidate: Is there a message size limit?",
      "level": 3,
      "page": 179
    },
    {
      "heading": "Interviewer: Yes, text length should be less than 100,000 characters long.",
      "level": 3,
      "page": 179
    },
    {
      "heading": "Candidate: Is end-to-end encryption required?",
      "level": 3,
      "page": 179
    },
    {
      "heading": "Interviewer: Not required for now but we will discuss that if time allows.",
      "level": 3,
      "page": 179
    },
    {
      "heading": "Candidate: How long shall we store the chat history?",
      "level": 3,
      "page": 179
    },
    {
      "heading": "Interviewer: Forever.",
      "level": 3,
      "page": 179
    },
    {
      "heading": "In the chapter, we focus on designing a chat app like Facebook messenger, with an emphasis",
      "level": 3,
      "page": 179
    },
    {
      "heading": "on the following features:",
      "level": 3,
      "page": 179
    },
    {
      "heading": "• A one-on-one chat with low delivery latency",
      "level": 3,
      "page": 179
    },
    {
      "heading": "• Small group chat (max of 100 people)",
      "level": 3,
      "page": 179
    },
    {
      "heading": "• Online presence",
      "level": 3,
      "page": 179
    },
    {
      "heading": "• Multiple device support. The same account can be logged in to multiple accounts at the",
      "level": 3,
      "page": 179
    },
    {
      "heading": "same time.",
      "level": 3,
      "page": 179
    },
    {
      "heading": "• Push notifications",
      "level": 3,
      "page": 179
    },
    {
      "heading": "It is also important to agree on the design scale. We will design a system that supports 50",
      "level": 3,
      "page": 179
    },
    {
      "heading": "million DAU.",
      "level": 3,
      "page": 179
    },
    {
      "heading": "Step 2 - Propose high-level design and get buy-in",
      "level": 3,
      "page": 180
    },
    {
      "heading": "To develop a high-quality design, we should have a basic knowledge of how clients and",
      "level": 3,
      "page": 180
    },
    {
      "heading": "servers communicate. In a chat system, clients can be either mobile applications or web",
      "level": 3,
      "page": 180
    },
    {
      "heading": "applications. Clients do not communicate directly with each other. Instead, each client",
      "level": 3,
      "page": 180
    },
    {
      "heading": "connects to a chat service, which supports all the features mentioned above. Let us focus on",
      "level": 3,
      "page": 180
    },
    {
      "heading": "fundamental operations. The chat service must support the following functions:",
      "level": 3,
      "page": 180
    },
    {
      "heading": "• Receive messages from other clients.",
      "level": 3,
      "page": 180
    },
    {
      "heading": "• Find the right recipients for each message and relay the message to the recipients.",
      "level": 3,
      "page": 180
    },
    {
      "heading": "• If a recipient is not online, hold the messages for that recipient on the server until she is",
      "level": 3,
      "page": 180
    },
    {
      "heading": "online.",
      "level": 3,
      "page": 180
    },
    {
      "heading": "Figure 12-2 shows the relationships between clients (sender and receiver) and the chat",
      "level": 3,
      "page": 180
    },
    {
      "heading": "service.",
      "level": 3,
      "page": 180
    },
    {
      "heading": "When a client intends to start a chat, it connects the chats service using one or more network",
      "level": 3,
      "page": 180
    },
    {
      "heading": "protocols. For a chat service, the choice of network protocols is important. Let us discuss this",
      "level": 3,
      "page": 180
    },
    {
      "heading": "with the interviewer.",
      "level": 3,
      "page": 180
    },
    {
      "heading": "Requests are initiated by the client for most client/server applications. This is also true for the",
      "level": 3,
      "page": 180
    },
    {
      "heading": "sender side of a chat application. In Figure 12-2, when the sender sends a message to the",
      "level": 3,
      "page": 180
    },
    {
      "heading": "receiver via the chat service, it uses the time-tested HTTP protocol, which is the most",
      "level": 3,
      "page": 180
    },
    {
      "heading": "common web protocol. In this scenario, the client opens a HTTP connection with the chat",
      "level": 3,
      "page": 180
    },
    {
      "heading": "service and sends the message, informing the service to send the message to the receiver. The",
      "level": 3,
      "page": 180
    },
    {
      "heading": "keep-alive is efficient for this because the keep-alive header allows a client to maintain a",
      "level": 3,
      "page": 180
    },
    {
      "heading": "persistent connection with the chat service. It also reduces the number of TCP handshakes.",
      "level": 3,
      "page": 180
    },
    {
      "heading": "HTTP is a fine option on the sender side, and many popular chat applications such as",
      "level": 3,
      "page": 180
    },
    {
      "heading": "Facebook [1] used HTTP initially to send messages.",
      "level": 3,
      "page": 180
    },
    {
      "heading": "However, the receiver side is a bit more complicated. Since HTTP is client-initiated, it is not",
      "level": 3,
      "page": 180
    },
    {
      "heading": "trivial to send messages from the server. Over the years, many techniques are used to",
      "level": 3,
      "page": 180
    },
    {
      "heading": "simulate a server-initiated connection: polling, long polling, and WebSocket. Those are",
      "level": 3,
      "page": 180
    },
    {
      "heading": "important techniques widely used in system design interviews so let us examine each of",
      "level": 3,
      "page": 180
    },
    {
      "heading": "them.",
      "level": 3,
      "page": 180
    },
    {
      "heading": "Polling",
      "level": 3,
      "page": 180
    },
    {
      "heading": "As shown in Figure 12-3, polling is a technique that the client periodically asks the server if",
      "level": 3,
      "page": 180
    },
    {
      "heading": "there are messages available. Depending on polling frequency, polling could be costly. It",
      "level": 3,
      "page": 180
    },
    {
      "heading": "could consume precious server resources to answer a question that offers no as an answer",
      "level": 3,
      "page": 180
    },
    {
      "heading": "most of the time.",
      "level": 3,
      "page": 180
    },
    {
      "heading": "Long polling",
      "level": 3,
      "page": 181
    },
    {
      "heading": "Because polling could be inefficient, the next progression is long polling (Figure 12-4).",
      "level": 3,
      "page": 181
    },
    {
      "heading": "In long polling, a client holds the connection open until there are actually new messages",
      "level": 3,
      "page": 182
    },
    {
      "heading": "available or a timeout threshold has been reached. Once the client receives new messages, it",
      "level": 3,
      "page": 182
    },
    {
      "heading": "immediately sends another request to the server, restarting the process. Long polling has a",
      "level": 3,
      "page": 182
    },
    {
      "heading": "few drawbacks:",
      "level": 3,
      "page": 182
    },
    {
      "heading": "• Sender and receiver may not connect to the same chat server. HTTP based servers are",
      "level": 3,
      "page": 182
    },
    {
      "heading": "usually stateless. If you use round robin for load balancing, the server that receives the",
      "level": 3,
      "page": 182
    },
    {
      "heading": "message might not have a long-polling connection with the client who receives the",
      "level": 3,
      "page": 182
    },
    {
      "heading": "message.",
      "level": 3,
      "page": 182
    },
    {
      "heading": "• A server has no good way to tell if a client is disconnected.",
      "level": 3,
      "page": 182
    },
    {
      "heading": "• It is inefficient. If a user does not chat much, long polling still makes periodic",
      "level": 3,
      "page": 182
    },
    {
      "heading": "connections after timeouts.",
      "level": 3,
      "page": 182
    },
    {
      "heading": "WebSocket",
      "level": 3,
      "page": 182
    },
    {
      "heading": "WebSocket is the most common solution for sending asynchronous updates from server to",
      "level": 3,
      "page": 182
    },
    {
      "heading": "client. Figure 12-5 shows how it works.",
      "level": 3,
      "page": 182
    },
    {
      "heading": "WebSocket connection is initiated by the client. It is bi-directional and persistent. It starts its",
      "level": 3,
      "page": 183
    },
    {
      "heading": "life as a HTTP connection and could be “upgraded” via some well-defined handshake to a",
      "level": 3,
      "page": 183
    },
    {
      "heading": "WebSocket connection. Through this persistent connection, a server could send updates to a",
      "level": 3,
      "page": 183
    },
    {
      "heading": "client. WebSocket connections generally work even if a firewall is in place. This is because",
      "level": 3,
      "page": 183
    },
    {
      "heading": "they use port 80 or 443 which are also used by HTTP/HTTPS connections.",
      "level": 3,
      "page": 183
    },
    {
      "heading": "Earlier we said that on the sender side HTTP is a fine protocol to use, but since WebSocket is",
      "level": 3,
      "page": 183
    },
    {
      "heading": "bidirectional, there is no strong technical reason not to use it also for sending. Figure 12-6",
      "level": 3,
      "page": 183
    },
    {
      "heading": "shows how WebSockets (ws) is used for both sender and receiver sides.",
      "level": 3,
      "page": 183
    },
    {
      "heading": "By using WebSocket for both sending and receiving, it simplifies the design and makes",
      "level": 3,
      "page": 183
    },
    {
      "heading": "implementation on both client and server more straightforward. Since WebSocket",
      "level": 3,
      "page": 183
    },
    {
      "heading": "connections are persistent, efficient connection management is critical on the server-side.",
      "level": 3,
      "page": 183
    },
    {
      "heading": "High-level design",
      "level": 3,
      "page": 184
    },
    {
      "heading": "Just now we mentioned that WebSocket was chosen as the main communication protocol",
      "level": 3,
      "page": 184
    },
    {
      "heading": "between the client and server for its bidirectional communication, it is important to note that",
      "level": 3,
      "page": 184
    },
    {
      "heading": "everything else does not have to be WebSocket. In fact, most features (sign up, login, user",
      "level": 3,
      "page": 184
    },
    {
      "heading": "profile, etc) of a chat application could use the traditional request/response method over",
      "level": 3,
      "page": 184
    },
    {
      "heading": "HTTP. Let us drill in a bit and look at the high-level components of the system.",
      "level": 3,
      "page": 184
    },
    {
      "heading": "As shown in Figure 12-7, the chat system is broken down into three major categories:",
      "level": 3,
      "page": 184
    },
    {
      "heading": "stateless services, stateful services, and third-party integration.",
      "level": 3,
      "page": 184
    },
    {
      "heading": "Stateless Services",
      "level": 3,
      "page": 184
    },
    {
      "heading": "Stateless services are traditional public-facing request/response services, used to manage the",
      "level": 3,
      "page": 184
    },
    {
      "heading": "login, signup, user profile, etc. These are common features among many websites and apps.",
      "level": 3,
      "page": 184
    },
    {
      "heading": "Stateless services sit behind a load balancer whose job is to route requests to the correct",
      "level": 3,
      "page": 184
    },
    {
      "heading": "services based on the request paths. These services can be monolithic or individual",
      "level": 3,
      "page": 184
    },
    {
      "heading": "microservices. We do not need to build many of these stateless services by ourselves as there",
      "level": 3,
      "page": 185
    },
    {
      "heading": "are services in the market that can be integrated easily. The one service that we will discuss",
      "level": 3,
      "page": 185
    },
    {
      "heading": "more in deep dive is the service discovery. Its primary job is to give the client a list of DNS",
      "level": 3,
      "page": 185
    },
    {
      "heading": "host names of chat servers that the client could connect to.",
      "level": 3,
      "page": 185
    },
    {
      "heading": "Stateful Service",
      "level": 3,
      "page": 185
    },
    {
      "heading": "The only stateful service is the chat service. The service is stateful because each client",
      "level": 3,
      "page": 185
    },
    {
      "heading": "maintains a persistent network connection to a chat server. In this service, a client normally",
      "level": 3,
      "page": 185
    },
    {
      "heading": "does not switch to another chat server as long as the server is still available. The service",
      "level": 3,
      "page": 185
    },
    {
      "heading": "discovery coordinates closely with the chat service to avoid server overloading. We will go",
      "level": 3,
      "page": 185
    },
    {
      "heading": "into detail in deep dive.",
      "level": 3,
      "page": 185
    },
    {
      "heading": "Third-party integration",
      "level": 3,
      "page": 185
    },
    {
      "heading": "For a chat app, push notification is the most important third-party integration. It is a way to",
      "level": 3,
      "page": 185
    },
    {
      "heading": "inform users when new messages have arrived, even when the app is not running. Proper",
      "level": 3,
      "page": 185
    },
    {
      "heading": "integration of push notification is crucial. Refer to Chapter 10 Design a notification system",
      "level": 3,
      "page": 185
    },
    {
      "heading": "for more information.",
      "level": 3,
      "page": 185
    },
    {
      "heading": "Scalability",
      "level": 3,
      "page": 185
    },
    {
      "heading": "On a small scale, all services listed above could fit in one server. Even at the scale we design",
      "level": 3,
      "page": 185
    },
    {
      "heading": "for, it is in theory possible to fit all user connections in one modern cloud server. The number",
      "level": 3,
      "page": 185
    },
    {
      "heading": "of concurrent connections that a server can handle will most likely be the limiting factor. In",
      "level": 3,
      "page": 185
    },
    {
      "heading": "our scenario, at 1M concurrent users, assuming each user connection needs 10K of memory",
      "level": 3,
      "page": 185
    },
    {
      "heading": "on the server (this is a very rough figure and very dependent on the language choice), it only",
      "level": 3,
      "page": 185
    },
    {
      "heading": "needs about 10GB of memory to hold all the connections on one box.",
      "level": 3,
      "page": 185
    },
    {
      "heading": "If we propose a design where everything fits in one server, this may raise a big red flag in the",
      "level": 3,
      "page": 185
    },
    {
      "heading": "interviewer’s mind. No technologist would design such a scale in a single server. Single",
      "level": 3,
      "page": 185
    },
    {
      "heading": "server design is a deal breaker due to many factors. The single point of failure is the biggest",
      "level": 3,
      "page": 185
    },
    {
      "heading": "among them.",
      "level": 3,
      "page": 185
    },
    {
      "heading": "However, it is perfectly fine to start with a single server design. Just make sure the",
      "level": 3,
      "page": 185
    },
    {
      "heading": "interviewer knows this is a starting point. Putting everything we mentioned together, Figure",
      "level": 3,
      "page": 185
    },
    {
      "heading": "12-8 shows the adjusted high-level design.",
      "level": 3,
      "page": 185
    },
    {
      "heading": "In Figure 12-8, the client maintains a persistent WebSocket connection to a chat server for",
      "level": 3,
      "page": 186
    },
    {
      "heading": "real-time messaging.",
      "level": 3,
      "page": 186
    },
    {
      "heading": "• Chat servers facilitate message sending/receiving.",
      "level": 3,
      "page": 186
    },
    {
      "heading": "• Presence servers manage online/offline status.",
      "level": 3,
      "page": 186
    },
    {
      "heading": "• API servers handle everything including user login, signup, change profile, etc.",
      "level": 3,
      "page": 186
    },
    {
      "heading": "• Notification servers send push notifications.",
      "level": 3,
      "page": 186
    },
    {
      "heading": "• Finally, the key-value store is used to store chat history. When an offline user comes",
      "level": 3,
      "page": 186
    },
    {
      "heading": "online, she will see all her previous chat history.",
      "level": 3,
      "page": 186
    },
    {
      "heading": "Storage",
      "level": 3,
      "page": 186
    },
    {
      "heading": "At this point, we have servers ready, services up running and third-party integrations",
      "level": 3,
      "page": 186
    },
    {
      "heading": "complete. Deep down the technical stack is the data layer. Data layer usually requires some",
      "level": 3,
      "page": 186
    },
    {
      "heading": "effort to get it correct. An important decision we must make is to decide on the right type of",
      "level": 3,
      "page": 186
    },
    {
      "heading": "database to use: relational databases or NoSQL databases? To make an informed decision, we",
      "level": 3,
      "page": 186
    },
    {
      "heading": "will examine the data types and read/write patterns.",
      "level": 3,
      "page": 187
    },
    {
      "heading": "Two types of data exist in a typical chat system. The first is generic data, such as user profile,",
      "level": 3,
      "page": 187
    },
    {
      "heading": "setting, user friends list. These data are stored in robust and reliable relational databases.",
      "level": 3,
      "page": 187
    },
    {
      "heading": "Replication and sharding are common techniques to satisfy availability and scalability",
      "level": 3,
      "page": 187
    },
    {
      "heading": "requirements.",
      "level": 3,
      "page": 187
    },
    {
      "heading": "The second is unique to chat systems: chat history data. It is important to understand the",
      "level": 3,
      "page": 187
    },
    {
      "heading": "read/write pattern.",
      "level": 3,
      "page": 187
    },
    {
      "heading": "• The amount of data is enormous for chat systems. A previous study [2] reveals that",
      "level": 3,
      "page": 187
    },
    {
      "heading": "Facebook messenger and Whatsapp process 60 billion messages a day.",
      "level": 3,
      "page": 187
    },
    {
      "heading": "• Only recent chats are accessed frequently. Users do not usually look up for old chats.",
      "level": 3,
      "page": 187
    },
    {
      "heading": "• Although very recent chat history is viewed in most cases, users might use features that",
      "level": 3,
      "page": 187
    },
    {
      "heading": "require random access of data, such as search, view your mentions, jump to specific",
      "level": 3,
      "page": 187
    },
    {
      "heading": "messages, etc. These cases should be supported by the data access layer.",
      "level": 3,
      "page": 187
    },
    {
      "heading": "• The read to write ratio is about 1:1 for 1 on 1 chat apps.",
      "level": 3,
      "page": 187
    },
    {
      "heading": "Selecting the correct storage system that supports all of our use cases is crucial. We",
      "level": 3,
      "page": 187
    },
    {
      "heading": "recommend key-value stores for the following reasons:",
      "level": 3,
      "page": 187
    },
    {
      "heading": "• Key-value stores allow easy horizontal scaling.",
      "level": 3,
      "page": 187
    },
    {
      "heading": "• Key-value stores provide very low latency to access data.",
      "level": 3,
      "page": 187
    },
    {
      "heading": "• Relational databases do not handle long tail [3] of data well. When the indexes grow",
      "level": 3,
      "page": 187
    },
    {
      "heading": "large, random access is expensive.",
      "level": 3,
      "page": 187
    },
    {
      "heading": "• Key-value stores are adopted by other proven reliable chat applications. For example,",
      "level": 3,
      "page": 187
    },
    {
      "heading": "both Facebook messenger and Discord use key-value stores. Facebook messenger uses",
      "level": 3,
      "page": 187
    },
    {
      "heading": "HBase [4], and Discord uses Cassandra [5].",
      "level": 3,
      "page": 187
    },
    {
      "heading": "Data models",
      "level": 3,
      "page": 187
    },
    {
      "heading": "Just now, we talked about using key-value stores as our storage layer. The most important",
      "level": 3,
      "page": 187
    },
    {
      "heading": "data is message data. Let us take a close look.",
      "level": 3,
      "page": 187
    },
    {
      "heading": "Message table for 1 on 1 chat",
      "level": 3,
      "page": 187
    },
    {
      "heading": "Figure 12-9 shows the message table for 1 on 1 chat. The primary key is message_id, which",
      "level": 3,
      "page": 187
    },
    {
      "heading": "helps to decide message sequence. We cannot rely on created_at  to decide the message",
      "level": 3,
      "page": 187
    },
    {
      "heading": "sequence because two messages can be created at the same time.",
      "level": 3,
      "page": 187
    },
    {
      "heading": "Message table for group chat",
      "level": 3,
      "page": 188
    },
    {
      "heading": "Figure 12-10 shows the message table for group chat. The composite primary key is",
      "level": 3,
      "page": 188
    },
    {
      "heading": "(channel_id, message_id). Channel and group represent the same meaning here. channel_id",
      "level": 3,
      "page": 188
    },
    {
      "heading": "is the partition key because all queries in a group chat operate in a channel.",
      "level": 3,
      "page": 188
    },
    {
      "heading": "Message ID",
      "level": 3,
      "page": 188
    },
    {
      "heading": "How to generate message_id is an interesting topic worth exploring. Message_id carries the",
      "level": 3,
      "page": 189
    },
    {
      "heading": "responsibility of ensuring the order of messages. To ascertain the order of messages,",
      "level": 3,
      "page": 189
    },
    {
      "heading": "message_id must satisfy the following two requirements:",
      "level": 3,
      "page": 189
    },
    {
      "heading": "• IDs must be unique.",
      "level": 3,
      "page": 189
    },
    {
      "heading": "• IDs should be sortable by time, meaning new rows have higher IDs than old ones.",
      "level": 3,
      "page": 189
    },
    {
      "heading": "How can we achieve those two guarantees? The first idea that comes to mind is the",
      "level": 3,
      "page": 189
    },
    {
      "heading": "“auto_increment” keyword in MySql. However, NoSQL databases usually do not provide",
      "level": 3,
      "page": 189
    },
    {
      "heading": "such a feature.",
      "level": 3,
      "page": 189
    },
    {
      "heading": "The second approach is to use a global 64-bit sequence number generator like Snowflake [6].",
      "level": 3,
      "page": 189
    },
    {
      "heading": "This is discussed in “Chapter 7: Design a unique ID generator in a distributed system”.",
      "level": 3,
      "page": 189
    },
    {
      "heading": "The final approach is to use local sequence number generator. Local means IDs are only",
      "level": 3,
      "page": 189
    },
    {
      "heading": "unique within a group. The reason why local IDs work is that maintaining message sequence",
      "level": 3,
      "page": 189
    },
    {
      "heading": "within one-on-one channel or a group channel is sufficient. This approach is easier to",
      "level": 3,
      "page": 189
    },
    {
      "heading": "implement in comparison to the global ID implementation.",
      "level": 3,
      "page": 189
    },
    {
      "heading": "Step 3 - Design deep dive",
      "level": 3,
      "page": 190
    },
    {
      "heading": "In a system design interview, usually you are expected to dive deep into some of the",
      "level": 3,
      "page": 190
    },
    {
      "heading": "components in the high-level design. For the chat system, service discovery, messaging",
      "level": 3,
      "page": 190
    },
    {
      "heading": "flows, and online/offline indicators worth deeper exploration.",
      "level": 3,
      "page": 190
    },
    {
      "heading": "Service discovery",
      "level": 3,
      "page": 190
    },
    {
      "heading": "The primary role of service discovery is to recommend the best chat server for a client based",
      "level": 3,
      "page": 190
    },
    {
      "heading": "on the criteria like geographical location, server capacity, etc. Apache Zookeeper [7] is a",
      "level": 3,
      "page": 190
    },
    {
      "heading": "popular open-source solution for service discovery. It registers all the available chat servers",
      "level": 3,
      "page": 190
    },
    {
      "heading": "and picks the best chat server for a client based on predefined criteria.",
      "level": 3,
      "page": 190
    },
    {
      "heading": "Figure 12-11 shows how service discovery (Zookeeper) works.",
      "level": 3,
      "page": 190
    },
    {
      "heading": "1. User A tries to log in to the app.",
      "level": 3,
      "page": 190
    },
    {
      "heading": "2. The load balancer sends the login request to API servers.",
      "level": 3,
      "page": 190
    },
    {
      "heading": "3. After the backend authenticates the user, service discovery finds the best chat server for",
      "level": 3,
      "page": 190
    },
    {
      "heading": "User A. In this example, server 2 is chosen and the server info is returned back to User A.",
      "level": 3,
      "page": 190
    },
    {
      "heading": "4. User A connects to chat server 2 through WebSocket.",
      "level": 3,
      "page": 190
    },
    {
      "heading": "Message flows",
      "level": 3,
      "page": 190
    },
    {
      "heading": "It is interesting to understand the end-to-end flow of a chat system. In this section, we will",
      "level": 3,
      "page": 190
    },
    {
      "heading": "explore 1 on 1 chat flow, message synchronization across multiple devices and group chat",
      "level": 3,
      "page": 191
    },
    {
      "heading": "flow.",
      "level": 3,
      "page": 191
    },
    {
      "heading": "1 on 1 chat flow",
      "level": 3,
      "page": 191
    },
    {
      "heading": "Figure 12-12 explains what happens when User A sends a message to User B.",
      "level": 3,
      "page": 191
    },
    {
      "heading": "1. User A sends a chat message to Chat server 1.",
      "level": 3,
      "page": 191
    },
    {
      "heading": "2. Chat server 1 obtains a message ID from the ID generator.",
      "level": 3,
      "page": 191
    },
    {
      "heading": "3. Chat server 1 sends the message to the message sync queue.",
      "level": 3,
      "page": 191
    },
    {
      "heading": "4. The message is stored in a key-value store.",
      "level": 3,
      "page": 191
    },
    {
      "heading": "5.a. If User B is online, the message is forwarded to Chat server 2 where User B is",
      "level": 3,
      "page": 191
    },
    {
      "heading": "connected.",
      "level": 3,
      "page": 191
    },
    {
      "heading": "5.b. If User B is offline, a push notification is sent from push notification (PN) servers.",
      "level": 3,
      "page": 191
    },
    {
      "heading": "6. Chat server 2 forwards the message to User B. There is a persistent WebSocket",
      "level": 3,
      "page": 191
    },
    {
      "heading": "connection between User B and Chat server 2.",
      "level": 3,
      "page": 191
    },
    {
      "heading": "Message synchronization across multiple devices",
      "level": 3,
      "page": 191
    },
    {
      "heading": "Many users have multiple devices. We will explain how to sync messages across multiple",
      "level": 3,
      "page": 191
    },
    {
      "heading": "devices. Figure 12-13 shows an example of message synchronization.",
      "level": 3,
      "page": 191
    },
    {
      "heading": "In Figure 12-13, user A has two devices: a phone and a laptop. When User A logs in to the",
      "level": 3,
      "page": 192
    },
    {
      "heading": "chat app with her phone, it establishes a WebSocket connection with Chat server 1. Similarly,",
      "level": 3,
      "page": 192
    },
    {
      "heading": "there is a connection between the laptop and Chat server 1.",
      "level": 3,
      "page": 192
    },
    {
      "heading": "Each device maintains a variable called cur_max_message_id, which keeps track of the latest",
      "level": 3,
      "page": 192
    },
    {
      "heading": "message ID on the device. Messages that satisfy the following two conditions are considered",
      "level": 3,
      "page": 192
    },
    {
      "heading": "as news messages:",
      "level": 3,
      "page": 192
    },
    {
      "heading": "• The recipient ID is equal to the currently logged-in user ID.",
      "level": 3,
      "page": 192
    },
    {
      "heading": "• Message ID in the key-value store is larger than cur_max_message_id .",
      "level": 3,
      "page": 192
    },
    {
      "heading": "With distinct cur_max_message_id on each device, message synchronization is easy as each",
      "level": 3,
      "page": 192
    },
    {
      "heading": "device can get new messages from the KV store.",
      "level": 3,
      "page": 192
    },
    {
      "heading": "Small group chat flow",
      "level": 3,
      "page": 192
    },
    {
      "heading": "In comparison to the one-on-one chat, the logic of group chat is more complicated. Figures",
      "level": 3,
      "page": 192
    },
    {
      "heading": "12-14 and 12-15 explain the flow.",
      "level": 3,
      "page": 192
    },
    {
      "heading": "Figure 12-14 explains what happens when User A sends a message in a group chat. Assume",
      "level": 3,
      "page": 193
    },
    {
      "heading": "there are 3 members in the group (User A, User B and user C). First, the message from User",
      "level": 3,
      "page": 193
    },
    {
      "heading": "A is copied to each group member’s message sync queue: one for User B and the second for",
      "level": 3,
      "page": 193
    },
    {
      "heading": "User C. You can think of the message sync queue as an inbox for a recipient. This design",
      "level": 3,
      "page": 193
    },
    {
      "heading": "choice is good for small group chat because:",
      "level": 3,
      "page": 193
    },
    {
      "heading": "• it simplifies message sync flow as each client only needs to check its own inbox to get",
      "level": 3,
      "page": 193
    },
    {
      "heading": "new messages.",
      "level": 3,
      "page": 193
    },
    {
      "heading": "• when the group number is small, storing a copy in each recipient’s inbox is not too",
      "level": 3,
      "page": 193
    },
    {
      "heading": "expensive.",
      "level": 3,
      "page": 193
    },
    {
      "heading": "WeChat uses a similar approach, and it limits a group to 500 members [8]. However, for",
      "level": 3,
      "page": 193
    },
    {
      "heading": "groups with a lot of users, storing a message copy for each member is not acceptable.",
      "level": 3,
      "page": 193
    },
    {
      "heading": "On the recipient side, a recipient can receive messages from multiple users. Each recipient",
      "level": 3,
      "page": 193
    },
    {
      "heading": "has an inbox (message sync queue) which contains messages from different senders. Figure",
      "level": 3,
      "page": 193
    },
    {
      "heading": "12-15 illustrates the design.",
      "level": 3,
      "page": 193
    },
    {
      "heading": "Online presence",
      "level": 3,
      "page": 194
    },
    {
      "heading": "An online presence indicator is an essential feature of many chat applications. Usually, you",
      "level": 3,
      "page": 194
    },
    {
      "heading": "can see a green dot next to a user’s profile picture or username. This section explains what",
      "level": 3,
      "page": 194
    },
    {
      "heading": "happens behind the scenes.",
      "level": 3,
      "page": 194
    },
    {
      "heading": "In the high-level design, presence servers are responsible for managing online status and",
      "level": 3,
      "page": 194
    },
    {
      "heading": "communicating with clients through WebSocket. There are a few flows that will trigger",
      "level": 3,
      "page": 194
    },
    {
      "heading": "online status change. Let us examine each of them.",
      "level": 3,
      "page": 194
    },
    {
      "heading": "User login",
      "level": 3,
      "page": 194
    },
    {
      "heading": "The user login flow is explained in the “Service Discovery” section. After a WebSocket",
      "level": 3,
      "page": 194
    },
    {
      "heading": "connection is built between the client and the real-time service, user A’s online status and",
      "level": 3,
      "page": 194
    },
    {
      "heading": "last_active_at  timestamp are saved in the KV store. Presence indicator shows the user is",
      "level": 3,
      "page": 194
    },
    {
      "heading": "online after she logs in.",
      "level": 3,
      "page": 194
    },
    {
      "heading": "User logout",
      "level": 3,
      "page": 195
    },
    {
      "heading": "When a user logs out, it goes through the user logout flow as shown in Figure 12-17. The",
      "level": 3,
      "page": 195
    },
    {
      "heading": "online status is changed to offline in the KV store. The presence indicator shows a user is",
      "level": 3,
      "page": 195
    },
    {
      "heading": "offline.",
      "level": 3,
      "page": 195
    },
    {
      "heading": "User disconnection",
      "level": 3,
      "page": 195
    },
    {
      "heading": "We all wish our internet connection is consistent and reliable. However, that is not always the",
      "level": 3,
      "page": 195
    },
    {
      "heading": "case; thus, we must address this issue in our design. When a user disconnects from the",
      "level": 3,
      "page": 195
    },
    {
      "heading": "internet, the persistent connection between the client and server is lost. A naive way to handle",
      "level": 3,
      "page": 195
    },
    {
      "heading": "user disconnection is to mark the user as offline and change the status to online when the",
      "level": 3,
      "page": 195
    },
    {
      "heading": "connection re-establishes. However, this approach has a major flaw. It is common for users to",
      "level": 3,
      "page": 195
    },
    {
      "heading": "disconnect and reconnect to the internet frequently in a short time. For example, network",
      "level": 3,
      "page": 195
    },
    {
      "heading": "connections can be on and off while a user goes through a tunnel. Updating online status on",
      "level": 3,
      "page": 195
    },
    {
      "heading": "every disconnect/reconnect would make the presence indicator change too often, resulting in",
      "level": 3,
      "page": 195
    },
    {
      "heading": "poor user experience.",
      "level": 3,
      "page": 195
    },
    {
      "heading": "We introduce a heartbeat mechanism to solve this problem. Periodically, an online client",
      "level": 3,
      "page": 195
    },
    {
      "heading": "sends a heartbeat event to presence servers. If presence servers receive a heartbeat event",
      "level": 3,
      "page": 195
    },
    {
      "heading": "within a certain time, say x seconds from the client, a user is considered as online. Otherwise,",
      "level": 3,
      "page": 195
    },
    {
      "heading": "it is offline.",
      "level": 3,
      "page": 195
    },
    {
      "heading": "In Figure 12-18, the client sends a heartbeat event to the server every 5 seconds. After",
      "level": 3,
      "page": 195
    },
    {
      "heading": "sending 3 heartbeat events, the client is disconnected and does not reconnect within  x = 30",
      "level": 3,
      "page": 195
    },
    {
      "heading": "seconds (This number is arbitrarily chosen to demonstrate the logic). The online status is",
      "level": 3,
      "page": 195
    },
    {
      "heading": "changed to offline.",
      "level": 3,
      "page": 195
    },
    {
      "heading": "Online status fanout",
      "level": 3,
      "page": 196
    },
    {
      "heading": "How do user A’s friends know about the status changes? Figure 12-19 explains how it works.",
      "level": 3,
      "page": 196
    },
    {
      "heading": "Presence servers use a publish-subscribe model, in which each friend pair maintains a",
      "level": 3,
      "page": 196
    },
    {
      "heading": "channel. When User A’s online status changes, it publishes the event to three channels,",
      "level": 3,
      "page": 196
    },
    {
      "heading": "channel A-B, A-C, and A-D. Those three channels are subscribed by User B, C, and D,",
      "level": 3,
      "page": 196
    },
    {
      "heading": "respectively. Thus, it is easy for friends to get online status updates. The communication",
      "level": 3,
      "page": 196
    },
    {
      "heading": "between clients and servers is through real-time WebSocket.",
      "level": 3,
      "page": 196
    },
    {
      "heading": "The above design is effective for a small user group. For instance, WeChat uses a similar",
      "level": 3,
      "page": 197
    },
    {
      "heading": "approach because its user group is capped to 500. For larger groups, informing all members",
      "level": 3,
      "page": 197
    },
    {
      "heading": "about online status is expensive and time consuming. Assume a group has 100,000 members.",
      "level": 3,
      "page": 197
    },
    {
      "heading": "Each status change will generate 100,000 events. To solve the performance bottleneck, a",
      "level": 3,
      "page": 197
    },
    {
      "heading": "possible solution is to fetch online status only when a user enters a group or manually",
      "level": 3,
      "page": 197
    },
    {
      "heading": "refreshes the friend list.",
      "level": 3,
      "page": 197
    },
    {
      "heading": "Step 4 - Wrap up",
      "level": 3,
      "page": 198
    },
    {
      "heading": "In this chapter, we presented a chat system architecture that supports both 1-to-1 chat and",
      "level": 3,
      "page": 198
    },
    {
      "heading": "small group chat. WebSocket is used for real-time communication between the client and",
      "level": 3,
      "page": 198
    },
    {
      "heading": "server. The chat system contains the following components: chat servers for real-time",
      "level": 3,
      "page": 198
    },
    {
      "heading": "messaging, presence servers for managing online presence, push notification servers for",
      "level": 3,
      "page": 198
    },
    {
      "heading": "other functionalities.",
      "level": 3,
      "page": 198
    },
    {
      "heading": "If you have extra time at the end of the interview, here are additional talking points:",
      "level": 3,
      "page": 198
    },
    {
      "heading": "significantly larger than text in size. Compression, cloud storage, and thumbnails are",
      "level": 3,
      "page": 198
    },
    {
      "heading": "interesting topics to talk about.",
      "level": 3,
      "page": 198
    },
    {
      "heading": "sender and the recipient can read messages. Interested readers should refer to the article in",
      "level": 3,
      "page": 198
    },
    {
      "heading": "the reference materials [9].",
      "level": 3,
      "page": 198
    },
    {
      "heading": "• Caching messages on the client-side is effective to reduce the data transfer between the",
      "level": 3,
      "page": 198
    },
    {
      "heading": "client and server.",
      "level": 3,
      "page": 198
    },
    {
      "heading": "• Improve load time. Slack built a geographically distributed network to cache users’ data,",
      "level": 3,
      "page": 198
    },
    {
      "heading": "channels, etc. for better load time [10].",
      "level": 3,
      "page": 198
    },
    {
      "heading": "• Error handling.",
      "level": 3,
      "page": 198
    },
    {
      "heading": "• The chat server error. There might be hundreds of thousands, or even more persistent",
      "level": 3,
      "page": 198
    },
    {
      "heading": "connections to a chat server. If a chat server goes offline, service discovery",
      "level": 3,
      "page": 198
    },
    {
      "heading": "(Zookeeper) will provide a new chat server for clients to establish new connections",
      "level": 3,
      "page": 198
    },
    {
      "heading": "with.",
      "level": 3,
      "page": 198
    },
    {
      "heading": "• Message resent mechanism. Retry and queueing are common techniques for",
      "level": 3,
      "page": 198
    },
    {
      "heading": "resending messages.",
      "level": 3,
      "page": 198
    },
    {
      "heading": "Congratulations on getting this far! Now give yourself a pat on the back. Good job!",
      "level": 3,
      "page": 198
    },
    {
      "heading": "Reference materials",
      "level": 2,
      "page": 199
    },
    {
      "heading": "[1] Erlang at Facebook: https://www.erlang-",
      "level": 3,
      "page": 199
    },
    {
      "heading": "factory.com/upload/presentations/31/EugeneLetuchy-ErlangatFacebook.pdf",
      "level": 3,
      "page": 199
    },
    {
      "heading": "[2] Messenger and WhatsApp process 60 billion messages a day:",
      "level": 3,
      "page": 199
    },
    {
      "heading": "https://www.theverge.com/2016/4/12/11415198/facebook-messenger-whatsapp-number-",
      "level": 3,
      "page": 199
    },
    {
      "heading": "messages-vs-sms-f8-2016",
      "level": 3,
      "page": 199
    },
    {
      "heading": "[3] Long tail: https://en.wikipedia.org/wiki/Long_tail",
      "level": 3,
      "page": 199
    },
    {
      "heading": "[4] The Underlying Technology of Messages: https://www.facebook.com/notes/facebook-",
      "level": 3,
      "page": 199
    },
    {
      "heading": "engineering/the-underlying-technology-of-messages/454991608919/",
      "level": 3,
      "page": 199
    },
    {
      "heading": "[5] How Discord Stores Billions of Messages: https://blog.discordapp.com/how-discord-",
      "level": 3,
      "page": 199
    },
    {
      "heading": "stores-billions-of-messages-7fa6ec7ee4c7",
      "level": 3,
      "page": 199
    },
    {
      "heading": "[6] Announcing Snowflake: https://blog.twitter.com/engineering/en_us/a/2010/announcing-",
      "level": 3,
      "page": 199
    },
    {
      "heading": "snowflake.html",
      "level": 3,
      "page": 199
    },
    {
      "heading": "[7] Apache ZooKeeper: https://zookeeper.apache.org/",
      "level": 3,
      "page": 199
    },
    {
      "heading": "[8] From nothing: the evolution of WeChat background system (Article in Chinese):",
      "level": 3,
      "page": 199
    },
    {
      "heading": "https://www.infoq.cn/article/the-road-of-the-growth-weixin-background",
      "level": 3,
      "page": 199
    },
    {
      "heading": "[9] End-to-end encryption: https://faq.whatsapp.com/en/android/28030015/",
      "level": 3,
      "page": 199
    },
    {
      "heading": "[10] Flannel: An Application-Level Edge Cache to Make Slack Scale:",
      "level": 3,
      "page": 199
    },
    {
      "heading": "https://slack.engineering/flannel-an-application-level-edge-cache-to-make-slack-scale-",
      "level": 3,
      "page": 199
    },
    {
      "heading": "b8a6400e2f6b",
      "level": 3,
      "page": 199
    },
    {
      "heading": "CHAPTER 13: DESIGN A SEARCH AUTOCOMPLETE",
      "level": 1,
      "page": 200
    },
    {
      "heading": "SYSTEM",
      "level": 1,
      "page": 200
    },
    {
      "heading": "When searching on Google or shopping at Amazon, as you type in the search box, one or",
      "level": 3,
      "page": 200
    },
    {
      "heading": "more matches for the search term are presented to you. This feature is referred to as",
      "level": 3,
      "page": 200
    },
    {
      "heading": "autocomplete, typeahead, search-as-you-type, or incremental search. Figure 13-1 presents an",
      "level": 3,
      "page": 200
    },
    {
      "heading": "example of a Google search showing a list of autocompleted results when “dinner” is typed",
      "level": 3,
      "page": 200
    },
    {
      "heading": "into the search box. Search autocomplete is an important feature of many products. This leads",
      "level": 3,
      "page": 200
    },
    {
      "heading": "us to the interview question: design a search autocomplete system, also called “design top k”",
      "level": 3,
      "page": 200
    },
    {
      "heading": "or “design top k most searched queries”.",
      "level": 3,
      "page": 200
    },
    {
      "heading": "Step 1 - Understand the problem and establish design scope",
      "level": 3,
      "page": 201
    },
    {
      "heading": "The first step to tackle any system design interview question is to ask enough questions to",
      "level": 3,
      "page": 201
    },
    {
      "heading": "clarify requirements. Here is an example of candidate-interviewer interaction:",
      "level": 3,
      "page": 201
    },
    {
      "heading": "Candidate: Is the matching only supported at the beginning of a search query or in the",
      "level": 3,
      "page": 201
    },
    {
      "heading": "middle as well?",
      "level": 3,
      "page": 201
    },
    {
      "heading": "Interviewer: Only at the beginning of a search query.",
      "level": 3,
      "page": 201
    },
    {
      "heading": "Candidate: How many autocomplete suggestions should the system return?",
      "level": 3,
      "page": 201
    },
    {
      "heading": "Interviewer: 5",
      "level": 3,
      "page": 201
    },
    {
      "heading": "Candidate: How does the system know which 5 suggestions to return?",
      "level": 3,
      "page": 201
    },
    {
      "heading": "Interviewer: This is determined by popularity, decided by the historical query frequency.",
      "level": 3,
      "page": 201
    },
    {
      "heading": "Candidate: Does the system support spell check?",
      "level": 3,
      "page": 201
    },
    {
      "heading": "Interviewer: No, spell check or autocorrect is not supported.",
      "level": 3,
      "page": 201
    },
    {
      "heading": "Candidate: Are search queries in English?",
      "level": 3,
      "page": 201
    },
    {
      "heading": "Interviewer: Yes. If time allows at the end, we can discuss multi-language support.",
      "level": 3,
      "page": 201
    },
    {
      "heading": "Candidate: Do we allow capitalization and special characters?",
      "level": 3,
      "page": 201
    },
    {
      "heading": "Interviewer: No, we assume all search queries have lowercase alphabetic characters.",
      "level": 3,
      "page": 201
    },
    {
      "heading": "Candidate: How many users use the product?",
      "level": 3,
      "page": 201
    },
    {
      "heading": "Interviewer: 10 million DAU.",
      "level": 3,
      "page": 201
    },
    {
      "heading": "Requirements",
      "level": 3,
      "page": 201
    },
    {
      "heading": "Here is a summary of the requirements:",
      "level": 3,
      "page": 201
    },
    {
      "heading": "• Fast response time: As a user types a search query, autocomplete suggestions must show",
      "level": 3,
      "page": 201
    },
    {
      "heading": "up fast enough. An article about Facebook’s autocomplete system [1] reveals that the",
      "level": 3,
      "page": 201
    },
    {
      "heading": "system needs to return results within 100 milliseconds. Otherwise it will cause stuttering.",
      "level": 3,
      "page": 201
    },
    {
      "heading": "• Relevant: Autocomplete suggestions should be relevant to the search term.",
      "level": 3,
      "page": 201
    },
    {
      "heading": "• Sorted: Results returned by the system must be sorted by popularity or other ranking",
      "level": 3,
      "page": 201
    },
    {
      "heading": "models.",
      "level": 3,
      "page": 201
    },
    {
      "heading": "• Scalable: The system can handle high traffic volume.",
      "level": 3,
      "page": 201
    },
    {
      "heading": "• Highly available: The system should remain available and accessible when part of the",
      "level": 3,
      "page": 201
    },
    {
      "heading": "system is offline, slows down, or experiences unexpected network errors.",
      "level": 3,
      "page": 201
    },
    {
      "heading": "Back of the envelope estimation",
      "level": 3,
      "page": 201
    },
    {
      "heading": "• Assume 10 million daily active users (DAU).",
      "level": 3,
      "page": 201
    },
    {
      "heading": "• An average person performs 10 searches per day.",
      "level": 3,
      "page": 201
    },
    {
      "heading": "• 20 bytes of data per query string:",
      "level": 3,
      "page": 201
    },
    {
      "heading": "• Assume we use ASCII character encoding. 1 character = 1 byte",
      "level": 3,
      "page": 201
    },
    {
      "heading": "• Assume a query contains 4 words, and each word contains 5 characters on average.",
      "level": 3,
      "page": 201
    },
    {
      "heading": "• That is 4 x 5 = 20 bytes per query.",
      "level": 3,
      "page": 201
    },
    {
      "heading": "• For every character entered into the search box, a client sends a request to the backend",
      "level": 3,
      "page": 201
    },
    {
      "heading": "for autocomplete suggestions. On average, 20 requests are sent for each search query. For",
      "level": 3,
      "page": 201
    },
    {
      "heading": "example, the following 6 requests are sent to the backend by the time you finish typing",
      "level": 3,
      "page": 201
    },
    {
      "heading": "“dinner”.",
      "level": 3,
      "page": 201
    },
    {
      "heading": "search?q=d",
      "level": 3,
      "page": 201
    },
    {
      "heading": "search?q=di",
      "level": 3,
      "page": 202
    },
    {
      "heading": "search?q=din",
      "level": 3,
      "page": 202
    },
    {
      "heading": "search?q=dinn",
      "level": 3,
      "page": 202
    },
    {
      "heading": "search?q=dinne",
      "level": 3,
      "page": 202
    },
    {
      "heading": "search?q=dinner",
      "level": 3,
      "page": 202
    },
    {
      "heading": "• ~24,000 query per second (QPS) = 10,000,000 users * 10 queries / day * 20 characters /",
      "level": 3,
      "page": 202
    },
    {
      "heading": "24 hours / 3600 seconds.",
      "level": 3,
      "page": 202
    },
    {
      "heading": "• Peak QPS = QPS * 2 = ~48,000",
      "level": 3,
      "page": 202
    },
    {
      "heading": "• Assume 20% of the daily queries are new. 10 million * 10 queries / day * 20 byte per",
      "level": 3,
      "page": 202
    },
    {
      "heading": "query * 20% = 0.4 GB. This means 0.4GB of new data is added to storage daily.",
      "level": 3,
      "page": 202
    },
    {
      "heading": "Step 2 - Propose high-level design and get buy-in",
      "level": 3,
      "page": 203
    },
    {
      "heading": "At the high-level, the system is broken down into two:",
      "level": 3,
      "page": 203
    },
    {
      "heading": "• Data gathering service: It gathers user input queries and aggregates them in real-time.",
      "level": 3,
      "page": 203
    },
    {
      "heading": "Real-time processing is not practical for large data sets; however, it is a good starting",
      "level": 3,
      "page": 203
    },
    {
      "heading": "point. We will explore a more realistic solution in deep dive.",
      "level": 3,
      "page": 203
    },
    {
      "heading": "• Query service: Given a search query or prefix, return 5 most frequently searched terms.",
      "level": 3,
      "page": 203
    },
    {
      "heading": "Data gathering service",
      "level": 3,
      "page": 203
    },
    {
      "heading": "Let us use a simplified example to see how data gathering service works. Assume we have a",
      "level": 3,
      "page": 203
    },
    {
      "heading": "frequency table that stores the query string and its frequency as shown in Figure 13-2. In the",
      "level": 3,
      "page": 203
    },
    {
      "heading": "beginning, the frequency table is empty. Later, users enter queries “twitch”, “twitter”,",
      "level": 3,
      "page": 203
    },
    {
      "heading": "“twitter,” and “twillo” sequentially. Figure 13-2 shows how the frequency table is updated.",
      "level": 3,
      "page": 203
    },
    {
      "heading": "Query service",
      "level": 3,
      "page": 203
    },
    {
      "heading": "Assume we have a frequency table as shown in Table 13-1. It has two fields.",
      "level": 3,
      "page": 203
    },
    {
      "heading": "• Query: it stores the query string.",
      "level": 3,
      "page": 203
    },
    {
      "heading": "• Frequency: it represents the number of times a query has been searched.",
      "level": 3,
      "page": 203
    },
    {
      "heading": "When a user types “tw” in the search box, the following top 5 searched queries are displayed",
      "level": 3,
      "page": 204
    },
    {
      "heading": "(Figure 13-3), assuming the frequency table is based on Table 13-1.",
      "level": 3,
      "page": 204
    },
    {
      "heading": "To get top 5 frequently searched queries, execute the following SQL query:",
      "level": 3,
      "page": 204
    },
    {
      "heading": "This is an acceptable solution when the data set is small. When it is large, accessing the",
      "level": 3,
      "page": 205
    },
    {
      "heading": "database becomes a bottleneck. We will explore optimizations in deep dive.",
      "level": 3,
      "page": 205
    },
    {
      "heading": "Step 3 - Design deep dive",
      "level": 3,
      "page": 206
    },
    {
      "heading": "level design is not optimal, but it serves as a good starting point. In this section, we will dive",
      "level": 3,
      "page": 206
    },
    {
      "heading": "deep into a few components and explore optimizations as follows:",
      "level": 3,
      "page": 206
    },
    {
      "heading": "• Trie data structure",
      "level": 3,
      "page": 206
    },
    {
      "heading": "• Data gathering service",
      "level": 3,
      "page": 206
    },
    {
      "heading": "• Query service",
      "level": 3,
      "page": 206
    },
    {
      "heading": "• Scale the storage",
      "level": 3,
      "page": 206
    },
    {
      "heading": "• Trie operations",
      "level": 3,
      "page": 206
    },
    {
      "heading": "Trie data structure",
      "level": 3,
      "page": 206
    },
    {
      "heading": "Relational databases are used for storage in the high-level design. However, fetching the top",
      "level": 3,
      "page": 206
    },
    {
      "heading": "used to overcome the problem. As trie data structure is crucial for the system, we will",
      "level": 3,
      "page": 206
    },
    {
      "heading": "dedicate significant time to design a customized trie. Please note that some of the ideas are",
      "level": 3,
      "page": 206
    },
    {
      "heading": "from articles [2] and [3].",
      "level": 3,
      "page": 206
    },
    {
      "heading": "Understanding the basic trie data structure is essential for this interview question. However,",
      "level": 3,
      "page": 206
    },
    {
      "heading": "this is more of a data structure question than a system design question. Besides, many online",
      "level": 3,
      "page": 206
    },
    {
      "heading": "materials explain this concept. In this chapter, we will only discuss an overview of the trie",
      "level": 3,
      "page": 206
    },
    {
      "heading": "data structure and focus on how to optimize the basic trie to improve response time.",
      "level": 3,
      "page": 206
    },
    {
      "heading": "Trie (pronounced “try”) is a tree-like data structure that can compactly store strings. The",
      "level": 3,
      "page": 206
    },
    {
      "heading": "name comes from the word retrieval, which indicates it is designed for string retrieval",
      "level": 3,
      "page": 206
    },
    {
      "heading": "operations. The main idea of trie consists of the following:",
      "level": 3,
      "page": 206
    },
    {
      "heading": "• A trie is a tree-like data structure.",
      "level": 3,
      "page": 206
    },
    {
      "heading": "• The root represents an empty string.",
      "level": 3,
      "page": 206
    },
    {
      "heading": "• Each node stores a character and has 26 children, one for each possible character. To",
      "level": 3,
      "page": 206
    },
    {
      "heading": "save space, we do not draw empty links.",
      "level": 3,
      "page": 206
    },
    {
      "heading": "• Each tree node represents a single word or a prefix string.",
      "level": 3,
      "page": 206
    },
    {
      "heading": "Figure 13-5 shows a trie with search queries “tree”, “try”, “true”, “toy”, “wish”, “win”.",
      "level": 3,
      "page": 206
    },
    {
      "heading": "Search queries are highlighted with a thicker border.",
      "level": 3,
      "page": 206
    },
    {
      "heading": "Basic trie data structure stores characters in nodes. To support sorting by frequency,",
      "level": 3,
      "page": 207
    },
    {
      "heading": "frequency info needs to be included in nodes. Assume we have the following frequency table.",
      "level": 3,
      "page": 207
    },
    {
      "heading": "After adding frequency info to nodes, updated trie data structure is shown in Figure 13-6.",
      "level": 3,
      "page": 207
    },
    {
      "heading": "How does autocomplete work with trie? Before diving into the algorithm, let us define some",
      "level": 3,
      "page": 208
    },
    {
      "heading": "terms.",
      "level": 3,
      "page": 208
    },
    {
      "heading": "• p: length of a prefix",
      "level": 3,
      "page": 208
    },
    {
      "heading": "• n: total number of nodes in a trie",
      "level": 3,
      "page": 208
    },
    {
      "heading": "• c: number of children of a given node",
      "level": 3,
      "page": 208
    },
    {
      "heading": "Steps to get top k most searched queries are listed below:",
      "level": 3,
      "page": 208
    },
    {
      "heading": "1. Find the prefix. Time complexity: O(p).",
      "level": 3,
      "page": 208
    },
    {
      "heading": "2. Traverse the subtree from the prefix node to get all valid children. A child is valid if it",
      "level": 3,
      "page": 208
    },
    {
      "heading": "can form a valid query string. Time complexity: O(c)",
      "level": 3,
      "page": 208
    },
    {
      "heading": "3. Sort the children and get top k. Time complexity: O(clogc)",
      "level": 3,
      "page": 208
    },
    {
      "heading": "Let us use an example as shown in Figure 13-7 to explain the algorithm. Assume k equals to",
      "level": 3,
      "page": 208
    },
    {
      "heading": "2 and a user types “tr” in the search box. The algorithm works as follows:",
      "level": 3,
      "page": 208
    },
    {
      "heading": "• Step 1: Find the prefix node “tr”.",
      "level": 3,
      "page": 208
    },
    {
      "heading": "• Step 2: Traverse the subtree to get all valid children. In this case, nodes [tree: 10], [true:",
      "level": 3,
      "page": 208
    },
    {
      "heading": "35], [try: 29] are valid.",
      "level": 3,
      "page": 208
    },
    {
      "heading": "• Step 3: Sort the children and get top 2. [true: 35] and [try: 29] are the top 2 queries with",
      "level": 3,
      "page": 208
    },
    {
      "heading": "prefix “tr”.",
      "level": 3,
      "page": 208
    },
    {
      "heading": "The time complexity of this algorithm is the sum of time spent on each step mentioned above:",
      "level": 3,
      "page": 209
    },
    {
      "heading": "O(p) + O(c) + O(clogc)",
      "level": 3,
      "page": 209
    },
    {
      "heading": "The above algorithm is straightforward. However, it is too slow because we need to traverse",
      "level": 3,
      "page": 209
    },
    {
      "heading": "the entire trie to get top k results in the worst-case scenario. Below are two optimizations:",
      "level": 3,
      "page": 209
    },
    {
      "heading": "1. Limit the max length of a prefix",
      "level": 3,
      "page": 209
    },
    {
      "heading": "2. Cache top search queries at each node",
      "level": 3,
      "page": 209
    },
    {
      "heading": "Let us look at these optimizations one by one.",
      "level": 3,
      "page": 209
    },
    {
      "heading": "Limit the max length of a prefix",
      "level": 3,
      "page": 209
    },
    {
      "heading": "Users rarely type a long search query into the search box. Thus, it is safe to say p is a small",
      "level": 3,
      "page": 209
    },
    {
      "heading": "integer number, say 50. If we limit the length of a prefix, the time complexity for “Find the",
      "level": 3,
      "page": 209
    },
    {
      "heading": "prefix” can be reduced from O(p) to O(small constant), aka O(1).",
      "level": 3,
      "page": 209
    },
    {
      "heading": "Cache top search queries at each node",
      "level": 3,
      "page": 209
    },
    {
      "heading": "To avoid traversing the whole trie, we store top k most frequently used queries at each node.",
      "level": 3,
      "page": 209
    },
    {
      "heading": "Since 5 to 10 autocomplete suggestions are enough for users, k is a relatively small number.",
      "level": 3,
      "page": 209
    },
    {
      "heading": "In our specific case, only the top 5 search queries are cached.",
      "level": 3,
      "page": 209
    },
    {
      "heading": "By caching top search queries at every node, we significantly reduce the time complexity to",
      "level": 3,
      "page": 209
    },
    {
      "heading": "retrieve the top 5 queries. However, this design requires a lot of space to store top queries at",
      "level": 3,
      "page": 209
    },
    {
      "heading": "every node. Trading space for time is well worth it as fast response time is very important.",
      "level": 3,
      "page": 209
    },
    {
      "heading": "Figure 13-8 shows the updated trie data structure. Top 5 queries are stored on each node. For",
      "level": 3,
      "page": 209
    },
    {
      "heading": "example, the node with prefix “be” stores the following: [best: 35, bet: 29, bee: 20, be: 15,",
      "level": 3,
      "page": 209
    },
    {
      "heading": "beer: 10].",
      "level": 3,
      "page": 209
    },
    {
      "heading": "Let us revisit the time complexity of the algorithm after applying those two optimizations:",
      "level": 3,
      "page": 210
    },
    {
      "heading": "1. Find the prefix node. Time complexity: O(1)",
      "level": 3,
      "page": 210
    },
    {
      "heading": "2. Return top k. Since top k queries are cached, the time complexity for this step is O(1).",
      "level": 3,
      "page": 210
    },
    {
      "heading": "As the time complexity for each of the steps is reduced to O(1), our algorithm takes only",
      "level": 3,
      "page": 210
    },
    {
      "heading": "O(1)  to fetch top k queries.",
      "level": 3,
      "page": 210
    },
    {
      "heading": "Data gathering service",
      "level": 3,
      "page": 210
    },
    {
      "heading": "In our previous design, whenever a user types a search query, data is updated in real-time.",
      "level": 3,
      "page": 210
    },
    {
      "heading": "This approach is not practical for the following two reasons:",
      "level": 3,
      "page": 210
    },
    {
      "heading": "• Users may enter billions of queries per day. Updating the trie on every query",
      "level": 3,
      "page": 210
    },
    {
      "heading": "significantly slows down the query service.",
      "level": 3,
      "page": 210
    },
    {
      "heading": "• Top suggestions may not change much once the trie is built. Thus, it is unnecessary to",
      "level": 3,
      "page": 210
    },
    {
      "heading": "update the trie frequently.",
      "level": 3,
      "page": 210
    },
    {
      "heading": "To design a scalable data gathering service, we examine where data comes from and how",
      "level": 3,
      "page": 210
    },
    {
      "heading": "data is used. Real-time applications like Twitter require up to date autocomplete suggestions.",
      "level": 3,
      "page": 210
    },
    {
      "heading": "However, autocomplete suggestions for many Google keywords might not change much on a",
      "level": 3,
      "page": 210
    },
    {
      "heading": "daily basis.",
      "level": 3,
      "page": 210
    },
    {
      "heading": "Despite the differences in use cases, the underlying foundation for data gathering service",
      "level": 3,
      "page": 210
    },
    {
      "heading": "remains the same because data used to build the trie is usually from analytics or logging",
      "level": 3,
      "page": 210
    },
    {
      "heading": "services.",
      "level": 3,
      "page": 210
    },
    {
      "heading": "Figure 13-9 shows the redesigned data gathering service. Each component is examined one",
      "level": 3,
      "page": 210
    },
    {
      "heading": "by one.",
      "level": 3,
      "page": 210
    },
    {
      "heading": "Analytics Logs. It stores raw data about search queries. Logs are append-only and are not",
      "level": 3,
      "page": 211
    },
    {
      "heading": "indexed. Table 13-3 shows an example of the log file.",
      "level": 3,
      "page": 211
    },
    {
      "heading": "Aggregators. The size of analytics logs is usually very large, and data is not in the right",
      "level": 3,
      "page": 211
    },
    {
      "heading": "format. We need to aggregate data so it can be easily processed by our system.",
      "level": 3,
      "page": 211
    },
    {
      "heading": "Depending on the use case, we may aggregate data differently. For real-time applications",
      "level": 3,
      "page": 211
    },
    {
      "heading": "such as Twitter, we aggregate data in a shorter time interval as real-time results are important.",
      "level": 3,
      "page": 211
    },
    {
      "heading": "On the other hand, aggregating data less frequently, say once per week, might be good",
      "level": 3,
      "page": 211
    },
    {
      "heading": "enough for many use cases. During an interview session, verify whether real-time results are",
      "level": 3,
      "page": 211
    },
    {
      "heading": "important. We assume trie is rebuilt weekly.",
      "level": 3,
      "page": 211
    },
    {
      "heading": "Aggregated Data.",
      "level": 3,
      "page": 211
    },
    {
      "heading": "Table 13-4 shows an example of aggregated weekly data. “time” field represents the start",
      "level": 3,
      "page": 211
    },
    {
      "heading": "time of a week. “frequency” field is the sum of the occurrences for the corresponding query",
      "level": 3,
      "page": 211
    },
    {
      "heading": "in that week.",
      "level": 3,
      "page": 211
    },
    {
      "heading": "Workers. Workers are a set of servers that perform asynchronous jobs at regular intervals.",
      "level": 3,
      "page": 212
    },
    {
      "heading": "They build the trie data structure and store it in Trie DB.",
      "level": 3,
      "page": 212
    },
    {
      "heading": "Trie Cache. Trie Cache is a distributed cache system that keeps trie in memory for fast read.",
      "level": 3,
      "page": 212
    },
    {
      "heading": "It takes a weekly snapshot of the DB.",
      "level": 3,
      "page": 212
    },
    {
      "heading": "Trie DB. Trie DB is the persistent storage. Two options are available to store the data:",
      "level": 3,
      "page": 212
    },
    {
      "heading": "1. Document store: Since a new trie is built weekly, we can periodically take a snapshot of it,",
      "level": 3,
      "page": 212
    },
    {
      "heading": "serialize it, and store the serialized data in the database. Document stores like MongoDB [4]",
      "level": 3,
      "page": 212
    },
    {
      "heading": "are good fits for serialized data.",
      "level": 3,
      "page": 212
    },
    {
      "heading": "2. Key-value store: A trie can be represented in a hash table form [4] by applying the",
      "level": 3,
      "page": 212
    },
    {
      "heading": "following logic:",
      "level": 3,
      "page": 212
    },
    {
      "heading": "• Every prefix in the trie is mapped to a key in a hash table.",
      "level": 3,
      "page": 212
    },
    {
      "heading": "• Data on each trie node is mapped to a value in a hash table.",
      "level": 3,
      "page": 212
    },
    {
      "heading": "Figure 13-10 shows the mapping between the trie and hash table.",
      "level": 3,
      "page": 212
    },
    {
      "heading": "In Figure 13-10, each trie node on the left is mapped to the <key, value>  pair on the right. If",
      "level": 3,
      "page": 213
    },
    {
      "heading": "you are unclear how key-value stores work, refer to Chapter 6: Design a key-value store.",
      "level": 3,
      "page": 213
    },
    {
      "heading": "Query service",
      "level": 3,
      "page": 213
    },
    {
      "heading": "In the high-level design, query service calls the database directly to fetch the top 5 results.",
      "level": 3,
      "page": 213
    },
    {
      "heading": "Figure 13-11 shows the improved design as previous design is inefficient.",
      "level": 3,
      "page": 213
    },
    {
      "heading": "1. A search query is sent to the load balancer.",
      "level": 3,
      "page": 214
    },
    {
      "heading": "2. The load balancer routes the request to API servers.",
      "level": 3,
      "page": 214
    },
    {
      "heading": "3. API servers get trie data from Trie Cache and construct autocomplete suggestions for",
      "level": 3,
      "page": 214
    },
    {
      "heading": "the client.",
      "level": 3,
      "page": 214
    },
    {
      "heading": "4. In case the data is not in Trie Cache, we replenish data back to the cache. This way, all",
      "level": 3,
      "page": 214
    },
    {
      "heading": "subsequent requests for the same prefix are returned from the cache. A cache miss can",
      "level": 3,
      "page": 214
    },
    {
      "heading": "happen when a cache server is out of memory or offline.",
      "level": 3,
      "page": 214
    },
    {
      "heading": "Query service requires lightning-fast speed. We propose the following optimizations:",
      "level": 3,
      "page": 214
    },
    {
      "heading": "• AJAX request. For web applications, browsers usually send AJAX requests to fetch",
      "level": 3,
      "page": 214
    },
    {
      "heading": "autocomplete results. The main benefit of AJAX is that sending/receiving a",
      "level": 3,
      "page": 214
    },
    {
      "heading": "request/response does not refresh the whole web page.",
      "level": 3,
      "page": 214
    },
    {
      "heading": "• Browser caching. For many applications, autocomplete search suggestions may not",
      "level": 3,
      "page": 214
    },
    {
      "heading": "change much within a short time. Thus, autocomplete suggestions can be saved in browser",
      "level": 3,
      "page": 214
    },
    {
      "heading": "cache to allow subsequent requests to get results from the cache directly. Google search",
      "level": 3,
      "page": 214
    },
    {
      "heading": "engine uses the same cache mechanism. Figure 13-12 shows the response header when",
      "level": 3,
      "page": 214
    },
    {
      "heading": "you type “system design interview” on the Google search engine. As you can see, Google",
      "level": 3,
      "page": 214
    },
    {
      "heading": "caches the results in the browser for 1 hour. Please note: “private” in cache-control means",
      "level": 3,
      "page": 215
    },
    {
      "heading": "results are intended for a single user and must not be cached by a shared cache. “max-",
      "level": 3,
      "page": 215
    },
    {
      "heading": "age=3600” means the cache is valid for 3600 seconds, aka, an hour.",
      "level": 3,
      "page": 215
    },
    {
      "heading": "• Data sampling: For a large-scale system, logging every search query requires a lot of",
      "level": 3,
      "page": 215
    },
    {
      "heading": "processing power and storage. Data sampling is important. For instance, only 1 out of",
      "level": 3,
      "page": 215
    },
    {
      "heading": "every N requests is logged by the system.",
      "level": 3,
      "page": 215
    },
    {
      "heading": "Trie operations",
      "level": 3,
      "page": 215
    },
    {
      "heading": "Trie is a core component of the autocomplete system. Let us look at how trie operations",
      "level": 3,
      "page": 215
    },
    {
      "heading": "(create, update, and delete) work.",
      "level": 3,
      "page": 215
    },
    {
      "heading": "Create",
      "level": 3,
      "page": 215
    },
    {
      "heading": "Trie is created by workers using aggregated data. The source of data is from Analytics",
      "level": 3,
      "page": 215
    },
    {
      "heading": "Log/DB.",
      "level": 3,
      "page": 215
    },
    {
      "heading": "Update",
      "level": 3,
      "page": 215
    },
    {
      "heading": "There are two ways to update the trie.",
      "level": 3,
      "page": 215
    },
    {
      "heading": "Option 1: Update the trie weekly. Once a new trie is created, the new trie replaces the old",
      "level": 3,
      "page": 215
    },
    {
      "heading": "one.",
      "level": 3,
      "page": 215
    },
    {
      "heading": "Option 2: Update individual trie node directly. We try to avoid this operation because it is",
      "level": 3,
      "page": 215
    },
    {
      "heading": "slow. However, if the size of the trie is small, it is an acceptable solution. When we update a",
      "level": 3,
      "page": 215
    },
    {
      "heading": "trie node, its ancestors all the way up to the root must be updated because ancestors store top",
      "level": 3,
      "page": 215
    },
    {
      "heading": "queries of children. Figure 13-13 shows an example of how the update operation works. On",
      "level": 3,
      "page": 215
    },
    {
      "heading": "the left side, the search query “beer” has the original value 10. On the right side, it is updated",
      "level": 3,
      "page": 215
    },
    {
      "heading": "to 30. As you can see, the node and its ancestors have the “beer” value updated to 30.",
      "level": 3,
      "page": 215
    },
    {
      "heading": "Delete",
      "level": 3,
      "page": 216
    },
    {
      "heading": "We have to remove hateful, violent, sexually explicit, or dangerous autocomplete",
      "level": 3,
      "page": 216
    },
    {
      "heading": "suggestions. We add a filter layer (Figure 13-14) in front of the Trie Cache to filter out",
      "level": 3,
      "page": 216
    },
    {
      "heading": "unwanted suggestions. Having a filter layer gives us the flexibility of removing results based",
      "level": 3,
      "page": 216
    },
    {
      "heading": "on different filter rules. Unwanted suggestions are removed physically from the database",
      "level": 3,
      "page": 216
    },
    {
      "heading": "asynchronically so the correct data set will be used to build trie in the next update cycle.",
      "level": 3,
      "page": 216
    },
    {
      "heading": "Scale the storage",
      "level": 3,
      "page": 216
    },
    {
      "heading": "Now that we have developed a system to bring autocomplete queries to users, it is time to",
      "level": 3,
      "page": 216
    },
    {
      "heading": "solve the scalability issue when the trie grows too large to fit in one server.",
      "level": 3,
      "page": 216
    },
    {
      "heading": "Since English is the only supported language, a naive way to shard is based on the first",
      "level": 3,
      "page": 216
    },
    {
      "heading": "character. Here are some examples.",
      "level": 3,
      "page": 216
    },
    {
      "heading": "• If we need two servers for storage, we can store queries starting with ‘a’ to ‘m’ on the",
      "level": 3,
      "page": 216
    },
    {
      "heading": "first server, and ‘n’ to ‘z’ on the second server.",
      "level": 3,
      "page": 216
    },
    {
      "heading": "• If we need three servers, we can split queries into ‘a’ to ‘i’, ‘j’ to ‘r’ and ‘s’ to ‘z’.",
      "level": 3,
      "page": 216
    },
    {
      "heading": "Following this logic, we can split queries up to 26 servers because there are 26 alphabetic",
      "level": 3,
      "page": 216
    },
    {
      "heading": "characters in English. Let us define sharding based on the first character as first level",
      "level": 3,
      "page": 216
    },
    {
      "heading": "sharding. To store data beyond 26 servers, we can shard on the second or even at the third",
      "level": 3,
      "page": 216
    },
    {
      "heading": "level. For example, data queries that start with ‘a’ can be split into 4 servers: ‘aa-ag’, ‘ah-",
      "level": 3,
      "page": 216
    },
    {
      "heading": "an’, ‘ao-au’, and ‘av-az’.",
      "level": 3,
      "page": 216
    },
    {
      "heading": "At the first glance this approach seems reasonable, until you realize that there are a lot more",
      "level": 3,
      "page": 216
    },
    {
      "heading": "words that start with the letter ‘c’ than ‘x’. This creates uneven distribution.",
      "level": 3,
      "page": 216
    },
    {
      "heading": "To mitigate the data imbalance problem, we analyze historical data distribution pattern and",
      "level": 3,
      "page": 217
    },
    {
      "heading": "apply smarter sharding logic as shown in Figure 13-15. The shard map manager maintains a",
      "level": 3,
      "page": 217
    },
    {
      "heading": "lookup database for identifying where rows should be stored. For example, if there are a",
      "level": 3,
      "page": 217
    },
    {
      "heading": "similar number of historical queries for ‘s’ and for ‘u’, ‘v’, ‘w’, ‘x’, ‘y’ and ‘z’ combined, we",
      "level": 3,
      "page": 217
    },
    {
      "heading": "can maintain two shards: one for ‘s’ and one for ‘u’ to ‘z’.",
      "level": 3,
      "page": 217
    },
    {
      "heading": "Step 4 - Wrap up",
      "level": 3,
      "page": 218
    },
    {
      "heading": "After you finish the deep dive, your interviewer might ask you some follow up questions.",
      "level": 3,
      "page": 218
    },
    {
      "heading": "Interviewer: How do you extend your design to support multiple languages?",
      "level": 3,
      "page": 218
    },
    {
      "heading": "To support other non-English queries, we store Unicode characters in trie nodes. If you are",
      "level": 3,
      "page": 218
    },
    {
      "heading": "not familiar with Unicode, here is the definition: “an encoding standard covers all the",
      "level": 3,
      "page": 218
    },
    {
      "heading": "characters for all the writing systems of the world, modern and ancient” [5].",
      "level": 3,
      "page": 218
    },
    {
      "heading": "Interviewer: What if top search queries in one country are different from others?",
      "level": 3,
      "page": 218
    },
    {
      "heading": "In this case, we might build different tries for different countries. To improve the response",
      "level": 3,
      "page": 218
    },
    {
      "heading": "time, we can store tries in CDNs.",
      "level": 3,
      "page": 218
    },
    {
      "heading": "Interviewer: How can we support the trending (real-time) search queries?",
      "level": 3,
      "page": 218
    },
    {
      "heading": "Assuming a news event breaks out, a search query suddenly becomes popular. Our original",
      "level": 3,
      "page": 218
    },
    {
      "heading": "design will not work because:",
      "level": 3,
      "page": 218
    },
    {
      "heading": "• Offline workers are not scheduled to update the trie yet because this is scheduled to run",
      "level": 3,
      "page": 218
    },
    {
      "heading": "on weekly basis.",
      "level": 3,
      "page": 218
    },
    {
      "heading": "• Even if it is scheduled, it takes too long to build the trie.",
      "level": 3,
      "page": 218
    },
    {
      "heading": "Building a real-time search autocomplete is complicated and is beyond the scope of this book",
      "level": 3,
      "page": 218
    },
    {
      "heading": "so we will only give a few ideas:",
      "level": 3,
      "page": 218
    },
    {
      "heading": "• Reduce the working data set by sharding.",
      "level": 3,
      "page": 218
    },
    {
      "heading": "• Change the ranking model and assign more weight to recent search queries.",
      "level": 3,
      "page": 218
    },
    {
      "heading": "• Data may come as streams, so we do not have access to all the data at once. Streaming",
      "level": 3,
      "page": 218
    },
    {
      "heading": "data means data is generated continuously. Stream processing requires a different set of",
      "level": 3,
      "page": 218
    },
    {
      "heading": "systems: Apache Hadoop MapReduce [6], Apache Spark Streaming [7], Apache Storm",
      "level": 3,
      "page": 218
    },
    {
      "heading": "[8], Apache Kafka [9], etc. Because all those topics require specific domain knowledge,",
      "level": 3,
      "page": 218
    },
    {
      "heading": "we are not going into detail here.",
      "level": 3,
      "page": 218
    },
    {
      "heading": "Congratulations on getting this far! Now give yourself a pat on the back. Good job!",
      "level": 3,
      "page": 218
    },
    {
      "heading": "Reference materials",
      "level": 2,
      "page": 219
    },
    {
      "heading": "[1] The Life of a Typeahead Query: https://www.facebook.com/notes/facebook-",
      "level": 3,
      "page": 219
    },
    {
      "heading": "engineering/the-life-of-a-typeahead-query/389105248919/",
      "level": 3,
      "page": 219
    },
    {
      "heading": "[2] How We Built Prefixy: A Scalable Prefix Search Service for Powering Autocomplete:",
      "level": 3,
      "page": 219
    },
    {
      "heading": "https://medium.com/@prefixyteam/how-we-built-prefixy-a-scalable-prefix-search-service-",
      "level": 3,
      "page": 219
    },
    {
      "heading": "for-powering-autocomplete-c20f98e2eff1",
      "level": 3,
      "page": 219
    },
    {
      "heading": "[3] Prefix Hash Tree An Indexing Data Structure over Distributed Hash Tables:",
      "level": 3,
      "page": 219
    },
    {
      "heading": "https://people.eecs.berkeley.edu/~sylvia/papers/pht.pdf",
      "level": 3,
      "page": 219
    },
    {
      "heading": "[4] MongoDB wikipedia: https://en.wikipedia.org/wiki/MongoDB",
      "level": 3,
      "page": 219
    },
    {
      "heading": "[5] Unicode frequently asked questions: https://www.unicode.org/faq/basic_q.html",
      "level": 3,
      "page": 219
    },
    {
      "heading": "[6] Apache hadoop: https://hadoop.apache.org/",
      "level": 3,
      "page": 219
    },
    {
      "heading": "[7] Spark streaming: https://spark.apache.org/streaming/",
      "level": 3,
      "page": 219
    },
    {
      "heading": "[8] Apache storm: https://storm.apache.org/",
      "level": 3,
      "page": 219
    },
    {
      "heading": "[9] Apache kafka: https://kafka.apache.org/documentation/",
      "level": 3,
      "page": 219
    },
    {
      "heading": "CHAPTER 14: DESIGN YOUTUBE",
      "level": 1,
      "page": 220
    },
    {
      "heading": "In this chapter, you are asked to design YouTube. The solution to this question can be applied",
      "level": 3,
      "page": 220
    },
    {
      "heading": "to other interview questions like designing a video sharing platform such as Netflix and Hulu.",
      "level": 3,
      "page": 220
    },
    {
      "heading": "Figure 14-1 shows the YouTube homepage.",
      "level": 3,
      "page": 220
    },
    {
      "heading": "YouTube looks simple: content creators upload videos and viewers click play. Is it really that",
      "level": 3,
      "page": 220
    },
    {
      "heading": "simple? Not really. There are lots of complex technologies underneath the simplicity. Let us",
      "level": 3,
      "page": 220
    },
    {
      "heading": "look at some impressive statistics, demographics, and fun facts of YouTube in 2020 [1] [2].",
      "level": 3,
      "page": 220
    },
    {
      "heading": "• Total number of monthly active users: 2 billion.",
      "level": 3,
      "page": 220
    },
    {
      "heading": "• Number of videos watched per day: 5 billion.",
      "level": 3,
      "page": 220
    },
    {
      "heading": "• 73% of US adults use YouTube.",
      "level": 3,
      "page": 220
    },
    {
      "heading": "• 50 million creators on YouTube.",
      "level": 3,
      "page": 220
    },
    {
      "heading": "• YouTube’s Ad revenue was $15.1 billion for the full year 2019, up 36% from 2018.",
      "level": 3,
      "page": 220
    },
    {
      "heading": "• YouTube is responsible for 37% of all mobile internet traffic.",
      "level": 3,
      "page": 220
    },
    {
      "heading": "• YouTube is available in 80 different languages.",
      "level": 3,
      "page": 220
    },
    {
      "heading": "From these statistics, we know YouTube is enormous, global and makes a lot of money.",
      "level": 3,
      "page": 220
    },
    {
      "heading": "Step 1 - Understand the problem and establish design scope",
      "level": 3,
      "page": 221
    },
    {
      "heading": "As revealed in Figure 14-1, besides watching a video, you can do a lot more on YouTube. For",
      "level": 3,
      "page": 221
    },
    {
      "heading": "example, comment, share, or like a video, save a video to playlists, subscribe to a channel,",
      "level": 3,
      "page": 221
    },
    {
      "heading": "etc. It is impossible to design everything within a 45- or 60-minute interview. Thus, it is",
      "level": 3,
      "page": 221
    },
    {
      "heading": "important to ask questions to narrow down the scope.",
      "level": 3,
      "page": 221
    },
    {
      "heading": "Candidate: What features are important?",
      "level": 3,
      "page": 221
    },
    {
      "heading": "Interviewer: Ability to upload a video and watch a video.",
      "level": 3,
      "page": 221
    },
    {
      "heading": "Candidate: What clients do we need to support?",
      "level": 3,
      "page": 221
    },
    {
      "heading": "Interviewer: Mobile apps, web browsers, and smart TV.",
      "level": 3,
      "page": 221
    },
    {
      "heading": "Candidate: How many daily active users do we have?",
      "level": 3,
      "page": 221
    },
    {
      "heading": "Interviewer: 5 million",
      "level": 3,
      "page": 221
    },
    {
      "heading": "Candidate: What is the average daily time spent on the product?",
      "level": 3,
      "page": 221
    },
    {
      "heading": "Interviewer: 30 minutes.",
      "level": 3,
      "page": 221
    },
    {
      "heading": "Candidate: Do we need to support international users?",
      "level": 3,
      "page": 221
    },
    {
      "heading": "Interviewer: Yes, a large percentage of users are international users.",
      "level": 3,
      "page": 221
    },
    {
      "heading": "Candidate: What are the supported video resolutions?",
      "level": 3,
      "page": 221
    },
    {
      "heading": "Interviewer: The system accepts most of the video resolutions and formats.",
      "level": 3,
      "page": 221
    },
    {
      "heading": "Candidate: Is encryption required?",
      "level": 3,
      "page": 221
    },
    {
      "heading": "Interviewer: Yes",
      "level": 3,
      "page": 221
    },
    {
      "heading": "Candidate: Any file size requirement for videos?",
      "level": 3,
      "page": 221
    },
    {
      "heading": "Interviewer: Our platform focuses on small and medium-sized videos. The maximum",
      "level": 3,
      "page": 221
    },
    {
      "heading": "allowed video size is 1GB.",
      "level": 3,
      "page": 221
    },
    {
      "heading": "Candidate: Can we leverage some of the existing cloud infrastructures provided by Amazon,",
      "level": 3,
      "page": 221
    },
    {
      "heading": "Google, or Microsoft?",
      "level": 3,
      "page": 221
    },
    {
      "heading": "Interviewer: That is a great question. Building everything from scratch is unrealistic for most",
      "level": 3,
      "page": 221
    },
    {
      "heading": "companies, it is recommended to leverage some of the existing cloud services.",
      "level": 3,
      "page": 221
    },
    {
      "heading": "In the chapter, we focus on designing a video streaming service with the following features:",
      "level": 3,
      "page": 221
    },
    {
      "heading": "• Ability to upload videos fast",
      "level": 3,
      "page": 221
    },
    {
      "heading": "• Smooth video streaming",
      "level": 3,
      "page": 221
    },
    {
      "heading": "• Ability to change video quality",
      "level": 3,
      "page": 221
    },
    {
      "heading": "• Low infrastructure cost",
      "level": 3,
      "page": 221
    },
    {
      "heading": "• High availability, scalability, and reliability requirements",
      "level": 3,
      "page": 221
    },
    {
      "heading": "• Clients supported: mobile apps, web browser, and smart TV",
      "level": 3,
      "page": 221
    },
    {
      "heading": "Back of the envelope estimation",
      "level": 3,
      "page": 221
    },
    {
      "heading": "The following estimations are based on many assumptions, so it is important to communicate",
      "level": 3,
      "page": 221
    },
    {
      "heading": "with the interviewer to make sure she is on the same page.",
      "level": 3,
      "page": 221
    },
    {
      "heading": "• Assume the product has 5 million daily active users (DAU).",
      "level": 3,
      "page": 221
    },
    {
      "heading": "• Users watch 5 videos per day.",
      "level": 3,
      "page": 221
    },
    {
      "heading": "• 10% of users upload 1 video per day.",
      "level": 3,
      "page": 221
    },
    {
      "heading": "• Assume the average video size is 300 MB.",
      "level": 3,
      "page": 221
    },
    {
      "heading": "• Total daily storage space needed: 5 million * 10% * 300 MB = 150TB",
      "level": 3,
      "page": 221
    },
    {
      "heading": "• CDN cost.",
      "level": 3,
      "page": 222
    },
    {
      "heading": "• When cloud CDN serves a video, you are charged for data transferred out of the",
      "level": 3,
      "page": 222
    },
    {
      "heading": "CDN.",
      "level": 3,
      "page": 222
    },
    {
      "heading": "• Let us use Amazon’s CDN CloudFront for cost estimation (Figure 14-2) [3]. Assume",
      "level": 3,
      "page": 222
    },
    {
      "heading": "100% of traffic is served from the United States. The average cost per GB is $0.02.",
      "level": 3,
      "page": 222
    },
    {
      "heading": "For simplicity, we only calculate the cost of video streaming.",
      "level": 3,
      "page": 222
    },
    {
      "heading": "• 5 million * 5 videos * 0.3GB * $0.02 = $150,000 per day.",
      "level": 3,
      "page": 222
    },
    {
      "heading": "From the rough cost estimation, we know serving videos from the CDN costs lots of money.",
      "level": 3,
      "page": 222
    },
    {
      "heading": "Even though cloud providers are willing to lower the CDN costs significantly for big",
      "level": 3,
      "page": 222
    },
    {
      "heading": "customers, the cost is still substantial. We will discuss ways to reduce CDN costs in deep",
      "level": 3,
      "page": 222
    },
    {
      "heading": "dive.",
      "level": 3,
      "page": 222
    },
    {
      "heading": "Step 2 - Propose high-level design and get buy-in",
      "level": 3,
      "page": 223
    },
    {
      "heading": "As discussed previously, the interviewer recommended leveraging existing cloud services",
      "level": 3,
      "page": 223
    },
    {
      "heading": "instead of building everything from scratch. CDN and blob storage are the cloud services we",
      "level": 3,
      "page": 223
    },
    {
      "heading": "will leverage. Some readers might ask why not building everything by ourselves? Reasons",
      "level": 3,
      "page": 223
    },
    {
      "heading": "are listed below:",
      "level": 3,
      "page": 223
    },
    {
      "heading": "• System design interviews are not about building everything from scratch. Within the",
      "level": 3,
      "page": 223
    },
    {
      "heading": "limited time frame, choosing the right technology to do a job right is more important than",
      "level": 3,
      "page": 223
    },
    {
      "heading": "explaining how the technology works in detail. For instance, mentioning blob storage for",
      "level": 3,
      "page": 223
    },
    {
      "heading": "storing source videos is enough for the interview. Talking about the detailed design for",
      "level": 3,
      "page": 223
    },
    {
      "heading": "blob storage could be an overkill.",
      "level": 3,
      "page": 223
    },
    {
      "heading": "• Building scalable blob storage or CDN is extremely complex and costly. Even large",
      "level": 3,
      "page": 223
    },
    {
      "heading": "companies like Netflix or Facebook do not build everything themselves. Netflix leverages",
      "level": 3,
      "page": 223
    },
    {
      "heading": "Amazon’s cloud services [4], and Facebook uses Akamai’s CDN [5].",
      "level": 3,
      "page": 223
    },
    {
      "heading": "At the high-level, the system comprises three components (Figure 14-3).",
      "level": 3,
      "page": 223
    },
    {
      "heading": "Client: You can watch YouTube on your computer, mobile phone, and smartTV.",
      "level": 3,
      "page": 223
    },
    {
      "heading": "CDN: Videos are stored in CDN. When you press play, a video is streamed from the CDN.",
      "level": 3,
      "page": 223
    },
    {
      "heading": "API servers: Everything else except video streaming goes through API servers. This includes",
      "level": 3,
      "page": 223
    },
    {
      "heading": "user signup, etc.",
      "level": 3,
      "page": 223
    },
    {
      "heading": "In the question/answer session, the interviewer showed interests in two flows:",
      "level": 3,
      "page": 223
    },
    {
      "heading": "• Video uploading flow",
      "level": 3,
      "page": 223
    },
    {
      "heading": "• Video streaming flow",
      "level": 3,
      "page": 223
    },
    {
      "heading": "We will explore the high-level design for each of them.",
      "level": 3,
      "page": 223
    },
    {
      "heading": "Video uploading flow",
      "level": 3,
      "page": 223
    },
    {
      "heading": "Figure 14-4 shows the high-level design for the video uploading.",
      "level": 3,
      "page": 223
    },
    {
      "heading": "It consists of the following components:",
      "level": 3,
      "page": 224
    },
    {
      "heading": "• User: A user watches YouTube on devices such as a computer, mobile phone, or smart",
      "level": 3,
      "page": 224
    },
    {
      "heading": "TV.",
      "level": 3,
      "page": 224
    },
    {
      "heading": "• Load balancer: A load balancer evenly distributes requests among API servers.",
      "level": 3,
      "page": 224
    },
    {
      "heading": "• API servers: All user requests go through API servers except video streaming.",
      "level": 3,
      "page": 224
    },
    {
      "heading": "• Metadata DB: Video metadata are stored in Metadata DB. It is sharded and replicated to",
      "level": 3,
      "page": 224
    },
    {
      "heading": "meet performance and high availability requirements.",
      "level": 3,
      "page": 224
    },
    {
      "heading": "• Metadata cache: For better performance, video metadata and user objects are cached.",
      "level": 3,
      "page": 224
    },
    {
      "heading": "• Original storage: A blob storage system is used to store original videos. A quotation in",
      "level": 3,
      "page": 224
    },
    {
      "heading": "Wikipedia regarding blob storage shows that: “A Binary Large Object (BLOB) is a",
      "level": 3,
      "page": 224
    },
    {
      "heading": "collection of binary data stored as a single entity in a database management system” [6].",
      "level": 3,
      "page": 224
    },
    {
      "heading": "• Transcoding servers: Video transcoding is also called video encoding. It is the process of",
      "level": 3,
      "page": 224
    },
    {
      "heading": "converting a video format to other formats (MPEG, HLS, etc), which provide the best",
      "level": 3,
      "page": 224
    },
    {
      "heading": "video streams possible for different devices and bandwidth capabilities.",
      "level": 3,
      "page": 224
    },
    {
      "heading": "• Transcoded storage: It is a blob storage that stores transcoded video files.",
      "level": 3,
      "page": 225
    },
    {
      "heading": "• CDN: Videos are cached in CDN. When you click the play button, a video is streamed",
      "level": 3,
      "page": 225
    },
    {
      "heading": "from the CDN.",
      "level": 3,
      "page": 225
    },
    {
      "heading": "• Completion queue: It is a message queue that stores information about video transcoding",
      "level": 3,
      "page": 225
    },
    {
      "heading": "completion events.",
      "level": 3,
      "page": 225
    },
    {
      "heading": "• Completion handler: This consists of a list of workers that pull event data from the",
      "level": 3,
      "page": 225
    },
    {
      "heading": "completion queue and update metadata cache and database.",
      "level": 3,
      "page": 225
    },
    {
      "heading": "Now that we understand each component individually, let us examine how the video",
      "level": 3,
      "page": 225
    },
    {
      "heading": "uploading flow works. The flow is broken down into two processes running in parallel.",
      "level": 3,
      "page": 225
    },
    {
      "heading": "a. Upload the actual video.",
      "level": 3,
      "page": 225
    },
    {
      "heading": "b. Update video metadata. Metadata contains information about video URL, size,",
      "level": 3,
      "page": 225
    },
    {
      "heading": "resolution, format, user info, etc.",
      "level": 3,
      "page": 225
    },
    {
      "heading": "Flow a: upload the actual video",
      "level": 3,
      "page": 225
    },
    {
      "heading": "Figure 14-5 shows how to upload the actual video. The explanation is shown below:",
      "level": 3,
      "page": 226
    },
    {
      "heading": "1. Videos are uploaded to the original storage.",
      "level": 3,
      "page": 226
    },
    {
      "heading": "2. Transcoding servers fetch videos from the original storage and start transcoding.",
      "level": 3,
      "page": 226
    },
    {
      "heading": "3. Once transcoding is complete, the following two steps are executed in parallel:",
      "level": 3,
      "page": 226
    },
    {
      "heading": "3a. Transcoded videos are sent to transcoded storage.",
      "level": 3,
      "page": 226
    },
    {
      "heading": "3b. Transcoding completion events are queued in the completion queue.",
      "level": 3,
      "page": 226
    },
    {
      "heading": "3a.1. Transcoded videos are distributed to CDN.",
      "level": 3,
      "page": 226
    },
    {
      "heading": "3b.1. Completion handler contains a bunch of workers that continuously pull event data",
      "level": 3,
      "page": 226
    },
    {
      "heading": "from the queue.",
      "level": 3,
      "page": 226
    },
    {
      "heading": "3b.1.a. and 3b.1.b. Completion handler updates the metadata database and cache when",
      "level": 3,
      "page": 227
    },
    {
      "heading": "video transcoding is complete.",
      "level": 3,
      "page": 227
    },
    {
      "heading": "4. API servers inform the client that the video is successfully uploaded and is ready for",
      "level": 3,
      "page": 227
    },
    {
      "heading": "streaming.",
      "level": 3,
      "page": 227
    },
    {
      "heading": "Flow b: update the metadata",
      "level": 3,
      "page": 227
    },
    {
      "heading": "While a file is being uploaded to the original storage, the client in parallel sends a request to",
      "level": 3,
      "page": 227
    },
    {
      "heading": "update the video metadata as shown in Figure 14-6. The request contains video metadata,",
      "level": 3,
      "page": 227
    },
    {
      "heading": "Video streaming flow",
      "level": 3,
      "page": 227
    },
    {
      "heading": "Whenever you watch a video on YouTube, it usually starts streaming immediately and you",
      "level": 3,
      "page": 227
    },
    {
      "heading": "do not wait until the whole video is downloaded. Downloading means the whole video is",
      "level": 3,
      "page": 227
    },
    {
      "heading": "copied to your device, while streaming means your device continuously receives video",
      "level": 3,
      "page": 227
    },
    {
      "heading": "streams from remote source videos. When you watch streaming videos, your client loads a",
      "level": 3,
      "page": 227
    },
    {
      "heading": "little bit of data at a time so you can watch videos immediately and continuously.",
      "level": 3,
      "page": 227
    },
    {
      "heading": "Before we discuss video streaming flow, let us look at an important concept: streaming",
      "level": 3,
      "page": 227
    },
    {
      "heading": "protocol. This is a standardized way to control data transfer for video streaming. Popular",
      "level": 3,
      "page": 227
    },
    {
      "heading": "streaming protocols are:",
      "level": 3,
      "page": 227
    },
    {
      "heading": "• MPEG–DASH. MPEG stands for “Moving Picture Experts Group” and DASH stands for",
      "level": 3,
      "page": 227
    },
    {
      "heading": "\"Dynamic Adaptive Streaming over HTTP\".",
      "level": 3,
      "page": 227
    },
    {
      "heading": "• Apple HLS. HLS stands for “HTTP Live Streaming”.",
      "level": 3,
      "page": 227
    },
    {
      "heading": "• Microsoft Smooth Streaming.",
      "level": 3,
      "page": 227
    },
    {
      "heading": "• Adobe HTTP Dynamic Streaming (HDS).",
      "level": 3,
      "page": 227
    },
    {
      "heading": "You do not need to fully understand or even remember those streaming protocol names as",
      "level": 3,
      "page": 228
    },
    {
      "heading": "they are low-level details that require specific domain knowledge. The important thing here is",
      "level": 3,
      "page": 228
    },
    {
      "heading": "to understand that different streaming protocols support different video encodings and",
      "level": 3,
      "page": 228
    },
    {
      "heading": "playback players. When we design a video streaming service, we have to choose the right",
      "level": 3,
      "page": 228
    },
    {
      "heading": "streaming protocol to support our use cases. To learn more about streaming protocols, here is",
      "level": 3,
      "page": 228
    },
    {
      "heading": "an excellent article [7].",
      "level": 3,
      "page": 228
    },
    {
      "heading": "Videos are streamed from CDN directly. The edge server closest to you will deliver the",
      "level": 3,
      "page": 228
    },
    {
      "heading": "video. Thus, there is very little latency. Figure 14-7 shows a high level of design for video",
      "level": 3,
      "page": 228
    },
    {
      "heading": "streaming.",
      "level": 3,
      "page": 228
    },
    {
      "heading": "Step 3 - Design deep dive",
      "level": 3,
      "page": 229
    },
    {
      "heading": "In the high-level design, the entire system is broken down in two parts: video uploading flow",
      "level": 3,
      "page": 229
    },
    {
      "heading": "and video streaming flow. In this section, we will refine both flows with important",
      "level": 3,
      "page": 229
    },
    {
      "heading": "optimizations and introduce error handling mechanisms.",
      "level": 3,
      "page": 229
    },
    {
      "heading": "Video transcoding",
      "level": 3,
      "page": 229
    },
    {
      "heading": "When you record a video, the device (usually a phone or camera) gives the video file a",
      "level": 3,
      "page": 229
    },
    {
      "heading": "certain format. If you want the video to be played smoothly on other devices, the video must",
      "level": 3,
      "page": 229
    },
    {
      "heading": "be encoded into compatible bitrates and formats. Bitrate is the rate at which bits are processed",
      "level": 3,
      "page": 229
    },
    {
      "heading": "over time. A higher bitrate generally means higher video quality. High bitrate streams need",
      "level": 3,
      "page": 229
    },
    {
      "heading": "more processing power and fast internet speed.",
      "level": 3,
      "page": 229
    },
    {
      "heading": "Video transcoding is important for the following reasons:",
      "level": 3,
      "page": 229
    },
    {
      "heading": "• Raw video consumes large amounts of storage space. An hour-long high definition video",
      "level": 3,
      "page": 229
    },
    {
      "heading": "recorded at 60 frames per second can take up a few hundred GB of space.",
      "level": 3,
      "page": 229
    },
    {
      "heading": "• Many devices and browsers only support certain types of video formats. Thus, it is",
      "level": 3,
      "page": 229
    },
    {
      "heading": "important to encode a video to different formats for compatibility reasons.",
      "level": 3,
      "page": 229
    },
    {
      "heading": "• To ensure users watch high-quality videos while maintaining smooth playback, it is a",
      "level": 3,
      "page": 229
    },
    {
      "heading": "good idea to deliver higher resolution video to users who have high network bandwidth",
      "level": 3,
      "page": 229
    },
    {
      "heading": "and lower resolution video to users who have low bandwidth.",
      "level": 3,
      "page": 229
    },
    {
      "heading": "• Network conditions can change, especially on mobile devices. To ensure a video is",
      "level": 3,
      "page": 229
    },
    {
      "heading": "played continuously, switching video quality automatically or manually based on network",
      "level": 3,
      "page": 229
    },
    {
      "heading": "conditions is essential for smooth user experience.",
      "level": 3,
      "page": 229
    },
    {
      "heading": "Many types of encoding formats are available; however, most of them contain two parts:",
      "level": 3,
      "page": 229
    },
    {
      "heading": "• Container: This is like a basket that contains the video file, audio, and metadata. You can",
      "level": 3,
      "page": 229
    },
    {
      "heading": "tell the container format by the file extension, such as .avi, .mov, or .mp4.",
      "level": 3,
      "page": 229
    },
    {
      "heading": "• Codecs: These are compression and decompression algorithms aim to reduce the video",
      "level": 3,
      "page": 229
    },
    {
      "heading": "size while preserving the video quality. The most used video codecs are H.264, VP9, and",
      "level": 3,
      "page": 229
    },
    {
      "heading": "HEVC.",
      "level": 3,
      "page": 229
    },
    {
      "heading": "Directed acyclic graph (DAG) model",
      "level": 3,
      "page": 229
    },
    {
      "heading": "Transcoding a video is computationally expensive and time-consuming. Besides, different",
      "level": 3,
      "page": 229
    },
    {
      "heading": "content creators may have different video processing requirements. For instance, some",
      "level": 3,
      "page": 229
    },
    {
      "heading": "content creators require watermarks on top of their videos, some provide thumbnail images",
      "level": 3,
      "page": 229
    },
    {
      "heading": "themselves, and some upload high definition videos, whereas others do not.",
      "level": 3,
      "page": 229
    },
    {
      "heading": "To support different video processing pipelines and maintain high parallelism, it is important",
      "level": 3,
      "page": 229
    },
    {
      "heading": "to add some level of abstraction and let client programmers define what tasks to execute. For",
      "level": 3,
      "page": 229
    },
    {
      "heading": "example, Facebook’s streaming video engine uses a directed acyclic graph (DAG)",
      "level": 3,
      "page": 229
    },
    {
      "heading": "programming model, which defines tasks in stages so they can be executed sequentially or",
      "level": 3,
      "page": 229
    },
    {
      "heading": "parallelly [8]. In our design, we adopt a similar DAG model to achieve flexibility and",
      "level": 3,
      "page": 229
    },
    {
      "heading": "parallelism. Figure 14-8 represents a DAG for video transcoding.",
      "level": 3,
      "page": 229
    },
    {
      "heading": "In Figure 14-8, the original video is split into video, audio, and metadata. Here are some of",
      "level": 3,
      "page": 230
    },
    {
      "heading": "the tasks that can be applied on a video file:",
      "level": 3,
      "page": 230
    },
    {
      "heading": "• Inspection: Make sure videos have good quality and are not malformed.",
      "level": 3,
      "page": 230
    },
    {
      "heading": "• Video encodings: Videos are converted to support different resolutions, codec, bitrates,",
      "level": 3,
      "page": 230
    },
    {
      "heading": "etc. Figure 14-9 shows an example of video encoded files.",
      "level": 3,
      "page": 230
    },
    {
      "heading": "• Thumbnail. Thumbnails can either be uploaded by a user or automatically generated by",
      "level": 3,
      "page": 230
    },
    {
      "heading": "the system.",
      "level": 3,
      "page": 230
    },
    {
      "heading": "• Watermark: An image overlay on top of your video contains identifying information",
      "level": 3,
      "page": 230
    },
    {
      "heading": "about your video.",
      "level": 3,
      "page": 230
    },
    {
      "heading": "Video transcoding architecture",
      "level": 3,
      "page": 231
    },
    {
      "heading": "The proposed video transcoding architecture that leverages the cloud services, is shown in",
      "level": 3,
      "page": 231
    },
    {
      "heading": "Figure 14-10.",
      "level": 3,
      "page": 231
    },
    {
      "heading": "The architecture has six main components: preprocessor, DAG scheduler, resource manager,",
      "level": 3,
      "page": 231
    },
    {
      "heading": "task workers, temporary storage, and encoded video as the output. Let us take a close look at",
      "level": 3,
      "page": 231
    },
    {
      "heading": "each component.",
      "level": 3,
      "page": 231
    },
    {
      "heading": "Preprocessor",
      "level": 3,
      "page": 231
    },
    {
      "heading": "The preprocessor has 4 responsibilities:",
      "level": 3,
      "page": 232
    },
    {
      "heading": "1. Video splitting. Video stream is split or further split into smaller Group of Pictures (GOP)",
      "level": 3,
      "page": 232
    },
    {
      "heading": "alignment. GOP is a group/chunk of frames arranged in a specific order. Each chunk is an",
      "level": 3,
      "page": 232
    },
    {
      "heading": "independently playable unit, usually a few seconds in length.",
      "level": 3,
      "page": 232
    },
    {
      "heading": "2. Some old mobile devices or browsers might not support video splitting. Preprocessor split",
      "level": 3,
      "page": 232
    },
    {
      "heading": "videos by GOP alignment for old clients.",
      "level": 3,
      "page": 232
    },
    {
      "heading": "3. DAG generation. The processor generates DAG based on configuration files client",
      "level": 3,
      "page": 232
    },
    {
      "heading": "programmers write. Figure 14-12 is a simplified DAG representation which has 2 nodes and",
      "level": 3,
      "page": 232
    },
    {
      "heading": "1 edge:",
      "level": 3,
      "page": 232
    },
    {
      "heading": "This DAG representation is generated from the two configuration files below (Figure 14-13):",
      "level": 3,
      "page": 232
    },
    {
      "heading": "4. Cache data. The preprocessor is a cache for segmented videos. For better reliability, the",
      "level": 3,
      "page": 232
    },
    {
      "heading": "preprocessor stores GOPs and metadata in temporary storage. If video encoding fails, the",
      "level": 3,
      "page": 232
    },
    {
      "heading": "system could use persisted data for retry operations.",
      "level": 3,
      "page": 232
    },
    {
      "heading": "DAG scheduler",
      "level": 3,
      "page": 232
    },
    {
      "heading": "The DAG scheduler splits a DAG graph into stages of tasks and puts them in the task queue",
      "level": 3,
      "page": 233
    },
    {
      "heading": "in the resource manager. Figure 14-15 shows an example of how the DAG scheduler works.",
      "level": 3,
      "page": 233
    },
    {
      "heading": "As shown in Figure 14-15, the original video is split into three stages: Stage 1: video, audio,",
      "level": 3,
      "page": 233
    },
    {
      "heading": "and metadata. The video file is further split into two tasks in stage 2: video encoding and",
      "level": 3,
      "page": 233
    },
    {
      "heading": "thumbnail. The audio file requires audio encoding as part of the stage 2 tasks.",
      "level": 3,
      "page": 233
    },
    {
      "heading": "Resource manager",
      "level": 3,
      "page": 233
    },
    {
      "heading": "The resource manager is responsible for managing the efficiency of resource allocation. It",
      "level": 3,
      "page": 234
    },
    {
      "heading": "contains 3 queues and a task scheduler as shown in Figure 14-17.",
      "level": 3,
      "page": 234
    },
    {
      "heading": "• Task queue: It is a priority queue that contains tasks to be executed.",
      "level": 3,
      "page": 234
    },
    {
      "heading": "• Worker queue: It is a priority queue that contains worker utilization info.",
      "level": 3,
      "page": 234
    },
    {
      "heading": "• Running queue: It contains info about the currently running tasks and workers running",
      "level": 3,
      "page": 234
    },
    {
      "heading": "the tasks.",
      "level": 3,
      "page": 234
    },
    {
      "heading": "• Task scheduler: It picks the optimal task/worker, and instructs the chosen task worker to",
      "level": 3,
      "page": 234
    },
    {
      "heading": "execute the job.",
      "level": 3,
      "page": 234
    },
    {
      "heading": "The resource manager works as follows:",
      "level": 3,
      "page": 234
    },
    {
      "heading": "• The task scheduler gets the highest priority task from the task queue.",
      "level": 3,
      "page": 234
    },
    {
      "heading": "• The task scheduler gets the optimal task worker to run the task from the worker queue.",
      "level": 3,
      "page": 234
    },
    {
      "heading": "• The task scheduler instructs the chosen task worker to run the task.",
      "level": 3,
      "page": 234
    },
    {
      "heading": "• The task scheduler binds the task/worker info and puts it in the running queue.",
      "level": 3,
      "page": 234
    },
    {
      "heading": "• The task scheduler removes the job from the running queue once the job is done.",
      "level": 3,
      "page": 234
    },
    {
      "heading": "Task workers",
      "level": 3,
      "page": 234
    },
    {
      "heading": "Task workers run the tasks which are defined in the DAG. Different task workers may run",
      "level": 3,
      "page": 235
    },
    {
      "heading": "different tasks as shown in Figure 14-19.",
      "level": 3,
      "page": 235
    },
    {
      "heading": "Temporary storage",
      "level": 3,
      "page": 235
    },
    {
      "heading": "Multiple storage systems are used here. The choice of storage system depends on factors like",
      "level": 3,
      "page": 235
    },
    {
      "heading": "accessed by workers, and the data size is usually small. Thus, caching metadata in memory is",
      "level": 3,
      "page": 236
    },
    {
      "heading": "a good idea. For video or audio data, we put them in blob storage. Data in temporary storage",
      "level": 3,
      "page": 236
    },
    {
      "heading": "is freed up once the corresponding video processing is complete.",
      "level": 3,
      "page": 236
    },
    {
      "heading": "Encoded video",
      "level": 3,
      "page": 236
    },
    {
      "heading": "Encoded video is the final output of the encoding pipeline. Here is an example of the output:",
      "level": 3,
      "page": 236
    },
    {
      "heading": "funny_720p.mp4 .",
      "level": 3,
      "page": 236
    },
    {
      "heading": "System optimizations",
      "level": 3,
      "page": 236
    },
    {
      "heading": "At this point, you ought to have good understanding about the video uploading flow, video",
      "level": 3,
      "page": 236
    },
    {
      "heading": "streaming flow and video transcoding. Next, we will refine the system with optimizations,",
      "level": 3,
      "page": 236
    },
    {
      "heading": "including speed, safety, and cost-saving.",
      "level": 3,
      "page": 236
    },
    {
      "heading": "Speed optimization: parallelize video uploading",
      "level": 3,
      "page": 236
    },
    {
      "heading": "Uploading a video as a whole unit is inefficient. We can split a video into smaller chunks by",
      "level": 3,
      "page": 236
    },
    {
      "heading": "GOP alignment as shown in Figure 14-22.",
      "level": 3,
      "page": 236
    },
    {
      "heading": "This allows fast resumable uploads when the previous upload failed. The job of splitting a",
      "level": 3,
      "page": 236
    },
    {
      "heading": "video file by GOP can be implemented by the client to improve the upload speed as shown in",
      "level": 3,
      "page": 236
    },
    {
      "heading": "Figure 14-23.",
      "level": 3,
      "page": 236
    },
    {
      "heading": "Speed optimization: place upload centers close to users",
      "level": 3,
      "page": 236
    },
    {
      "heading": "Another way to improve the upload speed is by setting up multiple upload centers across the",
      "level": 3,
      "page": 236
    },
    {
      "heading": "globe (Figure 14-24). People in the United States can upload videos to the North America",
      "level": 3,
      "page": 237
    },
    {
      "heading": "upload center, and people in China can upload videos to the Asian upload center. To achieve",
      "level": 3,
      "page": 237
    },
    {
      "heading": "this, we use CDN as upload centers.",
      "level": 3,
      "page": 237
    },
    {
      "heading": "Speed optimization: parallelism everywhere",
      "level": 3,
      "page": 237
    },
    {
      "heading": "Achieving low latency requires serious efforts. Another optimization is to build a loosely",
      "level": 3,
      "page": 237
    },
    {
      "heading": "coupled system and enable high parallelism.",
      "level": 3,
      "page": 237
    },
    {
      "heading": "Our design needs some modifications to achieve high parallelism. Let us zoom in to the flow",
      "level": 3,
      "page": 237
    },
    {
      "heading": "of how a video is transferred from original storage to the CDN. The flow is shown in Figure",
      "level": 3,
      "page": 237
    },
    {
      "heading": "14-25, revealing that the output depends on the input of the previous step. This dependency",
      "level": 3,
      "page": 237
    },
    {
      "heading": "makes parallelism difficult.",
      "level": 3,
      "page": 237
    },
    {
      "heading": "To make the system more loosely coupled, we introduced message queues as shown in Figure",
      "level": 3,
      "page": 237
    },
    {
      "heading": "14-26. Let us use an example to explain how message queues make the system more loosely",
      "level": 3,
      "page": 238
    },
    {
      "heading": "coupled.",
      "level": 3,
      "page": 238
    },
    {
      "heading": "• Before the message queue is introduced, the encoding module must wait for the output of",
      "level": 3,
      "page": 238
    },
    {
      "heading": "the download module.",
      "level": 3,
      "page": 238
    },
    {
      "heading": "• After the message queue is introduced, the encoding module does not need to wait for the",
      "level": 3,
      "page": 238
    },
    {
      "heading": "output of the download module anymore. If there are events in the message queue, the",
      "level": 3,
      "page": 238
    },
    {
      "heading": "encoding module can execute those jobs in parallel.",
      "level": 3,
      "page": 238
    },
    {
      "heading": "Safety optimization: pre-signed upload URL",
      "level": 3,
      "page": 238
    },
    {
      "heading": "Safety is one of the most important aspects of any product. To ensure only authorized users",
      "level": 3,
      "page": 238
    },
    {
      "heading": "upload videos to the right location, we introduce pre-signed URLs as shown in Figure 14-27.",
      "level": 3,
      "page": 238
    },
    {
      "heading": "The upload flow is updated as follows:",
      "level": 3,
      "page": 239
    },
    {
      "heading": "1. The client makes a HTTP request to API servers to fetch the pre-signed URL, which",
      "level": 3,
      "page": 239
    },
    {
      "heading": "gives the access permission to the object identified in the URL. The term pre-signed URL",
      "level": 3,
      "page": 239
    },
    {
      "heading": "is used by uploading files to Amazon S3. Other cloud service providers might use a",
      "level": 3,
      "page": 239
    },
    {
      "heading": "different name. For instance, Microsoft Azure blob storage supports the same feature, but",
      "level": 3,
      "page": 239
    },
    {
      "heading": "call it “Shared Access Signature” [10].",
      "level": 3,
      "page": 239
    },
    {
      "heading": "2. API servers respond with a pre-signed URL.",
      "level": 3,
      "page": 239
    },
    {
      "heading": "3. Once the client receives the response, it uploads the video using the pre-signed URL.",
      "level": 3,
      "page": 239
    },
    {
      "heading": "Safety optimization: protect your videos",
      "level": 3,
      "page": 239
    },
    {
      "heading": "Many content makers are reluctant to post videos online because they fear their original",
      "level": 3,
      "page": 239
    },
    {
      "heading": "videos will be stolen. To protect copyrighted videos, we can adopt one of the following three",
      "level": 3,
      "page": 239
    },
    {
      "heading": "safety options:",
      "level": 3,
      "page": 239
    },
    {
      "heading": "• Digital rights management (DRM) systems: Three major DRM systems are Apple",
      "level": 3,
      "page": 239
    },
    {
      "heading": "FairPlay, Google Widevine, and Microsoft PlayReady.",
      "level": 3,
      "page": 239
    },
    {
      "heading": "• AES encryption: You can encrypt a video and configure an authorization policy. The",
      "level": 3,
      "page": 239
    },
    {
      "heading": "encrypted video will be decrypted upon playback. This ensures that only authorized users",
      "level": 3,
      "page": 239
    },
    {
      "heading": "can watch an encrypted video.",
      "level": 3,
      "page": 239
    },
    {
      "heading": "• Visual watermarking: This is an image overlay on top of your video that contains",
      "level": 3,
      "page": 239
    },
    {
      "heading": "identifying information for your video. It can be your company logo or company name.",
      "level": 3,
      "page": 239
    },
    {
      "heading": "Cost-saving optimization",
      "level": 3,
      "page": 239
    },
    {
      "heading": "CDN is a crucial component of our system. It ensures fast video delivery on a global scale.",
      "level": 3,
      "page": 239
    },
    {
      "heading": "However, from the back of the envelope calculation, we know CDN is expensive, especially",
      "level": 3,
      "page": 239
    },
    {
      "heading": "when the data size is large. How can we reduce the cost?",
      "level": 3,
      "page": 239
    },
    {
      "heading": "Previous research shows that YouTube video streams follow long-tail distribution [11] [12].",
      "level": 3,
      "page": 239
    },
    {
      "heading": "It means a few popular videos are accessed frequently but many others have few or no",
      "level": 3,
      "page": 239
    },
    {
      "heading": "viewers. Based on this observation, we implement a few optimizations:",
      "level": 3,
      "page": 239
    },
    {
      "heading": "1. Only serve the most popular videos from CDN and other videos from our high capacity",
      "level": 3,
      "page": 239
    },
    {
      "heading": "storage video servers (Figure 14-28).",
      "level": 3,
      "page": 240
    },
    {
      "heading": "2. For less popular content, we may not need to store many encoded video versions. Short",
      "level": 3,
      "page": 240
    },
    {
      "heading": "videos can be encoded on-demand.",
      "level": 3,
      "page": 240
    },
    {
      "heading": "3. Some videos are popular only in certain regions. There is no need to distribute these",
      "level": 3,
      "page": 240
    },
    {
      "heading": "videos to other regions.",
      "level": 3,
      "page": 240
    },
    {
      "heading": "4. Build your own CDN like Netflix and partner with Internet Service Providers (ISPs).",
      "level": 3,
      "page": 240
    },
    {
      "heading": "Building your CDN is a giant project; however, this could make sense for large streaming",
      "level": 3,
      "page": 240
    },
    {
      "heading": "companies. An ISP can be Comcast, AT&T, Verizon, or other internet providers. ISPs are",
      "level": 3,
      "page": 240
    },
    {
      "heading": "located all around the world and are close to users. By partnering with ISPs, you can",
      "level": 3,
      "page": 240
    },
    {
      "heading": "improve the viewing experience and reduce the bandwidth charges.",
      "level": 3,
      "page": 240
    },
    {
      "heading": "is important to analyze historical viewing patterns before doing any optimization. Here are",
      "level": 3,
      "page": 240
    },
    {
      "heading": "some of the interesting articles on this topic: [12] [13].",
      "level": 3,
      "page": 240
    },
    {
      "heading": "Error handling",
      "level": 3,
      "page": 240
    },
    {
      "heading": "For a large-scale system, system errors are unavoidable. To build a highly fault-tolerant",
      "level": 3,
      "page": 240
    },
    {
      "heading": "system, we must handle errors gracefully and recover from them fast. Two types of errors",
      "level": 3,
      "page": 240
    },
    {
      "heading": "exist:",
      "level": 3,
      "page": 240
    },
    {
      "heading": "• Recoverable error. For recoverable errors such as video segment fails to transcode, the",
      "level": 3,
      "page": 240
    },
    {
      "heading": "general idea is to retry the operation a few times. If the task continues to fail and the",
      "level": 3,
      "page": 240
    },
    {
      "heading": "system believes it is not recoverable, it returns a proper error code to the client.",
      "level": 3,
      "page": 240
    },
    {
      "heading": "• Non-recoverable error. For non-recoverable errors such as malformed video format, the",
      "level": 3,
      "page": 240
    },
    {
      "heading": "system stops the running tasks associated with the video and returns the proper error code",
      "level": 3,
      "page": 240
    },
    {
      "heading": "to the client.",
      "level": 3,
      "page": 240
    },
    {
      "heading": "Typical errors for each system component are covered by the following playbook:",
      "level": 3,
      "page": 240
    },
    {
      "heading": "• Upload error: retry a few times.",
      "level": 3,
      "page": 240
    },
    {
      "heading": "• Split video error: if older versions of clients cannot split videos by GOP alignment, the",
      "level": 3,
      "page": 241
    },
    {
      "heading": "entire video is passed to the server. The job of splitting videos is done on the server-side.",
      "level": 3,
      "page": 241
    },
    {
      "heading": "• Transcoding error: retry.",
      "level": 3,
      "page": 241
    },
    {
      "heading": "• Preprocessor error: regenerate DAG diagram.",
      "level": 3,
      "page": 241
    },
    {
      "heading": "• DAG scheduler error: reschedule a task.",
      "level": 3,
      "page": 241
    },
    {
      "heading": "• Resource manager queue down: use a replica.",
      "level": 3,
      "page": 241
    },
    {
      "heading": "• Task worker down: retry the task on a new worker.",
      "level": 3,
      "page": 241
    },
    {
      "heading": "• API server down: API servers are stateless so requests will be directed to a different API",
      "level": 3,
      "page": 241
    },
    {
      "heading": "server.",
      "level": 3,
      "page": 241
    },
    {
      "heading": "• Metadata cache server down: data is replicated multiple times. If one node goes down,",
      "level": 3,
      "page": 241
    },
    {
      "heading": "you can still access other nodes to fetch data. We can bring up a new cache server to",
      "level": 3,
      "page": 241
    },
    {
      "heading": "replace the dead one.",
      "level": 3,
      "page": 241
    },
    {
      "heading": "• Metadata DB server down:",
      "level": 3,
      "page": 241
    },
    {
      "heading": "• Master is down. If the master is down, promote one of the slaves to act as the new",
      "level": 3,
      "page": 241
    },
    {
      "heading": "master.",
      "level": 3,
      "page": 241
    },
    {
      "heading": "• Slave is down. If a slave goes down, you can use another slave for reads and bring",
      "level": 3,
      "page": 241
    },
    {
      "heading": "up another database server to replace the dead one.",
      "level": 3,
      "page": 241
    },
    {
      "heading": "Step 4 - Wrap up",
      "level": 3,
      "page": 242
    },
    {
      "heading": "In this chapter, we presented the architecture design for video streaming services like",
      "level": 3,
      "page": 242
    },
    {
      "heading": "YouTube. If there is extra time at the end of the interview, here are a few additional points:",
      "level": 3,
      "page": 242
    },
    {
      "heading": "• Scale the API tier: Because API servers are stateless, it is easy to scale API tier",
      "level": 3,
      "page": 242
    },
    {
      "heading": "horizontally.",
      "level": 3,
      "page": 242
    },
    {
      "heading": "• Scale the database: You can talk about database replication and sharding.",
      "level": 3,
      "page": 242
    },
    {
      "heading": "• Live streaming: It refers to the process of how a video is recorded and broadcasted in real",
      "level": 3,
      "page": 242
    },
    {
      "heading": "time. Although our system is not designed specifically for live streaming, live streaming",
      "level": 3,
      "page": 242
    },
    {
      "heading": "and non-live streaming have some similarities: both require uploading, encoding, and",
      "level": 3,
      "page": 242
    },
    {
      "heading": "streaming. The notable differences are:",
      "level": 3,
      "page": 242
    },
    {
      "heading": "• Live streaming has a higher latency requirement, so it might need a different",
      "level": 3,
      "page": 242
    },
    {
      "heading": "streaming protocol.",
      "level": 3,
      "page": 242
    },
    {
      "heading": "• Live streaming has a lower requirement for parallelism because small chunks of data",
      "level": 3,
      "page": 242
    },
    {
      "heading": "are already processed in real-time.",
      "level": 3,
      "page": 242
    },
    {
      "heading": "• Live streaming requires different sets of error handling. Any error handling that",
      "level": 3,
      "page": 242
    },
    {
      "heading": "takes too much time is not acceptable.",
      "level": 3,
      "page": 242
    },
    {
      "heading": "• Video takedowns: Videos that violate copyrights, pornography, or other illegal acts shall",
      "level": 3,
      "page": 242
    },
    {
      "heading": "be removed. Some can be discovered by the system during the upload process, while",
      "level": 3,
      "page": 242
    },
    {
      "heading": "others might be discovered through user flagging.",
      "level": 3,
      "page": 242
    },
    {
      "heading": "Congratulations on getting this far! Now give yourself a pat on the back. Good job!",
      "level": 3,
      "page": 242
    },
    {
      "heading": "Reference materials",
      "level": 2,
      "page": 243
    },
    {
      "heading": "[1] YouTube by the numbers: https://www.omnicoreagency.com/youtube-statistics/",
      "level": 3,
      "page": 243
    },
    {
      "heading": "[2] 2019 YouTube Demographics:",
      "level": 3,
      "page": 243
    },
    {
      "heading": "https://blog.hubspot.com/marketing/youtube-demographics",
      "level": 3,
      "page": 243
    },
    {
      "heading": "[3] Cloudfront Pricing: https://aws.amazon.com/cloudfront/pricing/",
      "level": 3,
      "page": 243
    },
    {
      "heading": "[4] Netflix on AWS: https://aws.amazon.com/solutions/case-studies/netflix/",
      "level": 3,
      "page": 243
    },
    {
      "heading": "[5] Akamai homepage:  https://www.akamai.com/",
      "level": 3,
      "page": 243
    },
    {
      "heading": "[6] Binary large object:  https://en.wikipedia.org/wiki/Binary_large_object",
      "level": 3,
      "page": 243
    },
    {
      "heading": "[7] Here’s What You Need to Know About Streaming Protocols:",
      "level": 3,
      "page": 243
    },
    {
      "heading": "https://www.dacast.com/blog/streaming-protocols/",
      "level": 3,
      "page": 243
    },
    {
      "heading": "[8]  SVE: Distributed Video Processing at Facebook Scale:",
      "level": 3,
      "page": 243
    },
    {
      "heading": "https://www.cs.princeton.edu/~wlloyd/papers/sve-sosp17.pdf",
      "level": 3,
      "page": 243
    },
    {
      "heading": "[9] Weibo video processing architecture (in Chinese):",
      "level": 3,
      "page": 243
    },
    {
      "heading": "https://www.upyun.com/opentalk/399.html",
      "level": 3,
      "page": 243
    },
    {
      "heading": "[10] Delegate access with a shared access signature:",
      "level": 3,
      "page": 243
    },
    {
      "heading": "https://docs.microsoft.com/en-us/rest/api/storageservices/delegate-access-with-shared-access-",
      "level": 3,
      "page": 243
    },
    {
      "heading": "signature",
      "level": 3,
      "page": 243
    },
    {
      "heading": "[11] YouTube scalability talk by early YouTube employee: https://www.youtube.com/watch?",
      "level": 3,
      "page": 243
    },
    {
      "heading": "v=w5WVu624fY8",
      "level": 3,
      "page": 243
    },
    {
      "heading": "[12] Understanding the characteristics of internet short video sharing: A youtube-based",
      "level": 3,
      "page": 243
    },
    {
      "heading": "measurement study. https://arxiv.org/pdf/0707.3670.pdf",
      "level": 3,
      "page": 243
    },
    {
      "heading": "[13] Content Popularity for Open Connect:",
      "level": 3,
      "page": 243
    },
    {
      "heading": "https://netflixtechblog.com/content-popularity-for-open-connect-b86d56f613b",
      "level": 3,
      "page": 243
    },
    {
      "heading": "CHAPTER 15: DESIGN GOOGLE DRIVE",
      "level": 1,
      "page": 244
    },
    {
      "heading": "In recent years, cloud storage services such as Google Drive, Dropbox, Microsoft OneDrive,",
      "level": 3,
      "page": 244
    },
    {
      "heading": "and Apple iCloud have become very popular. In this chapter, you are asked to design Google",
      "level": 3,
      "page": 244
    },
    {
      "heading": "Drive.",
      "level": 3,
      "page": 244
    },
    {
      "heading": "Let us take a moment to understand Google Drive before jumping into the design. Google",
      "level": 3,
      "page": 244
    },
    {
      "heading": "Drive is a file storage and synchronization service that helps you store documents, photos,",
      "level": 3,
      "page": 244
    },
    {
      "heading": "videos, and other files in the cloud. You can access your files from any computer,",
      "level": 3,
      "page": 244
    },
    {
      "heading": "smartphone, and tablet. You can easily share those files with friends, family, and coworkers",
      "level": 3,
      "page": 244
    },
    {
      "heading": "[1]. Figure 15-1 and 15-2 show what Google drive looks like on a browser and mobile",
      "level": 3,
      "page": 244
    },
    {
      "heading": "application, respectively.",
      "level": 3,
      "page": 244
    },
    {
      "heading": "Step 1 - Understand the problem and establish design scope",
      "level": 3,
      "page": 246
    },
    {
      "heading": "Designing a Google drive is a big project, so it is important to ask questions to narrow down",
      "level": 3,
      "page": 246
    },
    {
      "heading": "the scope.",
      "level": 3,
      "page": 246
    },
    {
      "heading": "Candidate: What are the most important features?",
      "level": 3,
      "page": 246
    },
    {
      "heading": "Interviewer: Upload and download files, file sync, and notifications.",
      "level": 3,
      "page": 246
    },
    {
      "heading": "Candidate: Is this a mobile app, a web app, or both?",
      "level": 3,
      "page": 246
    },
    {
      "heading": "Interviewer: Both.",
      "level": 3,
      "page": 246
    },
    {
      "heading": "Candidate: What are the supported file formats?",
      "level": 3,
      "page": 246
    },
    {
      "heading": "Interviewer: Any file type.",
      "level": 3,
      "page": 246
    },
    {
      "heading": "Candidate: Do files need to be encrypted?",
      "level": 3,
      "page": 246
    },
    {
      "heading": "Interview: Yes, files in the storage must be encrypted.",
      "level": 3,
      "page": 246
    },
    {
      "heading": "Candidate: Is there a file size limit?",
      "level": 3,
      "page": 246
    },
    {
      "heading": "Interview: Yes, files must be 10 GB or smaller.",
      "level": 3,
      "page": 246
    },
    {
      "heading": "Candidate: How many users does the product have?",
      "level": 3,
      "page": 246
    },
    {
      "heading": "Interviewer: 10M DAU.",
      "level": 3,
      "page": 246
    },
    {
      "heading": "In this chapter, we focus on the following features:",
      "level": 3,
      "page": 246
    },
    {
      "heading": "• Add files. The easiest way to add a file is to drag and drop a file into Google drive.",
      "level": 3,
      "page": 246
    },
    {
      "heading": "• Download files.",
      "level": 3,
      "page": 246
    },
    {
      "heading": "• Sync files across multiple devices. When a file is added to one device, it is automatically",
      "level": 3,
      "page": 246
    },
    {
      "heading": "synced to other devices.",
      "level": 3,
      "page": 246
    },
    {
      "heading": "•  See file revisions.",
      "level": 3,
      "page": 246
    },
    {
      "heading": "• Share files with your friends, family, and coworkers",
      "level": 3,
      "page": 246
    },
    {
      "heading": "• Send a notification when a file is edited, deleted, or shared with you.",
      "level": 3,
      "page": 246
    },
    {
      "heading": "Features not discussed in this chapter include:",
      "level": 3,
      "page": 246
    },
    {
      "heading": "• Google doc editing and collaboration. Google doc allows multiple people to edit the",
      "level": 3,
      "page": 246
    },
    {
      "heading": "same document simultaneously. This is out of our design scope.",
      "level": 3,
      "page": 246
    },
    {
      "heading": "Other than clarifying requirements, it is important to understand non-functional requirements:",
      "level": 3,
      "page": 246
    },
    {
      "heading": "• Reliability. Reliability is extremely important for a storage system. Data loss is",
      "level": 3,
      "page": 246
    },
    {
      "heading": "unacceptable.",
      "level": 3,
      "page": 246
    },
    {
      "heading": "• Fast sync speed. If file sync takes too much time, users will become impatient and",
      "level": 3,
      "page": 246
    },
    {
      "heading": "abandon the product.",
      "level": 3,
      "page": 246
    },
    {
      "heading": "• Bandwidth usage. If a product takes a lot of unnecessary network bandwidth, users will",
      "level": 3,
      "page": 246
    },
    {
      "heading": "be unhappy, especially when they are on a mobile data plan.",
      "level": 3,
      "page": 246
    },
    {
      "heading": "• Scalability. The system should be able to handle high volumes of traffic.",
      "level": 3,
      "page": 246
    },
    {
      "heading": "• High availability. Users should still be able to use the system when some servers are",
      "level": 3,
      "page": 246
    },
    {
      "heading": "offline, slowed down, or have unexpected network errors.",
      "level": 3,
      "page": 246
    },
    {
      "heading": "Back of the envelope estimation",
      "level": 3,
      "page": 246
    },
    {
      "heading": "• Assume the application has 50 million signed up users and 10 million DAU.",
      "level": 3,
      "page": 246
    },
    {
      "heading": "• Users get 10 GB free space.",
      "level": 3,
      "page": 246
    },
    {
      "heading": "• Assume users upload 2 files per day. The average file size is 500 KB.",
      "level": 3,
      "page": 246
    },
    {
      "heading": "• 1:1 read to write ratio.",
      "level": 3,
      "page": 246
    },
    {
      "heading": "• Total space allocated: 50 million * 10 GB = 500 Petabyte",
      "level": 3,
      "page": 247
    },
    {
      "heading": "• QPS for upload API: 10 million * 2 uploads / 24 hours / 3600 seconds = ~ 240",
      "level": 3,
      "page": 247
    },
    {
      "heading": "• Peak QPS = QPS * 2 = 480",
      "level": 3,
      "page": 247
    },
    {
      "heading": "Step 2 - Propose high-level design and get buy-in",
      "level": 3,
      "page": 248
    },
    {
      "heading": "Instead of showing the high-level design diagram from the beginning, we will use a slightly",
      "level": 3,
      "page": 248
    },
    {
      "heading": "different approach. We will start with something simple: build everything in a single server.",
      "level": 3,
      "page": 248
    },
    {
      "heading": "Then, gradually scale it up to support millions of users. By doing this exercise, it will refresh",
      "level": 3,
      "page": 248
    },
    {
      "heading": "your memory about some important topics covered in the book.",
      "level": 3,
      "page": 248
    },
    {
      "heading": "Let us start with a single server setup as listed below:",
      "level": 3,
      "page": 248
    },
    {
      "heading": "• A web server to upload and download files.",
      "level": 3,
      "page": 248
    },
    {
      "heading": "• A storage system to store files. We allocate 1TB of storage space to store files.",
      "level": 3,
      "page": 248
    },
    {
      "heading": "We spend a few hours setting up an Apache web server, a MySql database, and a directory",
      "level": 3,
      "page": 248
    },
    {
      "heading": "called drive/ as the root directory to store uploaded files. Under drive/ directory, there is a list",
      "level": 3,
      "page": 248
    },
    {
      "heading": "of directories, known as namespaces. Each namespace contains all the uploaded files for that",
      "level": 3,
      "page": 248
    },
    {
      "heading": "user. The filename on the server is kept the same as the original file name. Each file or folder",
      "level": 3,
      "page": 248
    },
    {
      "heading": "can be uniquely identified by joining the namespace and the relative path.",
      "level": 3,
      "page": 248
    },
    {
      "heading": "Figure 15-3 shows an example of how the /drive directory looks like on the left side and its",
      "level": 3,
      "page": 248
    },
    {
      "heading": "expanded view on the right side.",
      "level": 3,
      "page": 248
    },
    {
      "heading": "APIs",
      "level": 3,
      "page": 248
    },
    {
      "heading": "What do the APIs look like? We primary need 3 APIs: upload a file, download a file, and get",
      "level": 3,
      "page": 248
    },
    {
      "heading": "file revisions.",
      "level": 3,
      "page": 248
    },
    {
      "heading": "1. Upload a file to Google Drive",
      "level": 3,
      "page": 248
    },
    {
      "heading": "Two types of uploads are supported:",
      "level": 3,
      "page": 248
    },
    {
      "heading": "• Simple upload. Use this upload type when the file size is small.",
      "level": 3,
      "page": 248
    },
    {
      "heading": "• Resumable upload. Use this upload type when the file size is large and there is high",
      "level": 3,
      "page": 248
    },
    {
      "heading": "chance of network interruption.",
      "level": 3,
      "page": 248
    },
    {
      "heading": "Here is an example of resumable upload API:",
      "level": 3,
      "page": 248
    },
    {
      "heading": "https://api.example.com/files/upload?uploadType=resumable",
      "level": 3,
      "page": 248
    },
    {
      "heading": "Params:",
      "level": 3,
      "page": 248
    },
    {
      "heading": "• uploadType=resumable",
      "level": 3,
      "page": 248
    },
    {
      "heading": "• data: Local file to be uploaded.",
      "level": 3,
      "page": 248
    },
    {
      "heading": "A resumable upload is achieved by the following 3 steps [2]:",
      "level": 3,
      "page": 249
    },
    {
      "heading": "• Send the initial request to retrieve the resumable URL.",
      "level": 3,
      "page": 249
    },
    {
      "heading": "• Upload the data and monitor upload state.",
      "level": 3,
      "page": 249
    },
    {
      "heading": "• If upload is disturbed, resume the upload.",
      "level": 3,
      "page": 249
    },
    {
      "heading": "2. Download a file from Google Drive",
      "level": 3,
      "page": 249
    },
    {
      "heading": "Example API: https://api.example.com/files/download",
      "level": 3,
      "page": 249
    },
    {
      "heading": "Params:",
      "level": 3,
      "page": 249
    },
    {
      "heading": "• path: download file path.",
      "level": 3,
      "page": 249
    },
    {
      "heading": "Example params:",
      "level": 3,
      "page": 249
    },
    {
      "heading": "\"path\": \"/recipes/soup/best_soup.txt\"",
      "level": 3,
      "page": 249
    },
    {
      "heading": "3. Get file revisions",
      "level": 3,
      "page": 249
    },
    {
      "heading": "Example API: https://api.example.com/files/list_revisions",
      "level": 3,
      "page": 249
    },
    {
      "heading": "Params:",
      "level": 3,
      "page": 249
    },
    {
      "heading": "• path: The path to the file you want to get the revision history.",
      "level": 3,
      "page": 249
    },
    {
      "heading": "• limit: The maximum number of revisions to return.",
      "level": 3,
      "page": 249
    },
    {
      "heading": "Example params:",
      "level": 3,
      "page": 249
    },
    {
      "heading": "\"path\": \"/recipes/soup/best_soup.txt\",",
      "level": 3,
      "page": 249
    },
    {
      "heading": "\"limit\": 20",
      "level": 3,
      "page": 249
    },
    {
      "heading": "All the APIs require user authentication and use HTTPS. Secure Sockets Layer (SSL)",
      "level": 3,
      "page": 249
    },
    {
      "heading": "protects data transfer between the client and backend servers.",
      "level": 3,
      "page": 249
    },
    {
      "heading": "Move away from single server",
      "level": 3,
      "page": 249
    },
    {
      "heading": "As more files are uploaded, eventually you get the space full alert as shown in Figure 15-4.",
      "level": 3,
      "page": 249
    },
    {
      "heading": "Only 10 MB of storage space is left! This is an emergency as users cannot upload files",
      "level": 3,
      "page": 249
    },
    {
      "heading": "anymore. The first solution comes to mind is to shard the data, so it is stored on multiple",
      "level": 3,
      "page": 249
    },
    {
      "heading": "storage servers. Figure 15-5 shows an example of sharding based on user_id .",
      "level": 3,
      "page": 249
    },
    {
      "heading": "You pull an all-nighter to set up database sharding and monitor it closely. Everything works",
      "level": 3,
      "page": 250
    },
    {
      "heading": "smoothly again. You have stopped the fire, but you are still worried about potential data",
      "level": 3,
      "page": 250
    },
    {
      "heading": "losses in case of storage server outage. You ask around and your backend guru friend Frank",
      "level": 3,
      "page": 250
    },
    {
      "heading": "told you that many leading companies like Netflix and Airbnb use Amazon S3 for storage.",
      "level": 3,
      "page": 250
    },
    {
      "heading": "“Amazon Simple Storage Service (Amazon S3) is an object storage service that offers",
      "level": 3,
      "page": 250
    },
    {
      "heading": "industry-leading scalability, data availability, security, and performance” [3]. You decide to",
      "level": 3,
      "page": 250
    },
    {
      "heading": "do some research to see if it is a good fit.",
      "level": 3,
      "page": 250
    },
    {
      "heading": "After a lot of reading, you gain a good understanding of the S3 storage system and decide to",
      "level": 3,
      "page": 250
    },
    {
      "heading": "store files in S3. Amazon S3 supports same-region and cross-region replication. A region is a",
      "level": 3,
      "page": 250
    },
    {
      "heading": "geographic area where Amazon web services (AWS) have data centers. As shown in Figure",
      "level": 3,
      "page": 250
    },
    {
      "heading": "15-6, data can be replicated on the same-region (left side) and cross-region (right side).",
      "level": 3,
      "page": 250
    },
    {
      "heading": "Redundant files are stored in multiple regions to guard against data loss and ensure",
      "level": 3,
      "page": 250
    },
    {
      "heading": "availability. A bucket is like a folder in file systems.",
      "level": 3,
      "page": 250
    },
    {
      "heading": "After putting files in S3, you can finally have a good night's sleep without worrying about",
      "level": 3,
      "page": 250
    },
    {
      "heading": "data losses. To stop similar problems from happening in the future, you decide to do further",
      "level": 3,
      "page": 250
    },
    {
      "heading": "research on areas you can improve. Here are a few areas you find:",
      "level": 3,
      "page": 250
    },
    {
      "heading": "evenly distributed traffic, and if a web server goes down, it will redistribute the traffic.",
      "level": 3,
      "page": 251
    },
    {
      "heading": "• Web servers: After a load balancer is added, more web servers can be added/removed",
      "level": 3,
      "page": 251
    },
    {
      "heading": "easily, depending on the traffic load.",
      "level": 3,
      "page": 251
    },
    {
      "heading": "• Metadata database: Move the database out of the server to avoid single point of failure.",
      "level": 3,
      "page": 251
    },
    {
      "heading": "In the meantime, set up data replication and sharding to meet the availability and",
      "level": 3,
      "page": 251
    },
    {
      "heading": "scalability requirements.",
      "level": 3,
      "page": 251
    },
    {
      "heading": "• File storage: Amazon S3 is used for file storage. To ensure availability and durability,",
      "level": 3,
      "page": 251
    },
    {
      "heading": "files are replicated in two separate geographical regions.",
      "level": 3,
      "page": 251
    },
    {
      "heading": "After applying the above improvements, you have successfully decoupled web servers,",
      "level": 3,
      "page": 251
    },
    {
      "heading": "metadata database, and file storage from a single server. The updated design is shown in",
      "level": 3,
      "page": 251
    },
    {
      "heading": "Figure 15-7.",
      "level": 3,
      "page": 251
    },
    {
      "heading": "Sync conflicts",
      "level": 3,
      "page": 251
    },
    {
      "heading": "For a large storage system like Google Drive, sync conflicts happen from time to time. When",
      "level": 3,
      "page": 251
    },
    {
      "heading": "two users modify the same file or folder at the same time, a conflict happens. How can we",
      "level": 3,
      "page": 251
    },
    {
      "heading": "resolve the conflict? Here is our strategy: the first version that gets processed wins, and the",
      "level": 3,
      "page": 251
    },
    {
      "heading": "version that gets processed later receives a conflict. Figure 15-8 shows an example of a sync",
      "level": 3,
      "page": 251
    },
    {
      "heading": "conflict.",
      "level": 3,
      "page": 251
    },
    {
      "heading": "In Figure 15-8, user 1 and user 2 tries to update the same file at the same time, but user 1’s",
      "level": 3,
      "page": 252
    },
    {
      "heading": "file is processed by our system first. User 1’s update operation goes through, but, user 2 gets",
      "level": 3,
      "page": 252
    },
    {
      "heading": "a sync conflict. How can we resolve the conflict for user 2? Our system presents both copies",
      "level": 3,
      "page": 252
    },
    {
      "heading": "of the same file: user 2’s local copy and the latest version from the server (Figure 15-9). User",
      "level": 3,
      "page": 252
    },
    {
      "heading": "2 has the option to merge both files or override one version with the other.",
      "level": 3,
      "page": 252
    },
    {
      "heading": "While multiple users are editing the same document at the same, it is challenging to keep the",
      "level": 3,
      "page": 252
    },
    {
      "heading": "document synchronized. Interested readers should refer to the reference material [4] [5].",
      "level": 3,
      "page": 252
    },
    {
      "heading": "High-level design",
      "level": 3,
      "page": 252
    },
    {
      "heading": "Figure 15-10 illustrates the proposed high-level design. Let us examine each component of",
      "level": 3,
      "page": 252
    },
    {
      "heading": "the system.",
      "level": 3,
      "page": 252
    },
    {
      "heading": "User: A user uses the application either through a browser or mobile app.",
      "level": 3,
      "page": 253
    },
    {
      "heading": "Block servers: Block servers upload blocks to cloud storage. Block storage, referred to as",
      "level": 3,
      "page": 253
    },
    {
      "heading": "can be split into several blocks, each with a unique hash value, stored in our metadata",
      "level": 3,
      "page": 253
    },
    {
      "heading": "database. Each block is treated as an independent object and stored in our storage system",
      "level": 3,
      "page": 253
    },
    {
      "heading": "(S3). To reconstruct a file, blocks are joined in a particular order. As for the block size, we",
      "level": 3,
      "page": 253
    },
    {
      "heading": "use Dropbox as a reference: it sets the maximal size of a block to 4MB [6].",
      "level": 3,
      "page": 253
    },
    {
      "heading": "Cloud storage: A file is split into smaller blocks and stored in cloud storage.",
      "level": 3,
      "page": 253
    },
    {
      "heading": "Cold storage: Cold storage is a computer system designed for storing inactive data, meaning",
      "level": 3,
      "page": 253
    },
    {
      "heading": "files are not accessed for a long time.",
      "level": 3,
      "page": 253
    },
    {
      "heading": "Load balancer: A load balancer evenly distributes requests among API servers.",
      "level": 3,
      "page": 253
    },
    {
      "heading": "API servers: These are responsible for almost everything other than the uploading flow. API",
      "level": 3,
      "page": 253
    },
    {
      "heading": "servers are used for user authentication, managing user profile, updating file metadata, etc.",
      "level": 3,
      "page": 253
    },
    {
      "heading": "Metadata database: It stores metadata of users, files, blocks, versions, etc. Please note that",
      "level": 3,
      "page": 253
    },
    {
      "heading": "files are stored in the cloud and the metadata database only contains metadata.",
      "level": 3,
      "page": 253
    },
    {
      "heading": "Metadata cache: Some of the metadata are cached for fast retrieval.",
      "level": 3,
      "page": 253
    },
    {
      "heading": "Notification service: It is a publisher/subscriber system that allows data to be transferred",
      "level": 3,
      "page": 253
    },
    {
      "heading": "from notification service to clients as certain events happen. In our specific case, notification",
      "level": 3,
      "page": 253
    },
    {
      "heading": "service notifies relevant clients when a file is added/edited/removed elsewhere so they can",
      "level": 3,
      "page": 253
    },
    {
      "heading": "pull the latest changes.",
      "level": 3,
      "page": 253
    },
    {
      "heading": "Offline backup queue: If a client is offline and cannot pull the latest file changes, the offline",
      "level": 3,
      "page": 253
    },
    {
      "heading": "backup queue stores the info so changes will be synced when the client is online.",
      "level": 3,
      "page": 254
    },
    {
      "heading": "We have discussed the design of Google Drive at the high-level. Some of the components are",
      "level": 3,
      "page": 254
    },
    {
      "heading": "complicated and worth careful examination; we will discuss these in detail in the deep dive.",
      "level": 3,
      "page": 254
    },
    {
      "heading": "Step 3 - Design deep dive",
      "level": 3,
      "page": 255
    },
    {
      "heading": "In this section, we will take a close look at the following: block servers, metadata database,",
      "level": 3,
      "page": 255
    },
    {
      "heading": "Block servers",
      "level": 3,
      "page": 255
    },
    {
      "heading": "For large files that are updated regularly, sending the whole file on each update consumes a",
      "level": 3,
      "page": 255
    },
    {
      "heading": "lot of bandwidth. Two optimizations are proposed to minimize the amount of network traffic",
      "level": 3,
      "page": 255
    },
    {
      "heading": "being transmitted:",
      "level": 3,
      "page": 255
    },
    {
      "heading": "• Delta sync. When a file is modified, only modified blocks are synced instead of the",
      "level": 3,
      "page": 255
    },
    {
      "heading": "whole file using a sync algorithm [7] [8].",
      "level": 3,
      "page": 255
    },
    {
      "heading": "• Compression. Applying compression on blocks can significantly reduce the data size.",
      "level": 3,
      "page": 255
    },
    {
      "heading": "Thus, blocks are compressed using compression algorithms depending on file types. For",
      "level": 3,
      "page": 255
    },
    {
      "heading": "example, gzip and bzip2 are used to compress text files. Different compression algorithms",
      "level": 3,
      "page": 255
    },
    {
      "heading": "are needed to compress images and videos.",
      "level": 3,
      "page": 255
    },
    {
      "heading": "In our system, block servers do the heavy lifting work for uploading files. Block servers",
      "level": 3,
      "page": 255
    },
    {
      "heading": "process files passed from clients by splitting a file into blocks, compressing each block, and",
      "level": 3,
      "page": 255
    },
    {
      "heading": "encrypting them. Instead of uploading the whole file to the storage system, only modified",
      "level": 3,
      "page": 255
    },
    {
      "heading": "blocks are transferred.",
      "level": 3,
      "page": 255
    },
    {
      "heading": "Figure 15-11 shows how a block server works when a new file is added.",
      "level": 3,
      "page": 255
    },
    {
      "heading": "• A file is split into smaller blocks.",
      "level": 3,
      "page": 255
    },
    {
      "heading": "• Each block is compressed using compression algorithms.",
      "level": 3,
      "page": 255
    },
    {
      "heading": "• To ensure security, each block is encrypted before it is sent to cloud storage.",
      "level": 3,
      "page": 255
    },
    {
      "heading": "• Blocks are uploaded to the cloud storage.",
      "level": 3,
      "page": 255
    },
    {
      "heading": "Figure 15-12 illustrates delta sync, meaning only modified blocks are transferred to cloud",
      "level": 3,
      "page": 255
    },
    {
      "heading": "storage. Highlighted blocks “block 2” and “block 5” represent changed blocks. Using delta",
      "level": 3,
      "page": 255
    },
    {
      "heading": "sync, only those two blocks are uploaded to the cloud storage.",
      "level": 3,
      "page": 255
    },
    {
      "heading": "Block servers allow us to save network traffic by providing delta sync and compression.",
      "level": 3,
      "page": 256
    },
    {
      "heading": "High consistency requirement",
      "level": 3,
      "page": 256
    },
    {
      "heading": "Our system requires strong consistency by default. It is unacceptable for a file to be shown",
      "level": 3,
      "page": 256
    },
    {
      "heading": "differently by different clients at the same time. The system needs to provide strong",
      "level": 3,
      "page": 256
    },
    {
      "heading": "consistency for metadata cache and database layers.",
      "level": 3,
      "page": 256
    },
    {
      "heading": "Memory caches adopt an eventual consistency model by default, which means different",
      "level": 3,
      "page": 256
    },
    {
      "heading": "replicas might have different data. To achieve strong consistency, we must ensure the",
      "level": 3,
      "page": 256
    },
    {
      "heading": "following:",
      "level": 3,
      "page": 256
    },
    {
      "heading": "• Data in cache replicas and the master is consistent.",
      "level": 3,
      "page": 256
    },
    {
      "heading": "• Invalidate caches on database write to ensure cache and database hold the same value.",
      "level": 3,
      "page": 256
    },
    {
      "heading": "Achieving strong consistency in a relational database is easy because it maintains the ACID",
      "level": 3,
      "page": 256
    },
    {
      "heading": "(Atomicity, Consistency, Isolation, Durability) properties [9]. However, NoSQL databases do",
      "level": 3,
      "page": 256
    },
    {
      "heading": "not support ACID properties by default. ACID properties must be programmatically",
      "level": 3,
      "page": 256
    },
    {
      "heading": "incorporated in synchronization logic. In our design, we choose relational databases because",
      "level": 3,
      "page": 256
    },
    {
      "heading": "the ACID is natively supported.",
      "level": 3,
      "page": 256
    },
    {
      "heading": "Metadata database",
      "level": 3,
      "page": 256
    },
    {
      "heading": "Figure 15-13 shows the database schema design. Please note this is a highly simplified",
      "level": 3,
      "page": 256
    },
    {
      "heading": "version as it only includes the most important tables and interesting fields.",
      "level": 3,
      "page": 256
    },
    {
      "heading": "User: The user table contains basic information about the user such as username, email,",
      "level": 3,
      "page": 257
    },
    {
      "heading": "profile photo, etc.",
      "level": 3,
      "page": 257
    },
    {
      "heading": "Device: Device table stores device info. Push_id is used for sending and receiving mobile",
      "level": 3,
      "page": 257
    },
    {
      "heading": "push notifications. Please note a user can have multiple devices.",
      "level": 3,
      "page": 257
    },
    {
      "heading": "Namespace: A namespace is the root directory of a user.",
      "level": 3,
      "page": 257
    },
    {
      "heading": "File: File table stores everything related to the latest file.",
      "level": 3,
      "page": 257
    },
    {
      "heading": "File_version: It stores version history of a file. Existing rows are read-only to keep the",
      "level": 3,
      "page": 257
    },
    {
      "heading": "integrity of the file revision history.",
      "level": 3,
      "page": 257
    },
    {
      "heading": "Block: It stores everything related to a file block. A file of any version can be reconstructed",
      "level": 3,
      "page": 257
    },
    {
      "heading": "by joining all the blocks in the correct order.",
      "level": 3,
      "page": 257
    },
    {
      "heading": "Upload flow",
      "level": 3,
      "page": 257
    },
    {
      "heading": "Let us discuss what happens when a client uploads a file. To better understand the flow, we",
      "level": 3,
      "page": 257
    },
    {
      "heading": "draw the sequence diagram as shown in Figure 15-14.",
      "level": 3,
      "page": 257
    },
    {
      "heading": "In Figure 15-14, two requests are sent in parallel: add file metadata and upload the file to",
      "level": 3,
      "page": 258
    },
    {
      "heading": "cloud storage. Both requests originate from client 1.",
      "level": 3,
      "page": 258
    },
    {
      "heading": "• Add file metadata.",
      "level": 3,
      "page": 258
    },
    {
      "heading": "1. Client 1 sends a request to add the metadata of the new file.",
      "level": 3,
      "page": 258
    },
    {
      "heading": "2. Store the new file metadata in metadata DB and change the file upload status to",
      "level": 3,
      "page": 258
    },
    {
      "heading": "“pending.”",
      "level": 3,
      "page": 258
    },
    {
      "heading": "3. Notify the notification service that a new file is being added.",
      "level": 3,
      "page": 258
    },
    {
      "heading": "4. The notification service notifies relevant clients (client 2) that a file is being",
      "level": 3,
      "page": 258
    },
    {
      "heading": "uploaded.",
      "level": 3,
      "page": 258
    },
    {
      "heading": "• Upload files to cloud storage.",
      "level": 3,
      "page": 258
    },
    {
      "heading": "2.1 Client 1 uploads the content of the file to block servers.",
      "level": 3,
      "page": 258
    },
    {
      "heading": "2.2 Block servers chunk the files into blocks, compress, encrypt the blocks, and",
      "level": 3,
      "page": 258
    },
    {
      "heading": "upload them to cloud storage.",
      "level": 3,
      "page": 258
    },
    {
      "heading": "2.3 Once the file is uploaded, cloud storage triggers upload completion callback. The",
      "level": 3,
      "page": 258
    },
    {
      "heading": "request is sent to API servers.",
      "level": 3,
      "page": 258
    },
    {
      "heading": "2.4 File status changed to “uploaded” in Metadata DB.",
      "level": 3,
      "page": 258
    },
    {
      "heading": "2.5 Notify the notification service that a file status is changed to “uploaded.”",
      "level": 3,
      "page": 258
    },
    {
      "heading": "2.6 The notification service notifies relevant clients (client 2) that a file is fully",
      "level": 3,
      "page": 258
    },
    {
      "heading": "uploaded.",
      "level": 3,
      "page": 258
    },
    {
      "heading": "When a file is edited, the flow is similar, so we will not repeat it.",
      "level": 3,
      "page": 258
    },
    {
      "heading": "Download flow",
      "level": 3,
      "page": 258
    },
    {
      "heading": "Download flow is triggered when a file is added or edited elsewhere. How does a client know",
      "level": 3,
      "page": 258
    },
    {
      "heading": "if a file is added or edited by another client? There are two ways a client can know:",
      "level": 3,
      "page": 258
    },
    {
      "heading": "• If client A is online while a file is changed by another client, notification service will",
      "level": 3,
      "page": 258
    },
    {
      "heading": "inform client A that changes are made somewhere so it needs to pull the latest data.",
      "level": 3,
      "page": 258
    },
    {
      "heading": "• If client A is offline while a file is changed by another client, data will be saved to the",
      "level": 3,
      "page": 259
    },
    {
      "heading": "cache. When the offline client is online again, it pulls the latest changes.",
      "level": 3,
      "page": 259
    },
    {
      "heading": "Once a client knows a file is changed, it first requests metadata via API servers, then",
      "level": 3,
      "page": 259
    },
    {
      "heading": "downloads blocks to construct the file. Figure 15-15 shows the detailed flow. Note, only the",
      "level": 3,
      "page": 259
    },
    {
      "heading": "most important components are shown in the diagram due to space constraint.",
      "level": 3,
      "page": 259
    },
    {
      "heading": "1. Notification service informs client 2 that a file is changed somewhere else.",
      "level": 3,
      "page": 259
    },
    {
      "heading": "2. Once client 2 knows that new updates are available, it sends a request to fetch metadata.",
      "level": 3,
      "page": 259
    },
    {
      "heading": "3. API servers call metadata DB to fetch metadata of the changes.",
      "level": 3,
      "page": 259
    },
    {
      "heading": "4. Metadata is returned to the API servers.",
      "level": 3,
      "page": 259
    },
    {
      "heading": "5. Client 2 gets the metadata.",
      "level": 3,
      "page": 259
    },
    {
      "heading": "6. Once the client receives the metadata, it sends requests to block servers to download",
      "level": 3,
      "page": 259
    },
    {
      "heading": "blocks.",
      "level": 3,
      "page": 259
    },
    {
      "heading": "7. Block servers first download blocks from cloud storage.",
      "level": 3,
      "page": 259
    },
    {
      "heading": "8. Cloud storage returns blocks to the block servers.",
      "level": 3,
      "page": 259
    },
    {
      "heading": "9. Client 2 downloads all the new blocks to reconstruct the file.",
      "level": 3,
      "page": 259
    },
    {
      "heading": "Notification service",
      "level": 3,
      "page": 259
    },
    {
      "heading": "To maintain file consistency, any mutation of a file performed locally needs to be informed to",
      "level": 3,
      "page": 259
    },
    {
      "heading": "other clients to reduce conflicts. Notification service is built to serve this purpose. At the",
      "level": 3,
      "page": 259
    },
    {
      "heading": "high-level, notification service allows data to be transferred to clients as events happen. Here",
      "level": 3,
      "page": 259
    },
    {
      "heading": "are a few options:",
      "level": 3,
      "page": 259
    },
    {
      "heading": "• Long polling. Dropbox uses long polling [10].",
      "level": 3,
      "page": 259
    },
    {
      "heading": "• WebSocket. WebSocket provides a persistent connection between the client and the",
      "level": 3,
      "page": 259
    },
    {
      "heading": "server. Communication is bi-directional.",
      "level": 3,
      "page": 259
    },
    {
      "heading": "Even though both options work well, we opt for long polling for the following two reasons:",
      "level": 3,
      "page": 259
    },
    {
      "heading": "• Communication for notification service is not bi-directional. The server sends",
      "level": 3,
      "page": 259
    },
    {
      "heading": "information about file changes to the client, but not vice versa.",
      "level": 3,
      "page": 259
    },
    {
      "heading": "• WebSocket is suited for real-time bi-directional communication such as a chat app. For",
      "level": 3,
      "page": 259
    },
    {
      "heading": "Google Drive, notifications are sent infrequently with no burst of data.",
      "level": 3,
      "page": 260
    },
    {
      "heading": "With long polling, each client establishes a long poll connection to the notification service. If",
      "level": 3,
      "page": 260
    },
    {
      "heading": "changes to a file are detected, the client will close the long poll connection. Closing the",
      "level": 3,
      "page": 260
    },
    {
      "heading": "connection means a client must connect to the metadata server to download the latest",
      "level": 3,
      "page": 260
    },
    {
      "heading": "changes. After a response is received or connection timeout is reached, a client immediately",
      "level": 3,
      "page": 260
    },
    {
      "heading": "sends a new request to keep the connection open.",
      "level": 3,
      "page": 260
    },
    {
      "heading": "Save storage space",
      "level": 3,
      "page": 260
    },
    {
      "heading": "To support file version history and ensure reliability, multiple versions of the same file are",
      "level": 3,
      "page": 260
    },
    {
      "heading": "stored across multiple data centers. Storage space can be filled up quickly with frequent",
      "level": 3,
      "page": 260
    },
    {
      "heading": "backups of all file revisions. Three techniques are proposed to reduce storage costs:",
      "level": 3,
      "page": 260
    },
    {
      "heading": "• De-duplicate data blocks. Eliminating redundant blocks at the account level is an easy",
      "level": 3,
      "page": 260
    },
    {
      "heading": "way to save space. Two blocks are identical if they have the same hash value.",
      "level": 3,
      "page": 260
    },
    {
      "heading": "• Adopt an intelligent data backup strategy. Two optimization strategies can be applied:",
      "level": 3,
      "page": 260
    },
    {
      "heading": "• Set a limit: We can set a limit for the number of versions to store. If the limit is",
      "level": 3,
      "page": 260
    },
    {
      "heading": "reached, the oldest version will be replaced with the new version.",
      "level": 3,
      "page": 260
    },
    {
      "heading": "• Keep valuable versions only: Some files might be edited frequently. For example,",
      "level": 3,
      "page": 260
    },
    {
      "heading": "saving every edited version for a heavily modified document could mean the file is",
      "level": 3,
      "page": 260
    },
    {
      "heading": "saved over 1000 times within a short period. To avoid unnecessary copies, we could",
      "level": 3,
      "page": 260
    },
    {
      "heading": "limit the number of saved versions. We give more weight to recent versions.",
      "level": 3,
      "page": 260
    },
    {
      "heading": "Experimentation is helpful to figure out the optimal number of versions to save.",
      "level": 3,
      "page": 260
    },
    {
      "heading": "• Moving infrequently used data to cold storage. Cold data is the data that has not been",
      "level": 3,
      "page": 260
    },
    {
      "heading": "active for months or years. Cold storage like Amazon S3 glacier [11] is much cheaper than",
      "level": 3,
      "page": 260
    },
    {
      "heading": "S3.",
      "level": 3,
      "page": 260
    },
    {
      "heading": "Failure Handling",
      "level": 3,
      "page": 260
    },
    {
      "heading": "Failures can occur in a large-scale system and we must adopt design strategies to address",
      "level": 3,
      "page": 260
    },
    {
      "heading": "these failures. Your interviewer might be interested in hearing about how you handle the",
      "level": 3,
      "page": 260
    },
    {
      "heading": "following system failures:",
      "level": 3,
      "page": 260
    },
    {
      "heading": "• Load balancer failure: If a load balancer fails, the secondary would become active and",
      "level": 3,
      "page": 260
    },
    {
      "heading": "pick up the traffic. Load balancers usually monitor each other using a heartbeat, a periodic",
      "level": 3,
      "page": 260
    },
    {
      "heading": "signal sent between load balancers. A load balancer is considered as failed if it has not sent",
      "level": 3,
      "page": 260
    },
    {
      "heading": "a heartbeat for some time.",
      "level": 3,
      "page": 260
    },
    {
      "heading": "• Block server failure: If a block server fails, other servers pick up unfinished or pending",
      "level": 3,
      "page": 260
    },
    {
      "heading": "jobs.",
      "level": 3,
      "page": 260
    },
    {
      "heading": "• Cloud storage failure: S3 buckets are replicated multiple times in different regions. If",
      "level": 3,
      "page": 260
    },
    {
      "heading": "files are not available in one region, they can be fetched from different regions.",
      "level": 3,
      "page": 260
    },
    {
      "heading": "• API server failure: It is a stateless service. If an API server fails, the traffic is redirected",
      "level": 3,
      "page": 260
    },
    {
      "heading": "to other API servers by a load balancer.",
      "level": 3,
      "page": 260
    },
    {
      "heading": "• Metadata cache failure: Metadata cache servers are replicated multiple times. If one node",
      "level": 3,
      "page": 260
    },
    {
      "heading": "goes down, you can still access other nodes to fetch data. We will bring up a new cache",
      "level": 3,
      "page": 260
    },
    {
      "heading": "server to replace the failed one.",
      "level": 3,
      "page": 260
    },
    {
      "heading": "• Metadata DB failure.",
      "level": 3,
      "page": 260
    },
    {
      "heading": "• Master down: If the master is down, promote one of the slaves to act as a new master",
      "level": 3,
      "page": 260
    },
    {
      "heading": "and bring up a new slave node.",
      "level": 3,
      "page": 260
    },
    {
      "heading": "• Slave down: If a slave is down, you can use another slave for read operations and",
      "level": 3,
      "page": 260
    },
    {
      "heading": "bring another database server to replace the failed one.",
      "level": 3,
      "page": 261
    },
    {
      "heading": "• Notification service failure: Every online user keeps a long poll connection with the",
      "level": 3,
      "page": 261
    },
    {
      "heading": "notification server. Thus, each notification server is connected with many users. According",
      "level": 3,
      "page": 261
    },
    {
      "heading": "to the Dropbox talk in 2012 [6], over 1 million connections are open per machine. If a",
      "level": 3,
      "page": 261
    },
    {
      "heading": "server goes down, all the long poll connections are lost so clients must reconnect to a",
      "level": 3,
      "page": 261
    },
    {
      "heading": "different server. Even though one server can keep many open connections, it cannot",
      "level": 3,
      "page": 261
    },
    {
      "heading": "reconnect all the lost connections at once. Reconnecting with all the lost clients is a",
      "level": 3,
      "page": 261
    },
    {
      "heading": "relatively slow process.",
      "level": 3,
      "page": 261
    },
    {
      "heading": "• Offline backup queue failure: Queues are replicated multiple times. If one queue fails,",
      "level": 3,
      "page": 261
    },
    {
      "heading": "consumers of the queue may need to re-subscribe to the backup queue.",
      "level": 3,
      "page": 261
    },
    {
      "heading": "Step 4 - Wrap up",
      "level": 3,
      "page": 262
    },
    {
      "heading": "In this chapter, we proposed a system design to support Google Drive. The combination of",
      "level": 3,
      "page": 262
    },
    {
      "heading": "strong consistency, low network bandwidth and fast sync make the design interesting. Our",
      "level": 3,
      "page": 262
    },
    {
      "heading": "important component of the system. It uses long polling to keep clients up to date with file",
      "level": 3,
      "page": 262
    },
    {
      "heading": "changes.",
      "level": 3,
      "page": 262
    },
    {
      "heading": "Like any system design interview questions, there is no perfect solution. Every company has",
      "level": 3,
      "page": 262
    },
    {
      "heading": "its unique constraints and you must design a system to fit those constraints. Knowing the",
      "level": 3,
      "page": 262
    },
    {
      "heading": "tradeoffs of your design and technology choices are important. If there are a few minutes left,",
      "level": 3,
      "page": 262
    },
    {
      "heading": "you can talk about different design choices.",
      "level": 3,
      "page": 262
    },
    {
      "heading": "For example, we can upload files directly to cloud storage from the client instead of going",
      "level": 3,
      "page": 262
    },
    {
      "heading": "through block servers. The advantage of this approach is that it makes file upload faster",
      "level": 3,
      "page": 262
    },
    {
      "heading": "because a file only needs to be transferred once to the cloud storage. In our design, a file is",
      "level": 3,
      "page": 262
    },
    {
      "heading": "transferred to block servers first, and then to the cloud storage. However, the new approach",
      "level": 3,
      "page": 262
    },
    {
      "heading": "has a few drawbacks:",
      "level": 3,
      "page": 262
    },
    {
      "heading": "• First, the same chunking, compression, and encryption logic must be implemented on",
      "level": 3,
      "page": 262
    },
    {
      "heading": "different platforms (iOS, Android, Web). It is error-prone and requires a lot of engineering",
      "level": 3,
      "page": 262
    },
    {
      "heading": "effort. In our design, all those logics are implemented in a centralized place: block servers.",
      "level": 3,
      "page": 262
    },
    {
      "heading": "• Second, as a client can easily be hacked or manipulated, implementing encrypting logic",
      "level": 3,
      "page": 262
    },
    {
      "heading": "on the client side is not ideal.",
      "level": 3,
      "page": 262
    },
    {
      "heading": "Another interesting evolution of the system is moving online/offline logic to a separate",
      "level": 3,
      "page": 262
    },
    {
      "heading": "service. Let us call it presence service. By moving presence service out of notification",
      "level": 3,
      "page": 262
    },
    {
      "heading": "servers, online/offline functionality can easily be integrated by other services.",
      "level": 3,
      "page": 262
    },
    {
      "heading": "Congratulations on getting this far! Now give yourself a pat on the back. Good job!",
      "level": 3,
      "page": 262
    },
    {
      "heading": "Reference materials",
      "level": 2,
      "page": 263
    },
    {
      "heading": "[1] Google Drive: https://www.google.com/drive/",
      "level": 3,
      "page": 263
    },
    {
      "heading": "[2] Upload file data: https://developers.google.com/drive/api/v2/manage-uploads",
      "level": 3,
      "page": 263
    },
    {
      "heading": "[3] Amazon S3: https://aws.amazon.com/s3",
      "level": 3,
      "page": 263
    },
    {
      "heading": "[4] Differential Synchronization https://neil.fraser.name/writing/sync/",
      "level": 3,
      "page": 263
    },
    {
      "heading": "[5] Differential Synchronization youtube talk https://www.youtube.com/watch?",
      "level": 3,
      "page": 263
    },
    {
      "heading": "v=S2Hp_1jqpY8",
      "level": 3,
      "page": 263
    },
    {
      "heading": "[6] How We’ve Scaled Dropbox: https://youtu.be/PE4gwstWhmc",
      "level": 3,
      "page": 263
    },
    {
      "heading": "[7] Tridgell, A., & Mackerras, P. (1996). The rsync algorithm.",
      "level": 3,
      "page": 263
    },
    {
      "heading": "[8] Librsync. (n.d.). Retrieved April 18, 2015, from https://github.com/librsync/librsync",
      "level": 3,
      "page": 263
    },
    {
      "heading": "[9] ACID:  https://en.wikipedia.org/wiki/ACID",
      "level": 3,
      "page": 263
    },
    {
      "heading": "[10] Dropbox security white paper:",
      "level": 3,
      "page": 263
    },
    {
      "heading": "https://www.dropbox.com/static/business/resources/Security_Whitepaper.pdf",
      "level": 3,
      "page": 263
    },
    {
      "heading": "[11] Amazon S3 Glacier: https://aws.amazon.com/glacier/faqs/",
      "level": 3,
      "page": 263
    },
    {
      "heading": "CHAPTER 16: THE LEARNING CONTINUES",
      "level": 1,
      "page": 264
    },
    {
      "heading": "Designing good systems requires years of accumulation of knowledge. One shortcut is to dive",
      "level": 3,
      "page": 264
    },
    {
      "heading": "into real-world system architectures. Below is a collection of helpful reading materials. We",
      "level": 3,
      "page": 264
    },
    {
      "heading": "highly recommend you pay attention to both the shared principles and the underlying",
      "level": 3,
      "page": 264
    },
    {
      "heading": "technologies. Researching each technology and understanding what problems it solves is a",
      "level": 3,
      "page": 264
    },
    {
      "heading": "great way to strengthen your knowledge base and refine the design process.",
      "level": 3,
      "page": 264
    },
    {
      "heading": "Real-world systems",
      "level": 3,
      "page": 265
    },
    {
      "heading": "The following materials can help you understand general design ideas of real system",
      "level": 3,
      "page": 265
    },
    {
      "heading": "architectures behind different companies.",
      "level": 3,
      "page": 265
    },
    {
      "heading": "Facebook Timeline: Brought To You By The Power Of Denormalization:",
      "level": 3,
      "page": 265
    },
    {
      "heading": "https://goo.gl/FCNrbm",
      "level": 3,
      "page": 265
    },
    {
      "heading": "Scale at Facebook: https://goo.gl/NGTdCs",
      "level": 3,
      "page": 265
    },
    {
      "heading": "Building Timeline: Scaling up to hold your life story: https://goo.gl/8p5wDV",
      "level": 3,
      "page": 265
    },
    {
      "heading": "Erlang at Facebook (Facebook chat): https://goo.gl/zSLHrj",
      "level": 3,
      "page": 265
    },
    {
      "heading": "Facebook Chat: https://goo.gl/qzSiWC",
      "level": 3,
      "page": 265
    },
    {
      "heading": "Finding a needle in Haystack: Facebook’s photo storage: https://goo.gl/edj4FL",
      "level": 3,
      "page": 265
    },
    {
      "heading": "Serving Facebook Multifeed: Efficiency, performance gains through redesign:",
      "level": 3,
      "page": 265
    },
    {
      "heading": "https://goo.gl/adFVMQ",
      "level": 3,
      "page": 265
    },
    {
      "heading": "Scaling Memcache at Facebook: https://goo.gl/rZiAhX",
      "level": 3,
      "page": 265
    },
    {
      "heading": "TAO: Facebook’s Distributed Data Store for the Social Graph: https://goo.gl/Tk1DyH",
      "level": 3,
      "page": 265
    },
    {
      "heading": "Amazon Architecture: https://goo.gl/k4feoW",
      "level": 3,
      "page": 265
    },
    {
      "heading": "Dynamo: Amazon’s Highly Available Key-value Store: https://goo.gl/C7zxDL",
      "level": 3,
      "page": 265
    },
    {
      "heading": "A 360 Degree View Of The Entire Netflix Stack: https://goo.gl/rYSDTz",
      "level": 3,
      "page": 265
    },
    {
      "heading": "It’s All A/Bout Testing: The Netflix Experimentation Platform: https://goo.gl/agbA4K",
      "level": 3,
      "page": 265
    },
    {
      "heading": "Netflix Recommendations: Beyond the 5 stars (Part 1): https://goo.gl/A4FkYi",
      "level": 3,
      "page": 265
    },
    {
      "heading": "Netflix Recommendations: Beyond the 5 stars (Part 2): https://goo.gl/XNPMXm",
      "level": 3,
      "page": 265
    },
    {
      "heading": "Google Architecture: https://goo.gl/dvkDiY",
      "level": 3,
      "page": 265
    },
    {
      "heading": "The Google File System (Google Docs): https://goo.gl/xj5n9R",
      "level": 3,
      "page": 265
    },
    {
      "heading": "Differential Synchronization (Google Docs): https://goo.gl/9zqG7x",
      "level": 3,
      "page": 265
    },
    {
      "heading": "YouTube Architecture: https://goo.gl/mCPRUF",
      "level": 3,
      "page": 265
    },
    {
      "heading": "Seattle Conference on Scalability: YouTube Scalability: https://goo.gl/dH3zYq",
      "level": 3,
      "page": 265
    },
    {
      "heading": "Bigtable: A Distributed Storage System for Structured Data: https://goo.gl/6NaZca",
      "level": 3,
      "page": 265
    },
    {
      "heading": "Instagram Architecture: 14 Million Users, Terabytes Of Photos, 100s Of Instances, Dozens",
      "level": 3,
      "page": 265
    },
    {
      "heading": "Of Technologies: https://goo.gl/s1VcW5",
      "level": 3,
      "page": 265
    },
    {
      "heading": "The Architecture Twitter Uses To Deal With 150M Active Users: https://goo.gl/EwvfRd",
      "level": 3,
      "page": 265
    },
    {
      "heading": "Scaling Twitter: Making Twitter 10000 Percent Faster: https://goo.gl/nYGC1k",
      "level": 3,
      "page": 265
    },
    {
      "heading": "Announcing Snowflake (Snowflake is a network service for generating unique ID numbers at",
      "level": 3,
      "page": 265
    },
    {
      "heading": "high scale with some simple guarantees): https://goo.gl/GzVWYm",
      "level": 3,
      "page": 265
    },
    {
      "heading": "Timelines at Scale: https://goo.gl/8KbqTy",
      "level": 3,
      "page": 265
    },
    {
      "heading": "How Uber Scales Their Real-Time Market Platform: https://goo.gl/kGZuVy",
      "level": 3,
      "page": 265
    },
    {
      "heading": "Scaling Pinterest: https://goo.gl/KtmjW3",
      "level": 3,
      "page": 265
    },
    {
      "heading": "Pinterest Architecture Update: https://goo.gl/w6rRsf",
      "level": 3,
      "page": 265
    },
    {
      "heading": "A Brief History of Scaling LinkedIn: https://goo.gl/8A1Pi8",
      "level": 3,
      "page": 266
    },
    {
      "heading": "Flickr Architecture: https://goo.gl/dWtgYa",
      "level": 3,
      "page": 266
    },
    {
      "heading": "How We've Scaled Dropbox: https://goo.gl/NjBDtC",
      "level": 3,
      "page": 266
    },
    {
      "heading": "The WhatsApp Architecture Facebook Bought For $19 Billion: https://bit.ly/2AHJnFn",
      "level": 3,
      "page": 266
    },
    {
      "heading": "Company engineering blogs",
      "level": 3,
      "page": 267
    },
    {
      "heading": "If you are going to interview with a company, it is a great idea to read their engineering blogs",
      "level": 3,
      "page": 267
    },
    {
      "heading": "and get familiar with technologies and systems adopted and implemented there. Besides,",
      "level": 3,
      "page": 267
    },
    {
      "heading": "engineering blogs provide invaluable insights about certain fields. Reading them regularly",
      "level": 3,
      "page": 267
    },
    {
      "heading": "could help us become better engineers.",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Here is a list of engineering blogs of well-known large companies and startups.",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Airbnb: https://medium.com/airbnb-engineering",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Amazon: https://developer.amazon.com/blogs",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Asana: https://blog.asana.com/category/eng",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Atlassian: https://developer.atlassian.com/blog",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Bittorrent: http://engineering.bittorrent.com",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Cloudera: https://blog.cloudera.com",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Docker: https://blog.docker.com",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Dropbox: https://blogs.dropbox.com/tech",
      "level": 3,
      "page": 267
    },
    {
      "heading": "eBay: http://www.ebaytechblog.com",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Facebook: https://code.facebook.com/posts",
      "level": 3,
      "page": 267
    },
    {
      "heading": "GitHub: https://githubengineering.com",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Google: https://developers.googleblog.com",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Groupon: https://engineering.groupon.com",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Highscalability: http://highscalability.com",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Instacart: https://tech.instacart.com",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Instagram: https://engineering.instagram.com",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Linkedin: https://engineering.linkedin.com/blog",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Mixpanel: https://mixpanel.com/blog",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Netflix: https://medium.com/netflix-techblog",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Nextdoor: https://engblog.nextdoor.com",
      "level": 3,
      "page": 267
    },
    {
      "heading": "PayPal: https://www.paypal-engineering.com",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Pinterest: https://engineering.pinterest.com",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Quora: https://engineering.quora.com",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Reddit: https://redditblog.com",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Salesforce: https://developer.salesforce.com/blogs/engineering",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Shopify: https://engineering.shopify.com",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Slack: https://slack.engineering",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Soundcloud: https://developers.soundcloud.com/blog",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Spotify: https://labs.spotify.com",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Stripe: https://stripe.com/blog/engineering",
      "level": 3,
      "page": 267
    },
    {
      "heading": "System design primer: https://github.com/donnemartin/system-design-primer",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Twitter: https://blog.twitter.com/engineering/en_us.html",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Thumbtack: https://www.thumbtack.com/engineering",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Uber: http://eng.uber.com",
      "level": 3,
      "page": 267
    },
    {
      "heading": "Yahoo: https://yahooeng.tumblr.com",
      "level": 3,
      "page": 268
    },
    {
      "heading": "Yelp: https://engineeringblog.yelp.com",
      "level": 3,
      "page": 268
    },
    {
      "heading": "Zoom: https://medium.com/zoom-developer-blog",
      "level": 3,
      "page": 268
    },
    {
      "heading": "AFTERWORD",
      "level": 1,
      "page": 269
    },
    {
      "heading": "Congratulations! You are at the end of this interview guide. You have accumulated skills and",
      "level": 3,
      "page": 269
    },
    {
      "heading": "knowledge to design systems. Not everyone has the discipline to learn what you have learned.",
      "level": 3,
      "page": 269
    },
    {
      "heading": "Take a moment and pat yourself on the back. Your hard work will be paid off.",
      "level": 3,
      "page": 269
    },
    {
      "heading": "Landing a dream job is a long journey and requires lots of time and effort. Practice makes",
      "level": 3,
      "page": 269
    },
    {
      "heading": "perfect. Best luck!",
      "level": 3,
      "page": 269
    },
    {
      "heading": "Thank you for buying and reading this book. Without readers like you, our work would not",
      "level": 3,
      "page": 269
    },
    {
      "heading": "exist. We hope you have enjoyed the book!",
      "level": 3,
      "page": 269
    },
    {
      "heading": "If you don’t mind, please review this book on Amazon: https://tinyurl.com/y7d3ltbc It would",
      "level": 3,
      "page": 269
    },
    {
      "heading": "help me attract more wonderful readers like you.",
      "level": 3,
      "page": 269
    },
    {
      "heading": "Please subscribe to our email list if you want to be notified when new chapters are available:",
      "level": 3,
      "page": 269
    },
    {
      "heading": "https://bit.ly/3dtIcsE",
      "level": 3,
      "page": 269
    },
    {
      "heading": "If you have comments or questions about this book, feel free to send us an email at",
      "level": 3,
      "page": 269
    },
    {
      "heading": "systemdesigninsider@gmail.com. Besides, if you notice any errors, please let us know so we",
      "level": 3,
      "page": 269
    },
    {
      "heading": "can make corrections in the next edition. Thank you!",
      "level": 3,
      "page": 269
    }
  ]
}